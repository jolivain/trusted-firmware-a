{
  "comments": [
    {
      "key": {
        "uuid": "dcbb0393_168005ce",
        "filename": "plat/arm/board/arm_fpga/aarch64/fpga_helpers.S",
        "patchSetId": 1
      },
      "lineNbr": 60,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2020-05-19T01:44:17Z",
      "side": 1,
      "message": "Do you not need a barrier here? Independent instructions after this can execute and commit before the loop completes.",
      "revId": "ad91cd5c7a51e0d95a71d5e3c3119936ca7035c3",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "04d05718_5028aafd",
        "filename": "plat/arm/board/arm_fpga/aarch64/fpga_helpers.S",
        "patchSetId": 1
      },
      "lineNbr": 60,
      "author": {
        "id": 1000298
      },
      "writtenOn": "2020-05-19T14:28:02Z",
      "side": 1,
      "message": "I don\u0027t think a barrier is needed here. The loop only checks that the primary processor has written a key value on secondary_core_spinlock to indicate that the C runtime has been initialized. No other PE writes there.",
      "parentUuid": "dcbb0393_168005ce",
      "revId": "ad91cd5c7a51e0d95a71d5e3c3119936ca7035c3",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2b40c2e9_85d3585b",
        "filename": "plat/arm/board/arm_fpga/aarch64/fpga_helpers.S",
        "patchSetId": 1
      },
      "lineNbr": 60,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2020-05-19T16:08:10Z",
      "side": 1,
      "message": "Thanks.. if you don\u0027t have a barrier here, the instructions below including bl fpga_get_cpu_cluster and onwards could execute and complete out-of-order  before the primary core sets the flag and you may still end up writing to the tree_desc before the C run time is initialized.",
      "parentUuid": "04d05718_5028aafd",
      "revId": "ad91cd5c7a51e0d95a71d5e3c3119936ca7035c3",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "482de514_ba6fa144",
        "filename": "plat/arm/board/arm_fpga/aarch64/fpga_helpers.S",
        "patchSetId": 1
      },
      "lineNbr": 60,
      "author": {
        "id": 1000298
      },
      "writtenOn": "2020-05-19T18:44:07Z",
      "side": 1,
      "message": "I am not sure of understanding you here, so please let me know if I am missing something. This function is executed during cold boot and this loop waits until secondary_core_spinlock has the value SECONDARY_CORE_KEY, which is unlikely to happen by chance at power on. So once in bl31_early_platform_setup2() the spinlock variable is set allowing all the cores to move forward. They do not need to follow any particular order as long as it is done after the .bss section has been initialized (which should be enforced by setting the spinlock variable inside bl31_early_platform_setup2()).\n\nfpga_get_cpu_cluster only access to the affinity registers of the CPU to find out the cluster to which the CPU belongs and further accesses to memory are ordered by the call to spin_lock on line 80",
      "parentUuid": "2b40c2e9_85d3585b",
      "revId": "ad91cd5c7a51e0d95a71d5e3c3119936ca7035c3",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7da00be8_206a1e60",
        "filename": "plat/arm/board/arm_fpga/aarch64/fpga_helpers.S",
        "patchSetId": 1
      },
      "lineNbr": 60,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2020-05-20T16:28:09Z",
      "side": 1,
      "message": "Hi Javier, I apologize. i don\u0027t think i was clear. I did not mean ordering of execution of this piece of code with respect to other secondary cores. Assuming you only have 2 PE\u0027s, before the primary cpu sets the flag, if the secondary core is spinning in the loop above, there is nothing preventing the instructions that appear in program order after the loop(specifically the instructions loading and storing to the address for spinlock and power domain tree desrc), from executing out-of-order. To guarantee that the instructions after the secondory_core_spinlock loop are REALLY only executed after loop, you need insert a barrier(dmb) after b.ne 1b. If not, the secondary_core_spinlock will not serve it\u0027s purpose. Does that make sense ?\n\nAlso i think you can use WFE. All you need to do is sevl before entering the loop. You can use sev in the thread that sets the global variable to make sure secondary cores are notified. This is not unlike the spinlock implementation and could save you some power.",
      "parentUuid": "482de514_ba6fa144",
      "revId": "ad91cd5c7a51e0d95a71d5e3c3119936ca7035c3",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4bc29f5a_aca291e5",
        "filename": "plat/arm/board/arm_fpga/aarch64/fpga_helpers.S",
        "patchSetId": 1
      },
      "lineNbr": 60,
      "author": {
        "id": 1000298
      },
      "writtenOn": "2020-05-21T09:44:18Z",
      "side": 1,
      "message": "Hi Raghu,\n\nThank you for your comment, it makes perfect sense now, yes. I will include that change on the next patchset.\nwrt your suggestion of using WFE, I am afraid that this will not work here as the Event Register is not guaranteed to be cleared at reset (see the comment at the beginning of the function). In fact, that was the first approach that I used and it failed during my tests. That is the reason why I used the spinlock variable approach.",
      "parentUuid": "7da00be8_206a1e60",
      "revId": "ad91cd5c7a51e0d95a71d5e3c3119936ca7035c3",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "78b5bd52_22d82f63",
        "filename": "plat/arm/board/arm_fpga/aarch64/fpga_helpers.S",
        "patchSetId": 1
      },
      "lineNbr": 91,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2020-05-19T01:44:17Z",
      "side": 1,
      "message": "Why do you need the dmb sy here ?spin_unlock should take care to ensure all memory ops in the critical section complete.",
      "revId": "ad91cd5c7a51e0d95a71d5e3c3119936ca7035c3",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "836821ef_11d16643",
        "filename": "plat/arm/board/arm_fpga/aarch64/fpga_helpers.S",
        "patchSetId": 1
      },
      "lineNbr": 91,
      "author": {
        "id": 1000298
      },
      "writtenOn": "2020-05-19T14:28:02Z",
      "side": 1,
      "message": "Current implementation of spin_unlock on lib/locks/exclusive/aarch64/spinlock.S does not include barriers.",
      "parentUuid": "78b5bd52_22d82f63",
      "revId": "ad91cd5c7a51e0d95a71d5e3c3119936ca7035c3",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c31fcb1a_ce12dd77",
        "filename": "plat/arm/board/arm_fpga/aarch64/fpga_helpers.S",
        "patchSetId": 1
      },
      "lineNbr": 91,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2020-05-19T16:08:10Z",
      "side": 1,
      "message": "So spin_unlock uses the STLR(store-release) instruction, which has an implicit barrier that ensures all loads/stores before the store that writes to the spin lock is visible to other PE\u0027s. So i don\u0027t think dmb sy is required if that was the reasoning.",
      "parentUuid": "836821ef_11d16643",
      "revId": "ad91cd5c7a51e0d95a71d5e3c3119936ca7035c3",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2478ea51_b0f3b00d",
        "filename": "plat/arm/board/arm_fpga/aarch64/fpga_helpers.S",
        "patchSetId": 1
      },
      "lineNbr": 91,
      "author": {
        "id": 1000298
      },
      "writtenOn": "2020-05-19T18:44:07Z",
      "side": 1,
      "message": "Yes, you are right. I totally missed that. Thanks for pointing it out. I will correct it on the next patchset.",
      "parentUuid": "c31fcb1a_ce12dd77",
      "revId": "ad91cd5c7a51e0d95a71d5e3c3119936ca7035c3",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5ff6e41b_11e2804f",
        "filename": "plat/arm/board/arm_fpga/fpga_bl31_setup.c",
        "patchSetId": 1
      },
      "lineNbr": 45,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2020-05-19T01:44:17Z",
      "side": 1,
      "message": "once again, you likely need a barrier to ensure the store is visible, Not sure why this is set to 0 at the end of the function too. Can you explain the race on a reset ?",
      "revId": "ad91cd5c7a51e0d95a71d5e3c3119936ca7035c3",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a6383ee1_06321a92",
        "filename": "plat/arm/board/arm_fpga/fpga_bl31_setup.c",
        "patchSetId": 1
      },
      "lineNbr": 45,
      "author": {
        "id": 1000298
      },
      "writtenOn": "2020-05-19T14:28:02Z",
      "side": 1,
      "message": "\u003e\u003e once again, you likely need a barrier to ensure the store is visible,\nYes, you are right. I need this change to be visible to other PEs before the variable is set back to 0. I will fix it on the next patchset\n\n\u003e\u003e Not sure why this is set to 0 at the end of the function too. Can you explain the race on a reset ?\nWhen the system resets, the .bss section is initialized to all zeroes by the primary processor at the end of el3_entrypoint_common macro. If any of the secondary processors enters into plat_secondary_cold_boot_setup before secondary_core_spinlock has been initialized to 0, chances are that it will start populating the topology tree before the C runtime is ready, which would lead to its corruption (for instance if it is cleared afterwards as part of the .bss initialization by the primary processor). Setting secondary_core_spinlock to 0 after we know that all the secondary processors have stopped spinning around it, would avoid that.",
      "parentUuid": "5ff6e41b_11e2804f",
      "revId": "ad91cd5c7a51e0d95a71d5e3c3119936ca7035c3",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b5ef61db_c992bd2a",
        "filename": "plat/arm/board/arm_fpga/fpga_bl31_setup.c",
        "patchSetId": 1
      },
      "lineNbr": 45,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2020-05-19T16:08:10Z",
      "side": 1,
      "message": "Thanks. What code between setting secondary_core_spinlock to SECONDARY_CORE_KEY and setting it to 0 ensures that all secondary processors have stopped spinning ? sorry, it is not obvious to me. Also not sure i understand why it is necessary to set it back to 0. I guess i\u0027m not seeing the sequence of events between the primary and secondary cores clearly.",
      "parentUuid": "a6383ee1_06321a92",
      "revId": "ad91cd5c7a51e0d95a71d5e3c3119936ca7035c3",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d0c94c69_6a67e67e",
        "filename": "plat/arm/board/arm_fpga/fpga_bl31_setup.c",
        "patchSetId": 1
      },
      "lineNbr": 45,
      "author": {
        "id": 1000298
      },
      "writtenOn": "2020-05-19T18:44:07Z",
      "side": 1,
      "message": "I think my previous explanation was misleading. Sorry about that. Let me try to explain again more in detail:\n\n1.- When the system boots up (after a cold reset) the secondary CPUs (if any) will execute plat_secondary_cold_boot_setup almost immediately, where they will start populating the topology tree (whose memory is located in the .bss section). In the meantime, the primary CPU will start performing some system initialization, which includes clearing the .bss section. If this happens after one of the secondary CPUs has written his topology information into the tree, this will be corrupted, hence the use of secondary_core_spinlock to make the secondary CPUs to wait until the .bss has been initialized. When we set it here to a specific value (SECONDARY_CORE_KEY) we allow the secondary cores to start populating the topology tree, as by the time the execution reaches here, the .bss section is already cleared.\n\n2.- If, at this point, there were a cold reset caused for instance by a RESET pin assertion, we could not guarantee that the memory would have been cleared by the Reset pin, therefore if the secondary cores reach plat_secondary_cold_boot_setup before the primary one has cleared the .bss section, they could find secondary_core_spinlock set to SECONDARY_CORE_KEY by the previous execution, causing a race condition here. Therefore, clearing this variable after a short period of time (to minimize the chances of a reset in between) should avoid this problem.\n\nHope this is clearer now.\n\nP.S: I just realized that SECONDARY_CORE_KEY might not be a very appropriate name, so I will change it as well.",
      "parentUuid": "b5ef61db_c992bd2a",
      "revId": "ad91cd5c7a51e0d95a71d5e3c3119936ca7035c3",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "685fa0ad_fc221a62",
        "filename": "plat/arm/board/arm_fpga/fpga_bl31_setup.c",
        "patchSetId": 1
      },
      "lineNbr": 45,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2020-05-20T16:28:09Z",
      "side": 1,
      "message": "Thanks. That makes it clear. Perhaps expanding the comment above secondary_core_spinlock \u003d 0 would help :)",
      "parentUuid": "d0c94c69_6a67e67e",
      "revId": "ad91cd5c7a51e0d95a71d5e3c3119936ca7035c3",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "70d2b548_d6c7d248",
        "filename": "plat/arm/board/arm_fpga/fpga_bl31_setup.c",
        "patchSetId": 1
      },
      "lineNbr": 45,
      "author": {
        "id": 1000298
      },
      "writtenOn": "2020-05-21T09:44:18Z",
      "side": 1,
      "message": "That\u0027s a good idea :) I\u0027ll do it",
      "parentUuid": "685fa0ad_fc221a62",
      "revId": "ad91cd5c7a51e0d95a71d5e3c3119936ca7035c3",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9f1040f1_365b376c",
        "filename": "plat/arm/board/arm_fpga/fpga_bl31_setup.c",
        "patchSetId": 1
      },
      "lineNbr": 75,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2020-05-19T01:44:17Z",
      "side": 1,
      "message": "It is generally a bad idea to use delays even thought it may work 99% of the times. You might be better off having the secondary CPU\u0027s send a message back indicating event completion.",
      "revId": "ad91cd5c7a51e0d95a71d5e3c3119936ca7035c3",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f422ffdc_be795100",
        "filename": "plat/arm/board/arm_fpga/fpga_bl31_setup.c",
        "patchSetId": 1
      },
      "lineNbr": 75,
      "author": {
        "id": 1000298
      },
      "writtenOn": "2020-05-19T14:28:02Z",
      "side": 1,
      "message": "I totally agree with you wrt the use of delays. However, in this case, as we do not know how many secondary CPUs the system might have (or even if there are any) we cannot rely on receiving messages from them to carry on. So I thought that the most \"universal\" way to overcome this would be to give some time to the secondary CPUs (if any) to populate the topology tree before moving forward. Not very happy with the use of the delay, though.",
      "parentUuid": "9f1040f1_365b376c",
      "revId": "ad91cd5c7a51e0d95a71d5e3c3119936ca7035c3",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1e36a90e_5174a745",
        "filename": "plat/arm/board/arm_fpga/fpga_bl31_setup.c",
        "patchSetId": 1
      },
      "lineNbr": 75,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2020-05-20T16:28:09Z",
      "side": 1,
      "message": "Thanks for the explanation. I\u0027ve usually seen the number of CPU\u0027s as the platform constant PLATFORM_CORE_COUNT or through e-fuses. If you don;t know the number of secondary CPU\u0027s then i don\u0027t know of a good way around it.",
      "parentUuid": "f422ffdc_be795100",
      "revId": "ad91cd5c7a51e0d95a71d5e3c3119936ca7035c3",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": false
    }
  ]
}