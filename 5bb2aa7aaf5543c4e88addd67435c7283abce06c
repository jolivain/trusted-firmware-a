{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "fdbc2cb0_eb27e90b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000660
      },
      "writtenOn": "2022-10-11T10:14:53Z",
      "side": 1,
      "message": "Few of the test_configs failed were unrelated to this change. Triggering CI again to ensure those tests are getting passed (as failed test_configs are now fixed by other patches).",
      "revId": "5bb2aa7aaf5543c4e88addd67435c7283abce06c",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "badf0c3f_830dd1cd",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000660
      },
      "writtenOn": "2022-10-11T15:36:19Z",
      "side": 1,
      "message": "Failed test_configs are unrelated to this change.\n\nAlso on rebuild: few have passed. Manually providing +1.",
      "revId": "5bb2aa7aaf5543c4e88addd67435c7283abce06c",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3952ea63_e04b7a57",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000043
      },
      "writtenOn": "2022-10-19T10:05:56Z",
      "side": 1,
      "message": "Hi Andre, I noticed a few more cases where we could apply the same logic. I\u0027ve pointed out 3 examples but then got tired ;) Any reason why these other cases were not covered in the patch?",
      "revId": "5bb2aa7aaf5543c4e88addd67435c7283abce06c",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d3489ecf_5a7c82ae",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2022-10-19T12:12:02Z",
      "side": 1,
      "message": "Hmm, I am not sure of this change. My worry is , these helpers are coupled with build time config flags in TF-A to detect whether the firmware has been correctly built to support a feature or not. The build time configs also pull in logic to save and restore feature registers across different worlds. If a higher compatible feature version includes more registers to be saved and restored on context switch, then the validation of build config flags will no longer work as expected ?\n\n",
      "revId": "5bb2aa7aaf5543c4e88addd67435c7283abce06c",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1385db24_374954fc",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000118
      },
      "writtenOn": "2022-10-19T15:25:22Z",
      "side": 1,
      "message": "I am wondering as well. I think I just wanted to test the waters on this issue (to trigger comments like Soby\u0027s), and focused on the features that were easy to verify.\nI will have a go at covering the other bits as well.",
      "parentUuid": "3952ea63_e04b7a57",
      "revId": "5bb2aa7aaf5543c4e88addd67435c7283abce06c",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "424bb2c8_92f64dff",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000118
      },
      "writtenOn": "2022-10-19T15:25:22Z",
      "side": 1,
      "message": "I don\u0027t think the ARM ARM says this explicitly, but if a new feature introduces more registers or more state needs to be saved, we would get a separate feature field, otherwise it\u0027s just not usable for lower ELs (including EL0).\nEven if that would be the case, those would be two separate issues:\n- We need to enable access to the feature if the ID registers are visible to lower ELs. Otherwise a kernel/hypervisor/userland has no way of telling if it can use the feature. The Linux kernel boot protocol explicitly lists this requirement.\n- Saving state should only be needed if EL3 or secure world would use those new registers. We would surely know about that.\n\nBeing very specific about a platform requirement is only feasible for fixed hardware platforms, and doesn\u0027t really work for flexible platforms like the FVP, QEMU, or the ARM FPGAs.\n\nAnd also: if EL3 decides to trap a feature (by not enabling it for lower ELs), it should at least handle that exception. At we moment we just hang *without any clue* whatsoever.\n\nAnd I actually checked all those features handled in this patch explicitly against the ARM ARM and their current usage in TF-A: those feature fields are safe to use with a \"!\u003d 0\" comparison.",
      "parentUuid": "d3489ecf_5a7c82ae",
      "revId": "5bb2aa7aaf5543c4e88addd67435c7283abce06c",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fceaff6d_de8e583b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2022-10-20T10:09:28Z",
      "side": 1,
      "message": "OK, I was taking a look at the ARM Arm and found some exceptions like FEAT_ECV\n\nECV, bits [63:60] Indicates presence of Enhanced Counter Virtualization. Defined values are:\n  0b0000 Enhanced Counter Virtualization is not implemented.\n  0b0001 Enhanced Counter Virtualization is implemented. Supports\n         CNTHCTL_EL2.{EL1TVT, EL1TVCT, EL1NVPCT, EL1NVVCT, EVNTIS},\n         CNTKCTL_EL1.EVNTIS, CNTPCTSS_EL0 counter views, and CNTVCTSS_EL0\n         counter views. Extends the PMSCR_EL1.PCT, PMSCR_EL2.PCT, TRFCR_EL1.TS,\n         and TRFCR_EL2.TS fields.\n  0b0010 As 0b0001, and also includes support for CNTHCTL_EL2.ECV and CNTPOFF_EL2.\n\nSo it seems there are cases when a higher version might pull in additional regs.\nI think the troublesome case is when the feature is used by multiple worlds and silently ignoring the version may result in register leaking between worlds or even missing some initialization for the new version.\n\nEven if a feature is only enabled for NS, I fear that this slack in check might allow some bugs to creep in if EL3 misses some initialization needed for higher versions of the same feature.\n\n\u003e We need to enable access to the feature if the ID registers are visible to lower ELs. Otherwise a kernel/hypervisor/userland has no way of telling if it can use the feature. The Linux kernel boot protocol explicitly lists this requirement.\n\nYes, this needs to be case for EL3 firmware. TF-A should enable all features exposed in feature regs and I would argue that TF-A should flag this up (which it doesn\u0027t today) during boot. Eventually we would like to get to a place where EL3 firmware is able to reflect the Features enabled at EL3 in the ID regs either by trap-emulate or some other hardware mechanism.\n\n\u003e Being very specific about a platform requirement is only feasible for fixed hardware platforms, and doesn\u0027t really work for flexible platforms like the FVP, QEMU, or the ARM FPGAs.\n\nAgree again. In fact the strict validation Build config vs runtime detection of feature is disabled for FVPs due to this problem. The ideal case is for platforms like FVP, TF-A includes the superset of all features that it can enable and dynamically enables them based on runtime detection. This I think is planned as second stage of feature detection work. @Jayanth or Manish can comment further.\n\n\u003e And also: if EL3 decides to trap a feature (by not enabling it for lower ELs), it should at least handle that exception. At we moment we just hang *without any clue* whatsoever.\n\nYes, although I am not sure what the correct handling should be. We could inject an UNDEF instruction abort to the lower EL or print a more helpful panic message from EL3.",
      "parentUuid": "424bb2c8_92f64dff",
      "revId": "5bb2aa7aaf5543c4e88addd67435c7283abce06c",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f0eb6e23_887092fb",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2022-10-20T10:09:28Z",
      "side": 1,
      "message": "Although I have given some comments, I think status quo is not a solution. Perhaps the dynamic feature enablement work should be fast tracked to resolve these kind of issues for FVP.",
      "revId": "5bb2aa7aaf5543c4e88addd67435c7283abce06c",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6829a98f_620fc909",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2022-10-20T10:15:46Z",
      "side": 1,
      "message": "giving a -1 to prevent accidental merge",
      "revId": "5bb2aa7aaf5543c4e88addd67435c7283abce06c",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "278ad571_8d7ac19c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000118
      },
      "writtenOn": "2022-10-20T10:47:02Z",
      "side": 1,
      "message": "Please note that there is an immediate issue: if you run the FVP with ARMv8.9 features enabled, the kernel crashes, because BL31 misses to enable FGT.\nWe should fix that ASAP.\nI think I verified that all the features I touched in this initial version of the patch are safe - there is nothing that needs saving or context switching. I can double check that again.",
      "parentUuid": "f0eb6e23_887092fb",
      "revId": "5bb2aa7aaf5543c4e88addd67435c7283abce06c",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c3be52b9_bdc0dd85",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000118
      },
      "writtenOn": "2022-10-20T10:47:02Z",
      "side": 1,
      "message": "Regarding FEAT_ECV: I think there is something off here, I will investigate. The description of CNTPOFF_EL2 doesn\u0027t mention version 1 or 2, it just speaks of FEAT_ECV.\n\nSo maybe those feature detection macros should be split up, then? I think there are two somewhat separate cases:\n1) FEAT_xxx requires enablement for lower ELs. EL3/BL31 has no interest in those features otherwise.\n2) FEAT_xxx introduces new registers that need to be handled / context-switched.\n\nThe vast majority is in case 1, actually many features don\u0027t even trigger any setting, they are just checked against build time config - which I find a bit odd, as it\u0027s not clear to me what people should do about it. For fixed platforms, the default config should do everything correctly, if people mess with that deliberately, it\u0027s their problem, I think.",
      "parentUuid": "fceaff6d_de8e583b",
      "revId": "5bb2aa7aaf5543c4e88addd67435c7283abce06c",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6dfcf8a0_d40a514e",
        "filename": "include/arch/aarch64/arch_features.h",
        "patchSetId": 2
      },
      "lineNbr": 79,
      "author": {
        "id": 1000043
      },
      "writtenOn": "2022-10-19T10:05:56Z",
      "side": 1,
      "message": "BTI_IMPLEMENTED was an unsigned long long constant (ULL(1)). Which makes me wonder... Should we rather have !\u003d 0ULL here? Presumably read_id_aa64pfr1_el1() returns a 64-bit value, given that the register is 64-bit? So it would more appropriate to compare it against a 64-bit constant? Especially if we want to keep the code MISRA compliant - the type model is quite strict on that.",
      "range": {
        "startLine": 79,
        "startChar": 30,
        "endLine": 79,
        "endChar": 32
      },
      "revId": "5bb2aa7aaf5543c4e88addd67435c7283abce06c",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "95784c23_ec583d1c",
        "filename": "include/arch/aarch64/arch_features.h",
        "patchSetId": 2
      },
      "lineNbr": 79,
      "author": {
        "id": 1000118
      },
      "writtenOn": "2022-10-19T15:25:22Z",
      "side": 1,
      "message": "I was always questioning the purpose of an unsigned 0 to begin with. MISRA is really annoying here, as per the C standard everything between 0 and 127 is unambiguous when it comes to signedness.\nOn top of that comparing against zero is in practise never actually using that constant, but is always special cased in assembly, by checking the Z or N bits in PSTATE, or using other tricks.\n\nI think most of us agree that arguing against MISRA is pointless, so I am fine with having a 0U, if that makes the checker happy. But I don\u0027t think we should go beyond that.",
      "parentUuid": "6dfcf8a0_d40a514e",
      "range": {
        "startLine": 79,
        "startChar": 30,
        "endLine": 79,
        "endChar": 32
      },
      "revId": "5bb2aa7aaf5543c4e88addd67435c7283abce06c",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "57bb187d_3ff2ce12",
        "filename": "include/arch/aarch64/arch_features.h",
        "patchSetId": 2
      },
      "lineNbr": 144,
      "author": {
        "id": 1000043
      },
      "writtenOn": "2022-10-19T10:05:56Z",
      "side": 1,
      "message": "Should this be \u003e\u003d here?",
      "range": {
        "startLine": 144,
        "startChar": 29,
        "endLine": 144,
        "endChar": 31
      },
      "revId": "5bb2aa7aaf5543c4e88addd67435c7283abce06c",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "00d63605_86336e3d",
        "filename": "include/arch/aarch64/arch_features.h",
        "patchSetId": 2
      },
      "lineNbr": 151,
      "author": {
        "id": 1000043
      },
      "writtenOn": "2022-10-19T10:05:56Z",
      "side": 1,
      "message": "Should this be !\u003d 0 here?",
      "range": {
        "startLine": 151,
        "startChar": 3,
        "endLine": 151,
        "endChar": 40
      },
      "revId": "5bb2aa7aaf5543c4e88addd67435c7283abce06c",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d901dce8_77ea7cfd",
        "filename": "include/arch/aarch64/arch_features.h",
        "patchSetId": 2
      },
      "lineNbr": 171,
      "author": {
        "id": 1000043
      },
      "writtenOn": "2022-10-19T10:05:56Z",
      "side": 1,
      "message": "!\u003d 0",
      "range": {
        "startLine": 171,
        "startChar": 24,
        "endLine": 171,
        "endChar": 52
      },
      "revId": "5bb2aa7aaf5543c4e88addd67435c7283abce06c",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    }
  ]
}