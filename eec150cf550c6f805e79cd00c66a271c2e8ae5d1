{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "0fe88a3f_298ce05b",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 9,
      "author": {
        "id": 1000228
      },
      "writtenOn": "2021-06-21T09:10:59Z",
      "side": 1,
      "message": "typo",
      "range": {
        "startLine": 9,
        "startChar": 28,
        "endLine": 9,
        "endChar": 36
      },
      "revId": "eec150cf550c6f805e79cd00c66a271c2e8ae5d1",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "52a9b145_a1afe8fd",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 15,
      "author": {
        "id": 1000228
      },
      "writtenOn": "2021-06-21T09:10:59Z",
      "side": 1,
      "message": "nit: TF-A ðŸ˜Š",
      "range": {
        "startLine": 15,
        "startChar": 43,
        "endLine": 15,
        "endChar": 46
      },
      "revId": "eec150cf550c6f805e79cd00c66a271c2e8ae5d1",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3cea9f49_b8907df4",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 20,
      "author": {
        "id": 1000228
      },
      "writtenOn": "2021-06-21T09:10:59Z",
      "side": 1,
      "message": "This is true for SPIs when affinity routing is enabled. Though in my mind with GICv3 there is still a need for a linear ID to generate SGIs (if used), right? (ICC_SGI1R_EL1.TargetList)",
      "range": {
        "startLine": 19,
        "startChar": 37,
        "endLine": 20,
        "endChar": 54
      },
      "revId": "eec150cf550c6f805e79cd00c66a271c2e8ae5d1",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b17a9a0c_dd4cb82d",
        "filename": "services/std_svc/spmd/spmd_main.c",
        "patchSetId": 3
      },
      "lineNbr": 176,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2021-06-15T22:08:41Z",
      "side": 1,
      "message": "given the other change on using platform specific SPMD messages, can we not get this information through one of those calls? will this still be required?",
      "range": {
        "startLine": 176,
        "startChar": 1,
        "endLine": 176,
        "endChar": 70
      },
      "revId": "eec150cf550c6f805e79cd00c66a271c2e8ae5d1",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a482f7da_590b96b3",
        "filename": "services/std_svc/spmd/spmd_main.c",
        "patchSetId": 3
      },
      "lineNbr": 176,
      "author": {
        "id": 1000655
      },
      "writtenOn": "2021-06-16T08:01:03Z",
      "side": 1,
      "message": "Hi Raghu,\nthese changes were not meant to be one-or-the-other.\nYour suggestion is valid, we had not thought about this before.\nI guess because of following problem:\nWhen you boot a core, you potentially pass some parameters in w0-w7 to the SPMC.\nWhen you do an FFA fastcall, you would also need w0-w7 to pass arguments and results.\nSo the SPMC on a booting core would first need to save somewhere the boot arguments, then prepare and execute the FFA call, and then use the linear id to setup a stack, and then recover the other arguments.\nIt could work easily on secondary cores, where today we potentially have 0 arguments. On the boot core, we don\u0027t need the linear ID early, we could do the FFA call to get the linear ID a bit later.",
      "parentUuid": "b17a9a0c_dd4cb82d",
      "range": {
        "startLine": 176,
        "startChar": 1,
        "endLine": 176,
        "endChar": 70
      },
      "revId": "eec150cf550c6f805e79cd00c66a271c2e8ae5d1",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ff7170e4_ba2d2017",
        "filename": "services/std_svc/spmd/spmd_main.c",
        "patchSetId": 3
      },
      "lineNbr": 176,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2021-06-17T15:36:55Z",
      "side": 1,
      "message": "Ack. I\u0027m okay either way i think, with a slight preference to use the FFA message. Using registers is specific to kinibi though, so i see why it can be of concern to others. Or we could ask ARM to reserve this in the FFA spec and standardize the boot protocol.",
      "parentUuid": "a482f7da_590b96b3",
      "range": {
        "startLine": 176,
        "startChar": 1,
        "endLine": 176,
        "endChar": 70
      },
      "revId": "eec150cf550c6f805e79cd00c66a271c2e8ae5d1",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7f29a907_f5749403",
        "filename": "services/std_svc/spmd/spmd_main.c",
        "patchSetId": 3
      },
      "lineNbr": 176,
      "author": {
        "id": 1000228
      },
      "writtenOn": "2021-06-21T09:10:59Z",
      "side": 1,
      "message": "\u003e given the other change on using platform specific SPMD messages, can we not get this information through one of those calls?\nDo you mean as soon as the boot or secondary core is entered, it immediately emits an SMC to figure out the running core linear id through an SPMC-to-SPMD platform direct message request?\n\u003e  on a booting core would first need to save somewhere the boot arguments\nPer AAPCS64/SMCCCv1.2 you can copy x0-x7 to callee-saved registers (x8-x30) prior to emitting the SMC. So once the TEE is first entered on any core, it can first save the boot arguments to preserved registers, and then retrieve the core linear id through a platform specific service using the interface you defined in the other change.",
      "parentUuid": "ff7170e4_ba2d2017",
      "range": {
        "startLine": 176,
        "startChar": 1,
        "endLine": 176,
        "endChar": 70
      },
      "revId": "eec150cf550c6f805e79cd00c66a271c2e8ae5d1",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b1a719fd_9c119d75",
        "filename": "services/std_svc/spmd/spmd_main.c",
        "patchSetId": 3
      },
      "lineNbr": 176,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2021-06-21T13:57:10Z",
      "side": 1,
      "message": "\u003eDo you mean as soon as the boot or secondary core is entered, it immediately emits an SMC to \u003efigure out the running core linear id through an SPMC-to-SPMD platform direct message request?\n[RK] Yep, more or less what i had in mind.\n\n\u003e\u003ePer AAPCS64/SMCCCv1.2 you can copy x0-x7 to callee-saved registers (x8-x30) prior to emitting the SMC\n[RK] Clever trick. Did not think about that. That should work :)",
      "parentUuid": "7f29a907_f5749403",
      "range": {
        "startLine": 176,
        "startChar": 1,
        "endLine": 176,
        "endChar": 70
      },
      "revId": "eec150cf550c6f805e79cd00c66a271c2e8ae5d1",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a50b1010_29416bee",
        "filename": "services/std_svc/spmd/spmd_main.c",
        "patchSetId": 3
      },
      "lineNbr": 176,
      "author": {
        "id": 1000289
      },
      "writtenOn": "2021-06-22T17:07:42Z",
      "side": 1,
      "message": "\u003e \u003eDo you mean as soon as the boot or secondary core is entered, it immediately emits an SMC to \u003efigure out the running core linear id through an SPMC-to-SPMD platform direct message request?\n\u003e [RK] Yep, more or less what i had in mind.\n\u003e \n\u003e \u003e\u003ePer AAPCS64/SMCCCv1.2 you can copy x0-x7 to callee-saved registers (x8-x30) prior to emitting the SMC\n\u003e [RK] Clever trick. Did not think about that. That should work :)\n\nI have been flip flopping in my head about using an SMC for this. But now I am thinking if on an FF-A enabled partition, we could piggy back on FFA_ID_GET to obtain the linear ID. An input flag bit could request it and it will appear in one of the output registers. What do you reckon?",
      "parentUuid": "b1a719fd_9c119d75",
      "range": {
        "startLine": 176,
        "startChar": 1,
        "endLine": 176,
        "endChar": 70
      },
      "revId": "eec150cf550c6f805e79cd00c66a271c2e8ae5d1",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a0441439_edef1c48",
        "filename": "services/std_svc/spmd/spmd_main.c",
        "patchSetId": 3
      },
      "lineNbr": 176,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2021-06-23T01:09:38Z",
      "side": 1,
      "message": "This works for me as well. Wont ffa_id_get require to have stack etc and a C environment setup? We might need to get the linear ID real early to setup the stack for example.",
      "parentUuid": "a50b1010_29416bee",
      "range": {
        "startLine": 176,
        "startChar": 1,
        "endLine": 176,
        "endChar": 70
      },
      "revId": "eec150cf550c6f805e79cd00c66a271c2e8ae5d1",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "50152b34_6c63fdb5",
        "filename": "services/std_svc/spmd/spmd_main.c",
        "patchSetId": 3
      },
      "lineNbr": 176,
      "author": {
        "id": 1000655
      },
      "writtenOn": "2021-06-24T12:54:45Z",
      "side": 1,
      "message": "\u003e I have been flip flopping in my head about using an SMC for this. But now I am thinking if on an FF-A enabled partition, we could piggy back on FFA_ID_GET to obtain the linear ID. An input flag bit could request it and it will appear in one of the output registers. What do you reckon?\nIt can work.\n\n\u003e Wont ffa_id_get require to have stack etc and a C environment setup?\nToday we call FFA_ID_GET only on boot core, and from C environment. However, it seems x0 is its only parameter, so this should be easy to call from assembler from starting secondary cores.\n\nAlso, on booting core, we can call FFA_ID_GET after saving boot args, but before using core-specific data structures.",
      "parentUuid": "a0441439_edef1c48",
      "range": {
        "startLine": 176,
        "startChar": 1,
        "endLine": 176,
        "endChar": 70
      },
      "revId": "eec150cf550c6f805e79cd00c66a271c2e8ae5d1",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "224e61f6_9c7a2132",
        "filename": "services/std_svc/spmd/spmd_main.c",
        "patchSetId": 3
      },
      "lineNbr": 176,
      "author": {
        "id": 1000289
      },
      "writtenOn": "2021-07-08T16:41:21Z",
      "side": 1,
      "message": "Circling back to this after a while....\n\nThinking about this a bit further from a non-technical viewpoint, using FFA_ID_GET would work but it seems like a bigger change in the TEE and SPMC than just passing the linear ID in a register. When S-EL2 is enabled, the SPMC can populate the linear ID in the VMPIDR. Would that not just solve the problem in the cleanest way? If so, then FFA_ID_GET would be required only if the SPMC is not in S-EL2. \n\nThis gives 3 ways to solve the problem.\n\n1. Pass linear ID in any register x0-x3\n2. Use FFA_ID_GET to get the linear ID\n3. Read the VMPIDR to obtain the linear ID\n\nA TEE would have to migrate from 1 -\u003e 2 -\u003e 3. The following migration path seems simpler to me.\n\n1. Pass linear ID in any register x0-x3\n2. Pass linear ID in any register x4-x7\n3. Read the VMPIDR to obtain the linear ID\n\nWhat do you reckon?",
      "parentUuid": "50152b34_6c63fdb5",
      "range": {
        "startLine": 176,
        "startChar": 1,
        "endLine": 176,
        "endChar": 70
      },
      "revId": "eec150cf550c6f805e79cd00c66a271c2e8ae5d1",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3690c621_27296108",
        "filename": "services/std_svc/spmd/spmd_main.c",
        "patchSetId": 3
      },
      "lineNbr": 176,
      "author": {
        "id": 1000228
      },
      "writtenOn": "2021-08-03T14:19:08Z",
      "side": 1,
      "message": "Any further thought Lukas/Achin? Btw I have some cosmetic SPMD refactoring/cleanup I can share soonish if still willing to pass the id through registers.",
      "parentUuid": "224e61f6_9c7a2132",
      "range": {
        "startLine": 176,
        "startChar": 1,
        "endLine": 176,
        "endChar": 70
      },
      "revId": "eec150cf550c6f805e79cd00c66a271c2e8ae5d1",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5373a71c_0fe46da3",
        "filename": "services/std_svc/spmd/spmd_main.c",
        "patchSetId": 3
      },
      "lineNbr": 176,
      "author": {
        "id": 1000655
      },
      "writtenOn": "2021-08-03T14:24:48Z",
      "side": 1,
      "message": "\u003e 3. The following migration path seems simpler to me.\n\u003e  1. Pass linear ID in any register x0-x3\n\u003e  2. Pass linear ID in any register x4-x7\n\u003e  3. Read the VMPIDR to obtain the linear ID\nThis looks good to me.\n\n\u003e Any further thought Lukas/Achin? Btw I have some cosmetic SPMD refactoring/cleanup I can share soonish if still willing to pass the id through registers.\nHappy to have a look !",
      "parentUuid": "3690c621_27296108",
      "range": {
        "startLine": 176,
        "startChar": 1,
        "endLine": 176,
        "endChar": 70
      },
      "revId": "eec150cf550c6f805e79cd00c66a271c2e8ae5d1",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5f14492a_aee9de52",
        "filename": "services/std_svc/spmd/spmd_main.c",
        "patchSetId": 3
      },
      "lineNbr": 176,
      "author": {
        "id": 1000289
      },
      "writtenOn": "2021-08-05T13:27:32Z",
      "side": 1,
      "message": "\u003e \u003e 3. The following migration path seems simpler to me.\n\u003e \u003e  1. Pass linear ID in any register x0-x3\n\u003e \u003e  2. Pass linear ID in any register x4-x7\n\u003e \u003e  3. Read the VMPIDR to obtain the linear ID\n\u003e This looks good to me.\n\u003e \n\u003e \u003e Any further thought Lukas/Achin? Btw I have some cosmetic SPMD refactoring/cleanup I can share soonish if still willing to pass the id through registers.\n\u003e Happy to have a look !\n\nSGTM too. BTW, do we want to standardise this in the FF-A spec? I am undecided! We do need to ensure that the EL3 SPMC and S-EL2 SPMC do the same thing. Also, will the SPMD do the same for the SPMC?",
      "parentUuid": "5373a71c_0fe46da3",
      "range": {
        "startLine": 176,
        "startChar": 1,
        "endLine": 176,
        "endChar": 70
      },
      "revId": "eec150cf550c6f805e79cd00c66a271c2e8ae5d1",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a3fbd7cc_3567a248",
        "filename": "services/std_svc/spmd/spmd_main.c",
        "patchSetId": 3
      },
      "lineNbr": 176,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2021-08-05T15:56:17Z",
      "side": 1,
      "message": "Achin, sorry to keep poking my nose here. one more thing to keep in mind. For S-EL0 partitions, say that are UP pinned(future) or MP pinned(future), the same problem about finding core linear id may apply. They will not have access to VMPIDR so we may still need an API or option #1 or #2 that survives even after we move to #3.",
      "parentUuid": "5f14492a_aee9de52",
      "range": {
        "startLine": 176,
        "startChar": 1,
        "endLine": 176,
        "endChar": 70
      },
      "revId": "eec150cf550c6f805e79cd00c66a271c2e8ae5d1",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    }
  ]
}