{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "0fe88a3f_298ce05b",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 9,
      "author": {
        "id": 1000228
      },
      "writtenOn": "2021-06-21T09:10:59Z",
      "side": 1,
      "message": "typo",
      "range": {
        "startLine": 9,
        "startChar": 28,
        "endLine": 9,
        "endChar": 36
      },
      "revId": "eec150cf550c6f805e79cd00c66a271c2e8ae5d1",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "52a9b145_a1afe8fd",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 15,
      "author": {
        "id": 1000228
      },
      "writtenOn": "2021-06-21T09:10:59Z",
      "side": 1,
      "message": "nit: TF-A ðŸ˜Š",
      "range": {
        "startLine": 15,
        "startChar": 43,
        "endLine": 15,
        "endChar": 46
      },
      "revId": "eec150cf550c6f805e79cd00c66a271c2e8ae5d1",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3cea9f49_b8907df4",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 20,
      "author": {
        "id": 1000228
      },
      "writtenOn": "2021-06-21T09:10:59Z",
      "side": 1,
      "message": "This is true for SPIs when affinity routing is enabled. Though in my mind with GICv3 there is still a need for a linear ID to generate SGIs (if used), right? (ICC_SGI1R_EL1.TargetList)",
      "range": {
        "startLine": 19,
        "startChar": 37,
        "endLine": 20,
        "endChar": 54
      },
      "revId": "eec150cf550c6f805e79cd00c66a271c2e8ae5d1",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b17a9a0c_dd4cb82d",
        "filename": "services/std_svc/spmd/spmd_main.c",
        "patchSetId": 3
      },
      "lineNbr": 176,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2021-06-15T22:08:41Z",
      "side": 1,
      "message": "given the other change on using platform specific SPMD messages, can we not get this information through one of those calls? will this still be required?",
      "range": {
        "startLine": 176,
        "startChar": 1,
        "endLine": 176,
        "endChar": 70
      },
      "revId": "eec150cf550c6f805e79cd00c66a271c2e8ae5d1",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a482f7da_590b96b3",
        "filename": "services/std_svc/spmd/spmd_main.c",
        "patchSetId": 3
      },
      "lineNbr": 176,
      "author": {
        "id": 1000655
      },
      "writtenOn": "2021-06-16T08:01:03Z",
      "side": 1,
      "message": "Hi Raghu,\nthese changes were not meant to be one-or-the-other.\nYour suggestion is valid, we had not thought about this before.\nI guess because of following problem:\nWhen you boot a core, you potentially pass some parameters in w0-w7 to the SPMC.\nWhen you do an FFA fastcall, you would also need w0-w7 to pass arguments and results.\nSo the SPMC on a booting core would first need to save somewhere the boot arguments, then prepare and execute the FFA call, and then use the linear id to setup a stack, and then recover the other arguments.\nIt could work easily on secondary cores, where today we potentially have 0 arguments. On the boot core, we don\u0027t need the linear ID early, we could do the FFA call to get the linear ID a bit later.",
      "parentUuid": "b17a9a0c_dd4cb82d",
      "range": {
        "startLine": 176,
        "startChar": 1,
        "endLine": 176,
        "endChar": 70
      },
      "revId": "eec150cf550c6f805e79cd00c66a271c2e8ae5d1",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ff7170e4_ba2d2017",
        "filename": "services/std_svc/spmd/spmd_main.c",
        "patchSetId": 3
      },
      "lineNbr": 176,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2021-06-17T15:36:55Z",
      "side": 1,
      "message": "Ack. I\u0027m okay either way i think, with a slight preference to use the FFA message. Using registers is specific to kinibi though, so i see why it can be of concern to others. Or we could ask ARM to reserve this in the FFA spec and standardize the boot protocol.",
      "parentUuid": "a482f7da_590b96b3",
      "range": {
        "startLine": 176,
        "startChar": 1,
        "endLine": 176,
        "endChar": 70
      },
      "revId": "eec150cf550c6f805e79cd00c66a271c2e8ae5d1",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7f29a907_f5749403",
        "filename": "services/std_svc/spmd/spmd_main.c",
        "patchSetId": 3
      },
      "lineNbr": 176,
      "author": {
        "id": 1000228
      },
      "writtenOn": "2021-06-21T09:10:59Z",
      "side": 1,
      "message": "\u003e given the other change on using platform specific SPMD messages, can we not get this information through one of those calls?\nDo you mean as soon as the boot or secondary core is entered, it immediately emits an SMC to figure out the running core linear id through an SPMC-to-SPMD platform direct message request?\n\u003e  on a booting core would first need to save somewhere the boot arguments\nPer AAPCS64/SMCCCv1.2 you can copy x0-x7 to callee-saved registers (x8-x30) prior to emitting the SMC. So once the TEE is first entered on any core, it can first save the boot arguments to preserved registers, and then retrieve the core linear id through a platform specific service using the interface you defined in the other change.",
      "parentUuid": "ff7170e4_ba2d2017",
      "range": {
        "startLine": 176,
        "startChar": 1,
        "endLine": 176,
        "endChar": 70
      },
      "revId": "eec150cf550c6f805e79cd00c66a271c2e8ae5d1",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b1a719fd_9c119d75",
        "filename": "services/std_svc/spmd/spmd_main.c",
        "patchSetId": 3
      },
      "lineNbr": 176,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2021-06-21T13:57:10Z",
      "side": 1,
      "message": "\u003eDo you mean as soon as the boot or secondary core is entered, it immediately emits an SMC to \u003efigure out the running core linear id through an SPMC-to-SPMD platform direct message request?\n[RK] Yep, more or less what i had in mind.\n\n\u003e\u003ePer AAPCS64/SMCCCv1.2 you can copy x0-x7 to callee-saved registers (x8-x30) prior to emitting the SMC\n[RK] Clever trick. Did not think about that. That should work :)",
      "parentUuid": "7f29a907_f5749403",
      "range": {
        "startLine": 176,
        "startChar": 1,
        "endLine": 176,
        "endChar": 70
      },
      "revId": "eec150cf550c6f805e79cd00c66a271c2e8ae5d1",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a50b1010_29416bee",
        "filename": "services/std_svc/spmd/spmd_main.c",
        "patchSetId": 3
      },
      "lineNbr": 176,
      "author": {
        "id": 1000289
      },
      "writtenOn": "2021-06-22T17:07:42Z",
      "side": 1,
      "message": "\u003e \u003eDo you mean as soon as the boot or secondary core is entered, it immediately emits an SMC to \u003efigure out the running core linear id through an SPMC-to-SPMD platform direct message request?\n\u003e [RK] Yep, more or less what i had in mind.\n\u003e \n\u003e \u003e\u003ePer AAPCS64/SMCCCv1.2 you can copy x0-x7 to callee-saved registers (x8-x30) prior to emitting the SMC\n\u003e [RK] Clever trick. Did not think about that. That should work :)\n\nI have been flip flopping in my head about using an SMC for this. But now I am thinking if on an FF-A enabled partition, we could piggy back on FFA_ID_GET to obtain the linear ID. An input flag bit could request it and it will appear in one of the output registers. What do you reckon?",
      "parentUuid": "b1a719fd_9c119d75",
      "range": {
        "startLine": 176,
        "startChar": 1,
        "endLine": 176,
        "endChar": 70
      },
      "revId": "eec150cf550c6f805e79cd00c66a271c2e8ae5d1",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a0441439_edef1c48",
        "filename": "services/std_svc/spmd/spmd_main.c",
        "patchSetId": 3
      },
      "lineNbr": 176,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2021-06-23T01:09:38Z",
      "side": 1,
      "message": "This works for me as well. Wont ffa_id_get require to have stack etc and a C environment setup? We might need to get the linear ID real early to setup the stack for example.",
      "parentUuid": "a50b1010_29416bee",
      "range": {
        "startLine": 176,
        "startChar": 1,
        "endLine": 176,
        "endChar": 70
      },
      "revId": "eec150cf550c6f805e79cd00c66a271c2e8ae5d1",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "50152b34_6c63fdb5",
        "filename": "services/std_svc/spmd/spmd_main.c",
        "patchSetId": 3
      },
      "lineNbr": 176,
      "author": {
        "id": 1000655
      },
      "writtenOn": "2021-06-24T12:54:45Z",
      "side": 1,
      "message": "\u003e I have been flip flopping in my head about using an SMC for this. But now I am thinking if on an FF-A enabled partition, we could piggy back on FFA_ID_GET to obtain the linear ID. An input flag bit could request it and it will appear in one of the output registers. What do you reckon?\nIt can work.\n\n\u003e Wont ffa_id_get require to have stack etc and a C environment setup?\nToday we call FFA_ID_GET only on boot core, and from C environment. However, it seems x0 is its only parameter, so this should be easy to call from assembler from starting secondary cores.\n\nAlso, on booting core, we can call FFA_ID_GET after saving boot args, but before using core-specific data structures.",
      "parentUuid": "a0441439_edef1c48",
      "range": {
        "startLine": 176,
        "startChar": 1,
        "endLine": 176,
        "endChar": 70
      },
      "revId": "eec150cf550c6f805e79cd00c66a271c2e8ae5d1",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "224e61f6_9c7a2132",
        "filename": "services/std_svc/spmd/spmd_main.c",
        "patchSetId": 3
      },
      "lineNbr": 176,
      "author": {
        "id": 1000289
      },
      "writtenOn": "2021-07-08T16:41:21Z",
      "side": 1,
      "message": "Circling back to this after a while....\n\nThinking about this a bit further from a non-technical viewpoint, using FFA_ID_GET would work but it seems like a bigger change in the TEE and SPMC than just passing the linear ID in a register. When S-EL2 is enabled, the SPMC can populate the linear ID in the VMPIDR. Would that not just solve the problem in the cleanest way? If so, then FFA_ID_GET would be required only if the SPMC is not in S-EL2. \n\nThis gives 3 ways to solve the problem.\n\n1. Pass linear ID in any register x0-x3\n2. Use FFA_ID_GET to get the linear ID\n3. Read the VMPIDR to obtain the linear ID\n\nA TEE would have to migrate from 1 -\u003e 2 -\u003e 3. The following migration path seems simpler to me.\n\n1. Pass linear ID in any register x0-x3\n2. Pass linear ID in any register x4-x7\n3. Read the VMPIDR to obtain the linear ID\n\nWhat do you reckon?",
      "parentUuid": "50152b34_6c63fdb5",
      "range": {
        "startLine": 176,
        "startChar": 1,
        "endLine": 176,
        "endChar": 70
      },
      "revId": "eec150cf550c6f805e79cd00c66a271c2e8ae5d1",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3690c621_27296108",
        "filename": "services/std_svc/spmd/spmd_main.c",
        "patchSetId": 3
      },
      "lineNbr": 176,
      "author": {
        "id": 1000228
      },
      "writtenOn": "2021-08-03T14:19:08Z",
      "side": 1,
      "message": "Any further thought Lukas/Achin? Btw I have some cosmetic SPMD refactoring/cleanup I can share soonish if still willing to pass the id through registers.",
      "parentUuid": "224e61f6_9c7a2132",
      "range": {
        "startLine": 176,
        "startChar": 1,
        "endLine": 176,
        "endChar": 70
      },
      "revId": "eec150cf550c6f805e79cd00c66a271c2e8ae5d1",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5373a71c_0fe46da3",
        "filename": "services/std_svc/spmd/spmd_main.c",
        "patchSetId": 3
      },
      "lineNbr": 176,
      "author": {
        "id": 1000655
      },
      "writtenOn": "2021-08-03T14:24:48Z",
      "side": 1,
      "message": "\u003e 3. The following migration path seems simpler to me.\n\u003e  1. Pass linear ID in any register x0-x3\n\u003e  2. Pass linear ID in any register x4-x7\n\u003e  3. Read the VMPIDR to obtain the linear ID\nThis looks good to me.\n\n\u003e Any further thought Lukas/Achin? Btw I have some cosmetic SPMD refactoring/cleanup I can share soonish if still willing to pass the id through registers.\nHappy to have a look !",
      "parentUuid": "3690c621_27296108",
      "range": {
        "startLine": 176,
        "startChar": 1,
        "endLine": 176,
        "endChar": 70
      },
      "revId": "eec150cf550c6f805e79cd00c66a271c2e8ae5d1",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5f14492a_aee9de52",
        "filename": "services/std_svc/spmd/spmd_main.c",
        "patchSetId": 3
      },
      "lineNbr": 176,
      "author": {
        "id": 1000289
      },
      "writtenOn": "2021-08-05T13:27:32Z",
      "side": 1,
      "message": "\u003e \u003e 3. The following migration path seems simpler to me.\n\u003e \u003e  1. Pass linear ID in any register x0-x3\n\u003e \u003e  2. Pass linear ID in any register x4-x7\n\u003e \u003e  3. Read the VMPIDR to obtain the linear ID\n\u003e This looks good to me.\n\u003e \n\u003e \u003e Any further thought Lukas/Achin? Btw I have some cosmetic SPMD refactoring/cleanup I can share soonish if still willing to pass the id through registers.\n\u003e Happy to have a look !\n\nSGTM too. BTW, do we want to standardise this in the FF-A spec? I am undecided! We do need to ensure that the EL3 SPMC and S-EL2 SPMC do the same thing. Also, will the SPMD do the same for the SPMC?",
      "parentUuid": "5373a71c_0fe46da3",
      "range": {
        "startLine": 176,
        "startChar": 1,
        "endLine": 176,
        "endChar": 70
      },
      "revId": "eec150cf550c6f805e79cd00c66a271c2e8ae5d1",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a3fbd7cc_3567a248",
        "filename": "services/std_svc/spmd/spmd_main.c",
        "patchSetId": 3
      },
      "lineNbr": 176,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2021-08-05T15:56:17Z",
      "side": 1,
      "message": "Achin, sorry to keep poking my nose here. one more thing to keep in mind. For S-EL0 partitions, say that are UP pinned(future) or MP pinned(future), the same problem about finding core linear id may apply. They will not have access to VMPIDR so we may still need an API or option #1 or #2 that survives even after we move to #3.",
      "parentUuid": "5f14492a_aee9de52",
      "range": {
        "startLine": 176,
        "startChar": 1,
        "endLine": 176,
        "endChar": 70
      },
      "revId": "eec150cf550c6f805e79cd00c66a271c2e8ae5d1",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a846b6ce_17d12d07",
        "filename": "services/std_svc/spmd/spmd_main.c",
        "patchSetId": 3
      },
      "lineNbr": 176,
      "author": {
        "id": 1000289
      },
      "writtenOn": "2021-08-05T20:21:30Z",
      "side": 1,
      "message": "\u003e Achin, sorry to keep poking my nose here. one more thing to keep in mind. For S-EL0 partitions, say that are UP pinned(future) or MP pinned(future), the same problem about finding core linear id may apply. They will not have access to VMPIDR so we may still need an API or option #1 or #2 that survives even after we move to #3.\n\nRaghu. Your nose poking is much appreciated :). That is a fair point but as you say I would expect S-EL0 SPs to continue using option 2. TBH, I had not considered a S-EL0 SP requirement so thanks for pointing it out.\n\nWhat are your thoughts on adding it to the FF-A spec? It would lessen ambiguity from a SP perspective. However, I am not sure if using an entire register for passing the index is fair. Wondering if reserving 8-bits in a register should be adequate. 255 entries, even sparsely populated should be adequate?",
      "parentUuid": "a3fbd7cc_3567a248",
      "range": {
        "startLine": 176,
        "startChar": 1,
        "endLine": 176,
        "endChar": 70
      },
      "revId": "eec150cf550c6f805e79cd00c66a271c2e8ae5d1",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3387461f_619d012a",
        "filename": "services/std_svc/spmd/spmd_main.c",
        "patchSetId": 3
      },
      "lineNbr": 176,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2021-08-05T21:41:44Z",
      "side": 1,
      "message": "Yep, this would definitely be good to have in the spec. Generally, for things that are IMPDEF, it would be good to have one spec defined method and while allowing the same to be IMPDEF as well.\n8-bits may be a bit short. We already have 96 core multi-socket servers in the market (Cavium) so \u003e 256 core systems are not too far away in the future. So 16 bits should be a safe bet for a while. Agree, stealing an entire register might be wasteful.",
      "parentUuid": "a846b6ce_17d12d07",
      "range": {
        "startLine": 176,
        "startChar": 1,
        "endLine": 176,
        "endChar": 70
      },
      "revId": "eec150cf550c6f805e79cd00c66a271c2e8ae5d1",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2aa4e2e8_b87f7e74",
        "filename": "services/std_svc/spmd/spmd_main.c",
        "patchSetId": 3
      },
      "lineNbr": 176,
      "author": {
        "id": 1000228
      },
      "writtenOn": "2021-08-10T16:24:47Z",
      "side": 1,
      "message": "See https://review.trustedfirmware.org/c/TF-A/trusted-firmware-a/+/11009\nIIUC this takes care of option 2. I restricted the change to only passing the core linear id to an S-EL1 SPMC. If we\u0027re aligned I can update the TF-A doc as an impdef behavior (https://trustedfirmware-a.readthedocs.io/en/latest/components/secure-partition-manager.html#spmc-boot). Now I\u0027m wondering, are you suggesting above that when secure virtualization is enabled, we want to pass the information in the same way?\nI\u0027m thinking the following would apply:\nEL3 to SEL1 SPMC: pass the core linear id through X4\nEL3 to SEL2 SPMC: not passed\nSEL2 SPMC to SEL1 SP: the MPIDR is read by the SP to determine the core linear id (hence no need for passing through a register at boot)\nDoes it make sense?\n\n@Raghu, for SEL0 SPs, would it be ok to trap the MPIDR_EL1 system register read to Hafnium, service it and resume?",
      "parentUuid": "3387461f_619d012a",
      "range": {
        "startLine": 176,
        "startChar": 1,
        "endLine": 176,
        "endChar": 70
      },
      "revId": "eec150cf550c6f805e79cd00c66a271c2e8ae5d1",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "11a4fe81_458f650b",
        "filename": "services/std_svc/spmd/spmd_main.c",
        "patchSetId": 3
      },
      "lineNbr": 176,
      "author": {
        "id": 1000289
      },
      "writtenOn": "2021-08-10T17:11:58Z",
      "side": 1,
      "message": "\u003e See https://review.trustedfirmware.org/c/TF-A/trusted-firmware-a/+/11009\n\u003e IIUC this takes care of option 2. I restricted the change to only passing the core linear id to an S-EL1 SPMC. If we\u0027re aligned I can update the TF-A doc as an impdef behavior (https://trustedfirmware-a.readthedocs.io/en/latest/components/secure-partition-manager.html#spmc-boot). Now I\u0027m wondering, are you suggesting above that when secure virtualization is enabled, we want to pass the information in the same way?\n\u003e I\u0027m thinking the following would apply:\n\u003e EL3 to SEL1 SPMC: pass the core linear id through X4\n\u003e EL3 to SEL2 SPMC: not passed\n\u003e SEL2 SPMC to SEL1 SP: the MPIDR is read by the SP to determine the core linear id (hence no need for passing through a register at boot)\n\u003e Does it make sense?\n\u003e \n\u003e @Raghu, for SEL0 SPs, would it be ok to trap the MPIDR_EL1 system register read to Hafnium, service it and resume?\n\n@Olivier, would it not be simpler if,\n\n1. EL3 SPMD always passed this info the SPMC in S-EL1 and S-EL2\n2. Any SPMC always passed this info to any SP it manages\n\nIt would be upto the SPMC (case 1) and the SP (case 2) to use this info or not. \n\nMPIDR_EL1 is typically not accessed by apps afaiu. So trapping these accesses to Hf from S-EL0 does not seem to lend itself naturally to the architecture model. Also, other SPMCs would have to do the same. Would it not be easier to leave it to the S-EL0 SP to retrieve the passed linear ID and use it as per its own requirements?",
      "parentUuid": "2aa4e2e8_b87f7e74",
      "range": {
        "startLine": 176,
        "startChar": 1,
        "endLine": 176,
        "endChar": 70
      },
      "revId": "eec150cf550c6f805e79cd00c66a271c2e8ae5d1",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ead22194_0fe00a64",
        "filename": "services/std_svc/spmd/spmd_main.c",
        "patchSetId": 3
      },
      "lineNbr": 176,
      "author": {
        "id": 1000228
      },
      "writtenOn": "2021-08-11T07:50:17Z",
      "side": 1,
      "message": "Agree with your comments, Achin!",
      "parentUuid": "11a4fe81_458f650b",
      "range": {
        "startLine": 176,
        "startChar": 1,
        "endLine": 176,
        "endChar": 70
      },
      "revId": "eec150cf550c6f805e79cd00c66a271c2e8ae5d1",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "658e2e73_6276cb41",
        "filename": "services/std_svc/spmd/spmd_main.c",
        "patchSetId": 3
      },
      "lineNbr": 176,
      "author": {
        "id": 1000228
      },
      "writtenOn": "2021-08-20T08:36:37Z",
      "side": 1,
      "message": "I updated https://review.trustedfirmware.org/c/TF-A/trusted-firmware-a/+/11009\nHopefully it covers bullet 1. and supersedes current change.\n@Lukas how do you want to proceed?\nCheck the other change works for you and abandon current change?\nI can copy the justification from current change commit message to 11009 and add you as sign-off if you agree.",
      "parentUuid": "ead22194_0fe00a64",
      "range": {
        "startLine": 176,
        "startChar": 1,
        "endLine": 176,
        "endChar": 70
      },
      "revId": "eec150cf550c6f805e79cd00c66a271c2e8ae5d1",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    }
  ]
}