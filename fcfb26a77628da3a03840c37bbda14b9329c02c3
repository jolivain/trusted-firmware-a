{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "46b50e35_b5c168b5",
        "filename": "lib/cpus/aarch64/cortex_a78c.S",
        "patchSetId": 3
      },
      "lineNbr": 207,
      "author": {
        "id": 1000910
      },
      "writtenOn": "2023-03-08T16:30:09Z",
      "side": 1,
      "message": "Doubt: Between the cpu_rev_var_range and #CPU_REV(0,2), is there a preferred method?",
      "revId": "fcfb26a77628da3a03840c37bbda14b9329c02c3",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e6e1f299_877fd922",
        "filename": "lib/cpus/aarch64/cortex_a78c.S",
        "patchSetId": 3
      },
      "lineNbr": 207,
      "author": {
        "id": 1000098
      },
      "writtenOn": "2023-03-08T16:39:22Z",
      "side": 1,
      "message": "I think the use of cpu_rev_var_range is necessary when the starting revision is not r0p0(which is true in this case as it is r0p1).\nCPU_REV is purely a macro to derive the encoding for a revision. So, for example, rather than using 0x13 to represent r1p3, we could use CPU_REV(1,3).",
      "parentUuid": "46b50e35_b5c168b5",
      "revId": "fcfb26a77628da3a03840c37bbda14b9329c02c3",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    }
  ]
}