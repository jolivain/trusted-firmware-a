{
  "comments": [
    {
      "key": {
        "uuid": "79e1809c_4518ce34",
        "filename": "drivers/arm/sbsa/sbsa.c",
        "patchSetId": 2
      },
      "lineNbr": 53,
      "author": {
        "id": 1000119
      },
      "writtenOn": "2020-08-31T15:23:35Z",
      "side": 1,
      "message": "Patchset:1 I had two handlers but I am not sure we need to differentiate at the moment.",
      "revId": "141f7e085ac7ae620259056dc20aa9e8321d6419",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "47fdcb67_2bc56c4b",
        "filename": "drivers/arm/sbsa/sbsa.c",
        "patchSetId": 2
      },
      "lineNbr": 59,
      "author": {
        "id": 1000119
      },
      "writtenOn": "2020-08-31T15:27:00Z",
      "side": 1,
      "message": "this requires psci_system_reset2() to be exported \nhttps://review.trustedfirmware.org/c/TF-A/trusted-firmware-a/+/5458",
      "revId": "141f7e085ac7ae620259056dc20aa9e8321d6419",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "eb31788b_42efa03c",
        "filename": "drivers/arm/sbsa/sbsa.c",
        "patchSetId": 2
      },
      "lineNbr": 67,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2020-08-31T15:51:23Z",
      "side": 1,
      "message": "should we indicate ws1 and ws0 in the names? Also do we really reset the system on a ws0 trusted watch dog? Typically, when there is trusted ws0 to EL3, we simply reset the ws0 watchdog and keep running, similar to how say linux handles non-secure ws0.. not sure i understand why we reset the system on secure/trusted ws0.",
      "range": {
        "startLine": 67,
        "startChar": 31,
        "endLine": 67,
        "endChar": 50
      },
      "revId": "141f7e085ac7ae620259056dc20aa9e8321d6419",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b30ed1b2_01d4c5a7",
        "filename": "drivers/arm/sbsa/sbsa.c",
        "patchSetId": 2
      },
      "lineNbr": 67,
      "author": {
        "id": 1000119
      },
      "writtenOn": "2020-08-31T16:27:17Z",
      "side": 1,
      "message": "Thanks. I have been thinking the same but could not define what should be default behavior.\nIf the default behavior can differ or can not be enforced then that would motivate to have separate handlers for both.\n\nPrimary goal of watchdog is to *recover* and reset is the ultimate option.\n\n  Secure watchdog WS0 might not mean a terminal error condition. While that is platform specific we must give option to bailout without resetting the platform by the default handler. ie. platform may take some action to recover and might want default handler to skip the reset. In that case how do I skip the reset at default handler. Let me think.\n\nI don\u0027t want to fully override the handlers by platforms as I think there will be more generic set of actions in future within this default handlers which platforms can benefit.",
      "parentUuid": "eb31788b_42efa03c",
      "range": {
        "startLine": 67,
        "startChar": 31,
        "endLine": 67,
        "endChar": 50
      },
      "revId": "141f7e085ac7ae620259056dc20aa9e8321d6419",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8b895cdd_8a238388",
        "filename": "drivers/arm/sbsa/sbsa.c",
        "patchSetId": 2
      },
      "lineNbr": 67,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2020-08-31T17:27:29Z",
      "side": 1,
      "message": "agree. I think it might be better to separate out the handlers for secure Ws0 and non-secure WS1 watchdogs as entirely platform hooks to do what they please. The default handler could you what you have in sbsa_wdog_handler(rename to plat_whatever).\nWS0\u0027s are not used to recover/reset usually and are used to know that a component is alive. WS1 is used to notify that a component is not active since WS0 is not being actively reset.",
      "parentUuid": "b30ed1b2_01d4c5a7",
      "range": {
        "startLine": 67,
        "startChar": 31,
        "endLine": 67,
        "endChar": 50
      },
      "revId": "141f7e085ac7ae620259056dc20aa9e8321d6419",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7b9ffa0e_de117142",
        "filename": "drivers/arm/sbsa/sbsa.c",
        "patchSetId": 2
      },
      "lineNbr": 67,
      "author": {
        "id": 1000119
      },
      "writtenOn": "2020-09-01T07:28:15Z",
      "side": 1,
      "message": "I wanted to see if we can define a default behavior for these conditions.\n\nNTWDG WS0 (EL1/2) -  linux does a panic then optionally crashdump and reset. I have seen platforms using watchdog ISR to know the component is alive but I think the former is a proper usage. ie. detect a lockup and if possible give more information about it.\n\nNTWDG WS1 (EL3) -  I think we can do reset as default behavior like in this handler.\n\nTWDGWS0 (EL3) -  I think panic() can be a default behavior instead of reset2().\nLet platform completely override as of now.\n\nAnd as side discussion about the usage of TWDGWS0, If we refresh the watchdog in this G0_EL3 ISR it is not going to detect any hang in S_EL1/S_EL2. And if its stuck in EL3 then anyway no interrupts can come. Correct me if I am missing something. So I think instead of reloading in WS0 we should reload in some other low prio context whose hang we intend to detect. And this interrupt will give opportunity to collect more information about that hang.",
      "parentUuid": "8b895cdd_8a238388",
      "range": {
        "startLine": 67,
        "startChar": 31,
        "endLine": 67,
        "endChar": 50
      },
      "revId": "141f7e085ac7ae620259056dc20aa9e8321d6419",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2519380c_877d8950",
        "filename": "drivers/arm/sbsa/sbsa.c",
        "patchSetId": 2
      },
      "lineNbr": 67,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2020-09-01T23:05:12Z",
      "side": 1,
      "message": "Fair enough. The decision of what is the proper usage, i think, is best left to the platform. The default behavior can be what you propose. I was thinking of using the watchdog to detect EL3 hangs such that TWDG WS1 would be directed to something like an SCP(system control processor) to detect if the application processors has hung but you could argue for it\u0027s use to detect S-EL1/2 hangs. In this case, would we not want a handler for TWDG WS1 as opposed to a TWDG WS0 in EL3?",
      "parentUuid": "7b9ffa0e_de117142",
      "range": {
        "startLine": 67,
        "startChar": 31,
        "endLine": 67,
        "endChar": 50
      },
      "revId": "141f7e085ac7ae620259056dc20aa9e8321d6419",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "503f006d_5f2ed13a",
        "filename": "drivers/arm/sbsa/sbsa.c",
        "patchSetId": 2
      },
      "lineNbr": 67,
      "author": {
        "id": 1000119
      },
      "writtenOn": "2020-09-02T05:15:41Z",
      "side": 1,
      "message": "I see TWDGWS1 as the traditional watchdog hardware reset. So it must be handled by another agent (SCP) to ensure the reliability. And system will recover from EL3 hang or other hardware lockups. And there is core specific debug context in this case.\n\nAll other cases ie if EL3 G0 ISR can be taken then WS0 will give opportunity to collect debug info.\nRefreshing of watchdog should be done by another context lower prio than TWDGWS0 ISR. \n-a low priority thread (to detect hang in scheduling) Or\n-a low prio ISR (to detect interrupt lockup) Or\n-start of some finite operation, eg: std /fast smc service. to detect/*recover* from a hang in that.",
      "parentUuid": "2519380c_877d8950",
      "range": {
        "startLine": 67,
        "startChar": 31,
        "endLine": 67,
        "endChar": 50
      },
      "revId": "141f7e085ac7ae620259056dc20aa9e8321d6419",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7134c288_48d0fe33",
        "filename": "drivers/arm/sbsa/sbsa.c",
        "patchSetId": 2
      },
      "lineNbr": 67,
      "author": {
        "id": 1000119
      },
      "writtenOn": "2020-09-02T05:17:51Z",
      "side": 1,
      "message": "^ there is no core specific debug context in case of TWDGWS1 (SCP).",
      "parentUuid": "503f006d_5f2ed13a",
      "range": {
        "startLine": 67,
        "startChar": 31,
        "endLine": 67,
        "endChar": 50
      },
      "revId": "141f7e085ac7ae620259056dc20aa9e8321d6419",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1aa81eb5_8d198a1a",
        "filename": "drivers/arm/sbsa/sbsa.c",
        "patchSetId": 2
      },
      "lineNbr": 67,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2020-09-02T21:58:20Z",
      "side": 1,
      "message": "okay let me ask you another question. Why don\u0027t we handle NTWDG WS0 interrupt in EL3 but handle TWDG WS0 interrupt in EL3? What is the difference between the two in it\u0027s use(other than secure vs non-secure)? If TWDG WS0 is to be used like linux, shouldnt the interrupt be handled in S-EL2 or S-EL1?",
      "parentUuid": "7134c288_48d0fe33",
      "range": {
        "startLine": 67,
        "startChar": 31,
        "endLine": 67,
        "endChar": 50
      },
      "revId": "141f7e085ac7ae620259056dc20aa9e8321d6419",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c8aa38b2_b0528d23",
        "filename": "drivers/arm/sbsa/sbsa.c",
        "patchSetId": 2
      },
      "lineNbr": 67,
      "author": {
        "id": 1000119
      },
      "writtenOn": "2020-09-03T08:38:48Z",
      "side": 1,
      "message": "NTWDG WS0 usage is defined by spec and linux implementation. WS0(optional)-EL1/EL2,  WS1-EL3.\n\nTWDG WS0 to be defined by TF-A. WS1 is clear.\nWhat are the choices for WS0 usage. Or rather the TWDG usage.\n\n1- Reload WDG *periodically* in EL3 ISR\nIt will result in *WS1* if EL3 is stuck as WS0 did not reload. All other hangs \"S_ELx/NS_ELx/other core EL3 hang\" this interrupt will keep refreshing the wdg and no detection.\nBut this means we keep refreshing the twdg all the time.\n\n2- reload WDG in a platform specific application (secure) or platform specific secure services.\nIf WS0 happens means you start collecting secure side contexts. and possibly indicate linux via sdei.\n\n\nThe usage of NTWDG is open to linux application. But NTWDGWS1 usage is for crashing.\nThe usage of TWDG itself is open like linux and I feel by giving plat override for TWDGWS1 we do not enforce any policy. That way the patch looks complete to me in its scope.",
      "parentUuid": "1aa81eb5_8d198a1a",
      "range": {
        "startLine": 67,
        "startChar": 31,
        "endLine": 67,
        "endChar": 50
      },
      "revId": "141f7e085ac7ae620259056dc20aa9e8321d6419",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cff1c191_6e8497b1",
        "filename": "drivers/arm/sbsa/sbsa.c",
        "patchSetId": 2
      },
      "lineNbr": 67,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2020-09-03T17:39:30Z",
      "side": 1,
      "message": "Alright. Fair enough. Latest patch looks good to me since platform can override behavior of interrupt handler and can choose not to register TWDGWS0 in EL3 at all based on PLAT_SBSA_TWDG_PRI.",
      "parentUuid": "c8aa38b2_b0528d23",
      "range": {
        "startLine": 67,
        "startChar": 31,
        "endLine": 67,
        "endChar": 50
      },
      "revId": "141f7e085ac7ae620259056dc20aa9e8321d6419",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    }
  ]
}