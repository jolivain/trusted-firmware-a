{
  "comments": [
    {
      "key": {
        "uuid": "5f474e19_c4f97e17",
        "filename": "plat/arm/board/arm_fpga/aarch64/fpga_helpers.S",
        "patchSetId": 26
      },
      "lineNbr": 61,
      "author": {
        "id": 1000118
      },
      "writtenOn": "2020-07-21T18:58:46Z",
      "side": 1,
      "message": "Please add a comment about what this is supposed to do, something like:\n\"Prevents reordering of the store into fpga_valid_mpids below.\"",
      "revId": "5d85bdd60e3edeb2ae02f5cb78301cb56de4c4df",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "24d2daca_864ca11f",
        "filename": "plat/arm/board/arm_fpga/aarch64/fpga_helpers.S",
        "patchSetId": 26
      },
      "lineNbr": 61,
      "author": {
        "id": 1000298
      },
      "writtenOn": "2020-07-22T11:31:38Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "5f474e19_c4f97e17",
      "revId": "5d85bdd60e3edeb2ae02f5cb78301cb56de4c4df",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fe4f9368_71e92fcf",
        "filename": "plat/arm/board/arm_fpga/aarch64/fpga_helpers.S",
        "patchSetId": 26
      },
      "lineNbr": 69,
      "author": {
        "id": 1000118
      },
      "writtenOn": "2020-07-21T18:58:46Z",
      "side": 1,
      "message": "Can\u0027t this just be \"mov w5, #VALID_MPID\"? Cheaper than a memory access. Otherwise good idea to store just a byte, that saves us some memory.",
      "revId": "5d85bdd60e3edeb2ae02f5cb78301cb56de4c4df",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e3703bf2_7d647440",
        "filename": "plat/arm/board/arm_fpga/aarch64/fpga_helpers.S",
        "patchSetId": 26
      },
      "lineNbr": 69,
      "author": {
        "id": 1000118
      },
      "writtenOn": "2020-07-22T10:04:11Z",
      "side": 1,
      "message": "I was just thinking about it: we need the MPIDRs of all cores for the devicetree. So I guess we need keep the 32-bit per core storage.",
      "parentUuid": "fe4f9368_71e92fcf",
      "revId": "5d85bdd60e3edeb2ae02f5cb78301cb56de4c4df",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "01c4e452_1dbcf226",
        "filename": "plat/arm/board/arm_fpga/aarch64/fpga_helpers.S",
        "patchSetId": 26
      },
      "lineNbr": 69,
      "author": {
        "id": 1000298
      },
      "writtenOn": "2020-07-22T11:31:38Z",
      "side": 1,
      "message": "Ack\n\nAs the PSCI library is not able to handle sparse CPUIDs, we use the hardcoded affinity levels to create a tree including all the possible clusters and cores so CPUIDs are always created based on those hardcoded limits.\n\nThen we only need an array with an entry per CPUID indicating whether that ID is valid or not. That will be used by plat_core_pos_by_mpidr() once it  calculates a CPUID.",
      "parentUuid": "fe4f9368_71e92fcf",
      "revId": "5d85bdd60e3edeb2ae02f5cb78301cb56de4c4df",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0491aa82_68bc0b02",
        "filename": "plat/arm/board/arm_fpga/aarch64/fpga_helpers.S",
        "patchSetId": 26
      },
      "lineNbr": 69,
      "author": {
        "id": 1000118
      },
      "writtenOn": "2020-07-22T12:20:40Z",
      "side": 1,
      "message": "OK, so want to stay with a byte per PE, then later, in the DT population code, iterate over the max topology and use plat_core_pos_by_mpidr() to filter for non-existing cores?\nSounds good to me. I ran into memory issues before, so every byte saved is welcome.",
      "parentUuid": "01c4e452_1dbcf226",
      "revId": "5d85bdd60e3edeb2ae02f5cb78301cb56de4c4df",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "414dee5b_de446732",
        "filename": "plat/arm/board/arm_fpga/aarch64/fpga_helpers.S",
        "patchSetId": 26
      },
      "lineNbr": 133,
      "author": {
        "id": 1000118
      },
      "writtenOn": "2020-07-21T18:58:46Z",
      "side": 1,
      "message": "Can you move this up into the prototype comment above?",
      "revId": "5d85bdd60e3edeb2ae02f5cb78301cb56de4c4df",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3de58bd1_18773b40",
        "filename": "plat/arm/board/arm_fpga/aarch64/fpga_helpers.S",
        "patchSetId": 26
      },
      "lineNbr": 133,
      "author": {
        "id": 1000298
      },
      "writtenOn": "2020-07-22T11:31:38Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "414dee5b_de446732",
      "revId": "5d85bdd60e3edeb2ae02f5cb78301cb56de4c4df",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b7d7495d_4e43cf1a",
        "filename": "plat/arm/board/arm_fpga/aarch64/fpga_helpers.S",
        "patchSetId": 26
      },
      "lineNbr": 141,
      "author": {
        "id": 1000118
      },
      "writtenOn": "2020-07-21T18:58:46Z",
      "side": 1,
      "message": "I thought that plat_my_core_pos() does not need to do any checks - a major reason why we have it in the first place. Checks should be done in plat_core_pos_by_mpidr() instead.",
      "revId": "5d85bdd60e3edeb2ae02f5cb78301cb56de4c4df",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4c42f682_df1fae55",
        "filename": "plat/arm/board/arm_fpga/aarch64/fpga_helpers.S",
        "patchSetId": 26
      },
      "lineNbr": 141,
      "author": {
        "id": 1000298
      },
      "writtenOn": "2020-07-22T11:31:38Z",
      "side": 1,
      "message": "Yes, you are right. Remains from a previous patchset. Thanks for spotting it.",
      "parentUuid": "b7d7495d_4e43cf1a",
      "revId": "5d85bdd60e3edeb2ae02f5cb78301cb56de4c4df",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "70ba0fe4_cb47e62f",
        "filename": "plat/arm/board/arm_fpga/fpga_bl31_setup.c",
        "patchSetId": 26
      },
      "lineNbr": 74,
      "author": {
        "id": 1000118
      },
      "writtenOn": "2020-07-21T18:58:46Z",
      "side": 1,
      "message": "That looks still weird, and does not appease me that there is no race condition, if a secondary takes a bit longer to wake up from the wfe. I mean below you explicitly wait quite a while for the other cores.",
      "revId": "5d85bdd60e3edeb2ae02f5cb78301cb56de4c4df",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "86e4aa7a_9d34a2ba",
        "filename": "plat/arm/board/arm_fpga/fpga_bl31_setup.c",
        "patchSetId": 26
      },
      "lineNbr": 74,
      "author": {
        "id": 1000298
      },
      "writtenOn": "2020-07-22T11:31:38Z",
      "side": 1,
      "message": "I can put this below, after the delay to wait for the other cores (in fact it was one of my first ideas) or in other intermediate point if you think there is a chance that some cores might not have time to wake up before the primary one reaches here. I just put this code here to minimize the chances of the second race condition mentioned above to occur.",
      "parentUuid": "70ba0fe4_cb47e62f",
      "revId": "5d85bdd60e3edeb2ae02f5cb78301cb56de4c4df",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1faa8a51_ee065c1e",
        "filename": "plat/arm/board/arm_fpga/fpga_topology.c",
        "patchSetId": 26
      },
      "lineNbr": 17,
      "author": {
        "id": 1000118
      },
      "writtenOn": "2020-07-21T18:58:46Z",
      "side": 1,
      "message": "So does that mean you now express cores and threads in different levels?\nFirst, this should be a separate patch, then. But actually: why? I don\u0027t think we do any kind of actual power gating or the like, and certainly not down to a per-thread level?",
      "revId": "5d85bdd60e3edeb2ae02f5cb78301cb56de4c4df",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5fdadfbf_7edb28ba",
        "filename": "plat/arm/board/arm_fpga/fpga_topology.c",
        "patchSetId": 26
      },
      "lineNbr": 17,
      "author": {
        "id": 1000298
      },
      "writtenOn": "2020-07-22T11:31:38Z",
      "side": 1,
      "message": "I used three affinity levels: Cluster - Core - Thread. I based that decision on the original implementation of plat_fpga_calc_core_pos() in which the MPIDR is always treated as a multi-threaded implementation by shifting it to the left if the MT bit is not set.\n\nMy assumption is that if the MT bit is set, we have to use three affinity levels, haven\u0027t we? In that case, as it is unknown whether an FPGA image is going to be multi-thread or not, I assume three levels (every CPU has at least one thread).\n\nIf this is not how it should be treated (or the most efficient way, anyway), are you suggesting to express the cores and threads at the same level (MAX_CPU_PER_CLUSTER * MAX_PE_PER_CPU on each cluster)? or just ignore the threads level (AFFLVL0) to crate the tree?",
      "parentUuid": "1faa8a51_ee065c1e",
      "revId": "5d85bdd60e3edeb2ae02f5cb78301cb56de4c4df",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c86a5404_b9b52d9a",
        "filename": "plat/arm/board/arm_fpga/fpga_topology.c",
        "patchSetId": 26
      },
      "lineNbr": 17,
      "author": {
        "id": 1000118
      },
      "writtenOn": "2020-07-22T12:20:40Z",
      "side": 1,
      "message": "So basically at the moment we are collapsing threads and cores into one level, for the sake of the topology tree (FPGA_MAX_CPUS_PER_CLUSTER * FPGA_MAX_PE_PER_CPU). It is my understanding that the pd tree is used to determine whether we can turn a cluster off or not: for that all cores in that cluster need to be turned off already - so the last core of a cluster going offline can trigger more power saving by also involving cluster level power gating (or whatever the platform offers).\nThe tree is there to abstract this, so to speak of affinity levels instead of cores or clusters, but using the same idea.\n\nThat\u0027s why I said:\na) we don\u0027t really do power management anyway for the FPGA\nb) I don\u0027t see how turning off threads would work in general, as the idea of threading is to share resources. There are always some exclusively used resources (register file, etc.), but since we don\u0027t even control power on the core level, I don\u0027t see how this would matter here.\n\nSo for the sake of simplicity I would keep it like we do now: collapsing cores and threads into one pd tree level. We can always change this, if needed, but that should be a separate patch, as it is independent.",
      "parentUuid": "5fdadfbf_7edb28ba",
      "revId": "5d85bdd60e3edeb2ae02f5cb78301cb56de4c4df",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7abe6fb8_fd516de5",
        "filename": "plat/arm/board/arm_fpga/fpga_topology.c",
        "patchSetId": 26
      },
      "lineNbr": 39,
      "author": {
        "id": 1000118
      },
      "writtenOn": "2020-07-21T18:58:46Z",
      "side": 1,
      "message": "Why do we need this whole change here? Now the secondaries don\u0027t write into the pd tree anymore, so why can\u0027t we keep the current approach?\nFor the fpga_valid_mpids[0] entry: Shouldn\u0027t we just set this to 1 before notifying the secondary CPUs? In bl31_early_platform_setup2()?",
      "revId": "5d85bdd60e3edeb2ae02f5cb78301cb56de4c4df",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7565acd8_606b7b82",
        "filename": "plat/arm/board/arm_fpga/fpga_topology.c",
        "patchSetId": 26
      },
      "lineNbr": 39,
      "author": {
        "id": 1000298
      },
      "writtenOn": "2020-07-22T11:31:38Z",
      "side": 1,
      "message": "The topology tree needs to be created the first time it needs to be accessed. In this case I create it based on the harcoded maximum affinity levels. As I use three levels of affinity, I need to iterate twice, once for the cores on each cluster and another one for the threads.\n\nWith regards to fpga_valid_mpids[0], I wanted to keep it in this module to reduce coupling.",
      "parentUuid": "7abe6fb8_fd516de5",
      "revId": "5d85bdd60e3edeb2ae02f5cb78301cb56de4c4df",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7c557621_c4654f65",
        "filename": "plat/arm/board/arm_fpga/fpga_topology.c",
        "patchSetId": 26
      },
      "lineNbr": 39,
      "author": {
        "id": 1000118
      },
      "writtenOn": "2020-07-22T12:20:40Z",
      "side": 1,
      "message": "I get the change for including the new level, but not why we need to check now? The pd tree is still static, based on compile time constants, so why do we need the \"if\" here?",
      "parentUuid": "7565acd8_606b7b82",
      "revId": "5d85bdd60e3edeb2ae02f5cb78301cb56de4c4df",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a9938ae9_ba3a3401",
        "filename": "plat/arm/board/arm_fpga/fpga_topology.c",
        "patchSetId": 26
      },
      "lineNbr": 80,
      "author": {
        "id": 1000118
      },
      "writtenOn": "2020-07-21T18:58:46Z",
      "side": 1,
      "message": "Is that really true? We don\u0027t need the pd tree for the array, right? And it\u0027s defined by compile time constants anyway?",
      "revId": "5d85bdd60e3edeb2ae02f5cb78301cb56de4c4df",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2161c6d5_228b2aab",
        "filename": "plat/arm/board/arm_fpga/fpga_topology.c",
        "patchSetId": 26
      },
      "lineNbr": 80,
      "author": {
        "id": 1000298
      },
      "writtenOn": "2020-07-22T11:31:38Z",
      "side": 1,
      "message": "You are right, we do not need the pdt here, however fpga_valid_mpids for the primary core is initialised when the pdt is created and this is needed here. There were other options such as initialise fpga_valid_mpids here or always assume index 0 for the primary processor but I thought it would be more consistent to keep the initialisation in one single place and just check here. Anyway, once the tree is created, this shouldn\u0027t add much overhead.",
      "parentUuid": "a9938ae9_ba3a3401",
      "revId": "5d85bdd60e3edeb2ae02f5cb78301cb56de4c4df",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "06b36faf_12b800de",
        "filename": "plat/arm/board/arm_fpga/fpga_topology.c",
        "patchSetId": 26
      },
      "lineNbr": 80,
      "author": {
        "id": 1000118
      },
      "writtenOn": "2020-07-22T12:20:40Z",
      "side": 1,
      "message": "That\u0027s why I wanted to initialise fpga_valid_mpids[0] earlier, basically at the same time as the secondaries populate their entries. It feels more consistent to set [0] just before we wake up the secondaries for the first time, so that that code there deals with fpga_valid_mpids[], and this code here just consumes it and deals with the pd tree.",
      "parentUuid": "2161c6d5_228b2aab",
      "revId": "5d85bdd60e3edeb2ae02f5cb78301cb56de4c4df",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    }
  ]
}