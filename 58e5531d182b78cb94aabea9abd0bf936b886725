{
  "comments": [
    {
      "key": {
        "uuid": "3ec3d449_538f13f4",
        "filename": "Makefile",
        "patchSetId": 1
      },
      "lineNbr": 506,
      "author": {
        "id": 1000043
      },
      "writtenOn": "2019-05-03T09:10:45Z",
      "side": 1,
      "message": "Could we simplify this logic a bit by making ENABLE_PAUTH and ENABLE_BTI snippets independent? As in:\n\n ifeq ($(ENABLE_PAUTH),1)\n   # Check stuff specific to PAuth.\n   # Print messages specific to PAuth.\n endif\n\n ifeq ($(ENABLE_BTI),1)\n   # Check stuff specific to BTI.\n   # Print messages specific to BTI.\n endif\n\nI suspect you wanted to avoid printing 2 \"experimental feature\" message when both PAuth and BTI are enabled, but I don\u0027t think that\u0027s an issue.",
      "range": {
        "startLine": 481,
        "startChar": 0,
        "endLine": 506,
        "endChar": 5
      },
      "revId": "58e5531d182b78cb94aabea9abd0bf936b886725",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2b95d75f_f9ae019d",
        "filename": "Makefile",
        "patchSetId": 1
      },
      "lineNbr": 506,
      "author": {
        "id": 1000105
      },
      "writtenOn": "2019-05-03T11:53:01Z",
      "side": 1,
      "message": "Both PAUTH and BTI features are passed as one build option, so a single warning should be printed. The logic is correct and covers all possible user cases.",
      "parentUuid": "3ec3d449_538f13f4",
      "range": {
        "startLine": 481,
        "startChar": 0,
        "endLine": 506,
        "endChar": 5
      },
      "revId": "58e5531d182b78cb94aabea9abd0bf936b886725",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a7906ac8_3d1db3b1",
        "filename": "bl1/bl1.mk",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000043
      },
      "writtenOn": "2019-05-03T09:10:45Z",
      "side": 1,
      "message": "Do these changes mean we are dropping support for GCC compilers that only provided PAuth support?",
      "revId": "58e5531d182b78cb94aabea9abd0bf936b886725",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6f5c4764_b242f47f",
        "filename": "bl1/bl1.mk",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000105
      },
      "writtenOn": "2019-05-03T11:53:01Z",
      "side": 1,
      "message": "Yes. In GCC 9 sign-return-address option has been deprecated by -mbranch-protection. Compilation with sign-return-address emits warnings and no PAUTH support code is generated.",
      "parentUuid": "a7906ac8_3d1db3b1",
      "revId": "58e5531d182b78cb94aabea9abd0bf936b886725",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ea021be5_546babb5",
        "filename": "bl1/bl1.mk",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000043
      },
      "writtenOn": "2019-05-06T08:46:24Z",
      "side": 1,
      "message": "Ok.",
      "parentUuid": "6f5c4764_b242f47f",
      "revId": "58e5531d182b78cb94aabea9abd0bf936b886725",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "caf6f13e_462d63b6",
        "filename": "bl2/aarch64/bl2_el3_entrypoint.S",
        "patchSetId": 1
      },
      "lineNbr": 60,
      "author": {
        "id": 1000043
      },
      "writtenOn": "2019-05-03T09:10:45Z",
      "side": 1,
      "message": "Given that we have to *clear* this bit to enable PAC branch type compatibility, I suppose we should set it by default in other configurations (as this bit resets to an architecturally unknown value).\n\nWhere is this done?",
      "range": {
        "startLine": 54,
        "startChar": 0,
        "endLine": 60,
        "endChar": 23
      },
      "revId": "58e5531d182b78cb94aabea9abd0bf936b886725",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fadbc080_e1bee8c4",
        "filename": "bl2/aarch64/bl2_el3_entrypoint.S",
        "patchSetId": 1
      },
      "lineNbr": 60,
      "author": {
        "id": 1000105
      },
      "writtenOn": "2019-05-03T11:53:01Z",
      "side": 1,
      "message": "Setting these bits is only required when PAUTH gets enabled and the bits don\u0027t have any effect otherwise. All PAUTH bits EnIA, EnIB, EnDA, EnDB also reset \"to an architecturally UNKNOWN value\", but only EnIA gets enabled by setting to 1 if ENABLE_PAUTH \u003d 1 and not cleared otherwise.\n\"I suppose we should set it by default in other configurations...\"\nSCTLR_EL3 is set in el3_entrypoint_common macro (include\\arch\\arch64\\el3_common_macros.S):\n mov_imm x0, (SCTLR_RESET_VAL \u0026 ~(SCTLR_EE_BIT | SCTLR_WXN_BIT \\\n\t    | SCTLR_SA_BIT | SCTLR_A_BIT | SCTLR_DSSBS_BIT))\n msr\tsctlr_el3, x0\n isb\n\n, where SCTLR_RESET_VAL is definition for RES1 bits, so all other bits are set to 0.",
      "parentUuid": "caf6f13e_462d63b6",
      "range": {
        "startLine": 54,
        "startChar": 0,
        "endLine": 60,
        "endChar": 23
      },
      "revId": "58e5531d182b78cb94aabea9abd0bf936b886725",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4ce05fa0_08651d6a",
        "filename": "bl2/aarch64/bl2_el3_entrypoint.S",
        "patchSetId": 1
      },
      "lineNbr": 60,
      "author": {
        "id": 1000043
      },
      "writtenOn": "2019-05-06T08:46:24Z",
      "side": 1,
      "message": "Ok, thanks for the clarification.",
      "parentUuid": "fadbc080_e1bee8c4",
      "range": {
        "startLine": 54,
        "startChar": 0,
        "endLine": 60,
        "endChar": 23
      },
      "revId": "58e5531d182b78cb94aabea9abd0bf936b886725",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "84e83884_0ea78a03",
        "filename": "docs/firmware-design.rst",
        "patchSetId": 1
      },
      "lineNbr": 2586,
      "author": {
        "id": 1000043
      },
      "writtenOn": "2019-05-03T09:10:45Z",
      "side": 1,
      "message": "(minor) Need an extra space here I think (for proper rst rendering).",
      "range": {
        "startLine": 2586,
        "startChar": 0,
        "endLine": 2586,
        "endChar": 2
      },
      "revId": "58e5531d182b78cb94aabea9abd0bf936b886725",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6b17ad35_5efb78e7",
        "filename": "docs/firmware-design.rst",
        "patchSetId": 1
      },
      "lineNbr": 2586,
      "author": {
        "id": 1000105
      },
      "writtenOn": "2019-05-07T13:16:06Z",
      "side": 1,
      "message": "Thanks, will fix that.",
      "parentUuid": "84e83884_0ea78a03",
      "range": {
        "startLine": 2586,
        "startChar": 0,
        "endLine": 2586,
        "endChar": 2
      },
      "revId": "58e5531d182b78cb94aabea9abd0bf936b886725",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "053c1a5b_384d9df0",
        "filename": "docs/user-guide.rst",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000043
      },
      "writtenOn": "2019-05-03T09:10:45Z",
      "side": 1,
      "message": "The changes introduced in this file do not seem to render properly, it looks like the whole paragraph ends up on the same line. (You can easily see that by copying \u0026 pasting this text in some online rst renderer, e.g. http://rst.ninjs.org/)",
      "revId": "58e5531d182b78cb94aabea9abd0bf936b886725",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6be53dc0_93184865",
        "filename": "docs/user-guide.rst",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000105
      },
      "writtenOn": "2019-05-07T13:16:06Z",
      "side": 1,
      "message": "Thanks, will fix that.",
      "parentUuid": "053c1a5b_384d9df0",
      "revId": "58e5531d182b78cb94aabea9abd0bf936b886725",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b537671d_ebb2e6c2",
        "filename": "docs/user-guide.rst",
        "patchSetId": 1
      },
      "lineNbr": 331,
      "author": {
        "id": 1000043
      },
      "writtenOn": "2019-05-03T09:10:45Z",
      "side": 1,
      "message": "Could we directly use the GCC options values (none, standard, pac-ret, pac-ret+leaf, bti) rather than using arbitrary numeric values? This would be clearer/easier to use.",
      "range": {
        "startLine": 327,
        "startChar": 0,
        "endLine": 331,
        "endChar": 48
      },
      "revId": "58e5531d182b78cb94aabea9abd0bf936b886725",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f9ff78c3_945b04b1",
        "filename": "docs/user-guide.rst",
        "patchSetId": 1
      },
      "lineNbr": 331,
      "author": {
        "id": 1000105
      },
      "writtenOn": "2019-05-03T11:53:01Z",
      "side": 1,
      "message": "Makefile should be abstracted from GCC and not dependent on compilation options, which could be changed in other versions, as what happened with \"sign-return-address\" deprecated by \"branch-protection\".",
      "parentUuid": "b537671d_ebb2e6c2",
      "range": {
        "startLine": 327,
        "startChar": 0,
        "endLine": 331,
        "endChar": 48
      },
      "revId": "58e5531d182b78cb94aabea9abd0bf936b886725",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "afe9e585_949d70da",
        "filename": "docs/user-guide.rst",
        "patchSetId": 1
      },
      "lineNbr": 331,
      "author": {
        "id": 1000043
      },
      "writtenOn": "2019-05-06T08:46:24Z",
      "side": 1,
      "message": "Good point!",
      "parentUuid": "f9ff78c3_945b04b1",
      "range": {
        "startLine": 327,
        "startChar": 0,
        "endLine": 331,
        "endChar": 48
      },
      "revId": "58e5531d182b78cb94aabea9abd0bf936b886725",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6dee442d_8faef8c7",
        "filename": "drivers/arm/pl011/aarch64/pl011_console.S",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000043
      },
      "writtenOn": "2019-05-03T09:10:45Z",
      "side": 1,
      "message": "How did you identify all assembly functions that needed a BTI instruction? And how did you figure out which type of BTI (c, j, cj) was needed? Did you just enable BTI support in the hardware and fixed all places that generated a branch target exception, until it did not crash anymore?",
      "revId": "58e5531d182b78cb94aabea9abd0bf936b886725",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c0a8ac4d_ab9eb0fd",
        "filename": "drivers/arm/pl011/aarch64/pl011_console.S",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000105
      },
      "writtenOn": "2019-05-03T11:53:01Z",
      "side": 1,
      "message": "Code analysis and debugging.",
      "parentUuid": "6dee442d_8faef8c7",
      "revId": "58e5531d182b78cb94aabea9abd0bf936b886725",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c8771cb0_2916cb62",
        "filename": "drivers/arm/pl011/aarch64/pl011_console.S",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000043
      },
      "writtenOn": "2019-05-06T08:46:24Z",
      "side": 1,
      "message": "Ok. I suppose that the debugging approach relies on running the code, i.e. you build TF-A in a specific configuration, run it on the target and fix any issue you can see. We might still miss some BTI instructions in code that is not built into the firmware (because conditionally excluded from the image by some build flag) or code that has not been executed (because this code path was not exercised in the debugging session). I guess it\u0027s hard to catch all of these through code analysis.\n\nI wonder whether we could use some tooling here. For example, we might be able to get the call graph from the compiler and if it tells us the type of branch for each call site, that would give us a list of all BTI targets. Then we could filter this list of BTI targets to keep only the functions implemented in assembly language, and check whether we\u0027ve patched all such code.\n\nThis still does not solve the build flags issues (we would still have to run this tool on many different build configurations) but it at least removes the need to run the code (since it\u0027s based on static code analysis rather than dynamic execution).\n\nWhat do you think? Do you reckon that would work?",
      "parentUuid": "c0a8ac4d_ab9eb0fd",
      "revId": "58e5531d182b78cb94aabea9abd0bf936b886725",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "34b4bbc1_11bff6fc",
        "filename": "drivers/arm/pl011/aarch64/pl011_console.S",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000105
      },
      "writtenOn": "2019-05-07T10:15:06Z",
      "side": 1,
      "message": "1. BTI feature is listed as experimental and is still under development/testing, e.g. USE_ROMLIB\u003d1 is currently not supported, because \"bti j\" instructions need to be injected in the jump table. I have a workaround for that, but John will implement a proper implementation.\n2. I\u0027m not aware of such tool existence, which indeed should be run for all configurations, build options, in case of any new assembler file added/modified, compiler version changed, etc. Also only assembler functions called after MMU is enabled should be analysed.\n3. Ideally this sort of analysis (except MMU) could be imlemented in GCC compiler/linker itself which could generate a warning for functions called from BTI-enabled code and missing \"bti\" instuctions.\n4. Are you suggesting that BTI support fro TF-A should be postponed until such tool is available?",
      "parentUuid": "c8771cb0_2916cb62",
      "revId": "58e5531d182b78cb94aabea9abd0bf936b886725",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4fe3a193_fd1ec8ca",
        "filename": "drivers/arm/pl011/aarch64/pl011_console.S",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000043
      },
      "writtenOn": "2019-05-07T13:06:50Z",
      "side": 1,
      "message": "\u003e 1. BTI feature is listed as experimental and is still under development/testing, e.g. USE_ROMLIB\u003d1 is currently not supported, because \"bti j\" instructions need to be injected in the jump table. I have a workaround for that, but John will implement a proper implementation.\n\nI see, thanks for the additional information. I think it would be worth mentioning that in the commit message. If you are aware of any other limitations or functionality excluded from the scope of this patch, these would be useful as well IMO.\n\n\u003e 2. I\u0027m not aware of such tool existence, which indeed should be run for all configurations, build options, in case of any new assembler file added/modified, compiler version changed, etc. Also only assembler functions called after MMU is enabled should be analysed.\n\u003e 3. Ideally this sort of analysis (except MMU) could be imlemented in GCC compiler/linker itself which could generate a warning for functions called from BTI-enabled code and missing \"bti\" instuctions.\n\nYes that would be neat, indeed.\n\n\u003e 4. Are you suggesting that BTI support fro TF-A should be postponed until such tool is available?\n\nNo, I am not suggesting that at all, sorry if I led you to think that. This patch per se is already a great stepping stone towards full BTI support in the TF-A and I think we should carry on with it. I guess there will be some BTI instructions missing in some places but we can go and fix them later. That should be easily identifiable, as we\u0027ll get a branch target exception.\n\nI guess I was just thinking out loud about how we could increase our confidence in identifying all BTI spots. But on further thoughts, I think that it would be too much work for us to develop such a tool for the value we\u0027d get out of it. I suppose I was also curious to know whether you\u0027d heard about any such tool.",
      "parentUuid": "34b4bbc1_11bff6fc",
      "revId": "58e5531d182b78cb94aabea9abd0bf936b886725",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9885ff8c_7c586730",
        "filename": "drivers/arm/pl011/aarch64/pl011_console.S",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000105
      },
      "writtenOn": "2019-05-07T13:16:06Z",
      "side": 1,
      "message": "If some BTI instructions are really missing in some assembler files/places and exception is generated, then modification of func macro you suggested to make it always add \"bti jc\" instruction on function entry will help identify this kind of problem.",
      "parentUuid": "4fe3a193_fd1ec8ca",
      "revId": "58e5531d182b78cb94aabea9abd0bf936b886725",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "51f450df_e8790675",
        "filename": "drivers/arm/pl011/aarch64/pl011_console.S",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000043
      },
      "writtenOn": "2019-05-07T15:19:36Z",
      "side": 1,
      "message": "Sorry, I did not get your point, how will the changes to the func macro help in identifying missing BTI instructions? Could you please elaborate on that?\n\n \u003e func macro you suggested to make it always add \"bti jc\" instruction on function entry\n\nActually, what I had in mind was to specify the kind of BTI instruction to the func macro, i.e. 3 possible options for declaring a function foo() that is genuinely reachable through an indirect branch:\n* func foo, bti\u003dc\n* func foo, bti\u003dj\n* func foo, bti\u003djc\n\nI think this would be a better approach than unconditionally using a \u0027bti cj\u0027. It\u0027s the principle of least privilege: if we don\u0027t need the function to be reachable through call-type instructions then let\u0027s not allow it.",
      "parentUuid": "9885ff8c_7c586730",
      "revId": "58e5531d182b78cb94aabea9abd0bf936b886725",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0ab26091_1be228b7",
        "filename": "drivers/arm/pl011/aarch64/pl011_console.S",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000105
      },
      "writtenOn": "2019-05-08T10:21:15Z",
      "side": 1,
      "message": "What I meant is that if exception is generated, we can work out whether it was caused by a missing \"bti\" instruction in assembler function by modifying \"func\" macro to always insert \"bti jc\". If after that code executes normaly, we know that \"bti\" is missing in assembler functions and can analyse and debug the code.",
      "parentUuid": "51f450df_e8790675",
      "revId": "58e5531d182b78cb94aabea9abd0bf936b886725",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fdc5521b_66c47ab7",
        "filename": "drivers/arm/pl011/aarch64/pl011_console.S",
        "patchSetId": 1
      },
      "lineNbr": 177,
      "author": {
        "id": 1000043
      },
      "writtenOn": "2019-05-03T09:10:45Z",
      "side": 1,
      "message": "We should try to limit the use of conditional code like that if we can, as it hurts readability.\n\nI think we might be able to handle that in the func macro. How about adding an optional macro argument that specifies whether this function is a valid BTI target? Then line 174 would become something like:\n\n func console_pl011_putc, bti\u003dc",
      "range": {
        "startLine": 175,
        "startChar": 0,
        "endLine": 177,
        "endChar": 6
      },
      "revId": "58e5531d182b78cb94aabea9abd0bf936b886725",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "22b33db0_e29c0fad",
        "filename": "drivers/arm/pl011/aarch64/pl011_console.S",
        "patchSetId": 1
      },
      "lineNbr": 177,
      "author": {
        "id": 1000105
      },
      "writtenOn": "2019-05-03T11:53:01Z",
      "side": 1,
      "message": "Changing func macro will effect all other assembler fuunctions as well which shouldn\u0027t be modified and use bti parameter as not being not effected by BTI. \nfunc macro bti parameter should be optional and will use conditional code anyway.",
      "parentUuid": "fdc5521b_66c47ab7",
      "range": {
        "startLine": 175,
        "startChar": 0,
        "endLine": 177,
        "endChar": 6
      },
      "revId": "58e5531d182b78cb94aabea9abd0bf936b886725",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "493b2397_b939b5ac",
        "filename": "drivers/arm/pl011/aarch64/pl011_console.S",
        "patchSetId": 1
      },
      "lineNbr": 177,
      "author": {
        "id": 1000043
      },
      "writtenOn": "2019-05-06T08:46:24Z",
      "side": 1,
      "message": "Yes, any change to the func macro will affect all assembler functions, which is why I was proposing to add an *optional* macro parameter. I think something like the following could work:\n\n .macro func _name, _align\u003d2, _bti_target\n /* snip */\n \\_name:\n #if ENABLE_BTI\n .ifnb _bti_target\n   bti \\_bti_target\n .endif\n #endif\n .endm\n\nWhen ENABLE_BTI is 0, nothing will change, except that the func macro now has an extra optional argument that is not used in the macro body.\n\nWhen ENABLE_BTI is 1, depending on whether the user of the func macro specifies a BTI target argument, the bti instruction will or will not be assembled.\n\nThe benefit I see in this approach is that the #if ENABLE_BIT preprocessor logic is hidden and contained in a single place. This makes the code easier to read IMO.",
      "parentUuid": "22b33db0_e29c0fad",
      "range": {
        "startLine": 175,
        "startChar": 0,
        "endLine": 177,
        "endChar": 6
      },
      "revId": "58e5531d182b78cb94aabea9abd0bf936b886725",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bef980ab_862e2362",
        "filename": "drivers/arm/pl011/aarch64/pl011_console.S",
        "patchSetId": 1
      },
      "lineNbr": 177,
      "author": {
        "id": 1000105
      },
      "writtenOn": "2019-05-07T10:15:06Z",
      "side": 1,
      "message": "Thanks. I\u0027ll take a look at this option.",
      "parentUuid": "493b2397_b939b5ac",
      "range": {
        "startLine": 175,
        "startChar": 0,
        "endLine": 177,
        "endChar": 6
      },
      "revId": "58e5531d182b78cb94aabea9abd0bf936b886725",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "180da222_539d013b",
        "filename": "lib/cpus/aarch64/aem_generic.S",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000043
      },
      "writtenOn": "2019-05-06T08:46:24Z",
      "side": 1,
      "message": "I would expect that similar changes are needed for all other CPUs as well, since these power management hooks are invoked through a table of function pointers in the cpu_ops structure. Is that not the case? Or is BTI support only introduced for the Base AEM FVP at this stage, and support for other platforms will be added in a future patch?",
      "revId": "58e5531d182b78cb94aabea9abd0bf936b886725",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "62fdadf2_66494074",
        "filename": "lib/cpus/aarch64/aem_generic.S",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000105
      },
      "writtenOn": "2019-05-07T10:15:06Z",
      "side": 1,
      "message": "BTI is v8.5 feature which is currently supported for FVP_Base_AEMv8A_... \u0026 FVP_Base_RevC-2xAEMv8A models only, support for other v8.5 platforms will be added when they are available,",
      "parentUuid": "180da222_539d013b",
      "revId": "58e5531d182b78cb94aabea9abd0bf936b886725",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "dd21aee3_3119d565",
        "filename": "lib/cpus/aarch64/aem_generic.S",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000043
      },
      "writtenOn": "2019-05-07T13:06:50Z",
      "side": 1,
      "message": "Yes, of course, that makes sense!",
      "parentUuid": "62fdadf2_66494074",
      "revId": "58e5531d182b78cb94aabea9abd0bf936b886725",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "687280b2_18aa8e42",
        "filename": "lib/libc/libc.mk",
        "patchSetId": 1
      },
      "lineNbr": 33,
      "author": {
        "id": 1000043
      },
      "writtenOn": "2019-05-03T09:10:45Z",
      "side": 1,
      "message": "Should this not be:\n\n ifneq (${BP_OPTION},none)\n\nlike in the other makefiles? Why is it different in this one?",
      "range": {
        "startLine": 33,
        "startChar": 0,
        "endLine": 33,
        "endChar": 22
      },
      "revId": "58e5531d182b78cb94aabea9abd0bf936b886725",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1a4710de_cdd86cab",
        "filename": "lib/libc/libc.mk",
        "patchSetId": 1
      },
      "lineNbr": 33,
      "author": {
        "id": 1000105
      },
      "writtenOn": "2019-05-03T11:53:01Z",
      "side": 1,
      "message": "Yes, thanks for pointing to this. Will fix in the next patch set.",
      "parentUuid": "687280b2_18aa8e42",
      "range": {
        "startLine": 33,
        "startChar": 0,
        "endLine": 33,
        "endChar": 22
      },
      "revId": "58e5531d182b78cb94aabea9abd0bf936b886725",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "eff247e3_087843b5",
        "filename": "lib/libc/libc.mk",
        "patchSetId": 1
      },
      "lineNbr": 33,
      "author": {
        "id": 1000105
      },
      "writtenOn": "2019-05-03T13:23:30Z",
      "side": 1,
      "message": "Original libc.mk doesn\u0027t have \"sign-return-address\" compilation option, so only BTI support was added. Should PAuth compilation support added as well?",
      "parentUuid": "1a4710de_cdd86cab",
      "range": {
        "startLine": 33,
        "startChar": 0,
        "endLine": 33,
        "endChar": 22
      },
      "revId": "58e5531d182b78cb94aabea9abd0bf936b886725",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "64689bcc_705cd630",
        "filename": "lib/libc/libc.mk",
        "patchSetId": 1
      },
      "lineNbr": 33,
      "author": {
        "id": 1000043
      },
      "writtenOn": "2019-05-06T08:46:24Z",
      "side": 1,
      "message": "\u003e Should PAuth compilation support added as well?\n\nBut you said here [1] that we were deprecating -msign-return-address in favour of -mbranch-protection, so why would we add support for PAuth only in this makefile and not the other ones? Did I misunderstand what you meant here?\n\n[1] https://review.trustedfirmware.org/c/TF-A/trusted-firmware-a/+/929/1/bl1/bl1.mk",
      "parentUuid": "eff247e3_087843b5",
      "range": {
        "startLine": 33,
        "startChar": 0,
        "endLine": 33,
        "endChar": 22
      },
      "revId": "58e5531d182b78cb94aabea9abd0bf936b886725",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "db846cc3_5128afb5",
        "filename": "lib/libc/libc.mk",
        "patchSetId": 1
      },
      "lineNbr": 33,
      "author": {
        "id": 1000105
      },
      "writtenOn": "2019-05-07T13:16:06Z",
      "side": 1,
      "message": "1. libc.mk didn\u0027t support PAuth and didn\u0027t have \"sign-return-address\" option.\n2. Now, when ENABLE_BTI \u003d 1 libc.mk must be compiled with \"mbranch-protection\u003dbti\" if only BTI is needed, or if we want to add full support for all PAuth+BTI combinations with:\n-mbranch-protection\u003d${BP_OPTION} when ifneq (${BP_OPTION},none)\nPlease share your opinion on that.",
      "parentUuid": "64689bcc_705cd630",
      "range": {
        "startLine": 33,
        "startChar": 0,
        "endLine": 33,
        "endChar": 22
      },
      "revId": "58e5531d182b78cb94aabea9abd0bf936b886725",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "daf295ed_dc7c105f",
        "filename": "lib/libc/libc.mk",
        "patchSetId": 1
      },
      "lineNbr": 33,
      "author": {
        "id": 1000043
      },
      "writtenOn": "2019-05-07T15:19:36Z",
      "side": 1,
      "message": "Oh I see! I had not realized that the libc code was compiled without pointer authentication support until now, even when TF-A was compiled with ENABLE_PAUTH\u003d1. Was that a gap in the implementation or was it done on purpose for a good reason?\n\nIf it was just a gap, then my opinion is that we should go for:\n\n ifneq (${BP_OPTION},none)\n   TF_CFLAGS_aarch64\t+\u003d -mbranch-protection\u003d${BP_OPTION}\n endif\n\nIf we go for the other option you\u0027re considering, which I believe, is:\n\n ifeq (${ENABLE_BTI},1)\n   TF_CFLAGS_aarch64\t+\u003d -mbranch-protection\u003dbti\n endif\n\nthen in the case where we\u0027d build TF-A with BRANCH_PROTECTION\u003d2 (pac-ret option) for example, my understanding is that we would compile the libc with no BTI or PAuth support whatsoever, while the rest of the firmware would have PAuth support. I find this use case intuitive. Can you think about why anyone would want to do that? Is there a use case I\u0027ve missed where this could be useful?\n\nAlso, would it make more sense to move this code to the top-level Makefile, rather than keeping it in libc.mk? AFAICS, if we keep it in libc.mk then some code is still compiled without PAuth/BTI support, for example libfdt code. Should we not extend this to all code within the firmware?",
      "parentUuid": "db846cc3_5128afb5",
      "range": {
        "startLine": 33,
        "startChar": 0,
        "endLine": 33,
        "endChar": 22
      },
      "revId": "58e5531d182b78cb94aabea9abd0bf936b886725",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "833d82a5_cbe9c742",
        "filename": "lib/xlat_tables_v2/xlat_tables_core.c",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000043
      },
      "writtenOn": "2019-05-03T09:10:45Z",
      "side": 1,
      "message": "IIUC, only code pages are guarded here, data pages are not.\n\nI did not clearly understand how non-guarded pages are treated. Let\u0027s say I do an indirect branch to a non-guarded page, what happens? Will it be allowed/ignored, or will it generate a branch target exception?",
      "revId": "58e5531d182b78cb94aabea9abd0bf936b886725",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "19a97c4d_2e7536ab",
        "filename": "lib/xlat_tables_v2/xlat_tables_core.c",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000105
      },
      "writtenOn": "2019-05-03T11:53:01Z",
      "side": 1,
      "message": "- Code is not executed in data pages.\n- Allowed, only guarded pages are protected, no exception is generated.",
      "parentUuid": "833d82a5_cbe9c742",
      "revId": "58e5531d182b78cb94aabea9abd0bf936b886725",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0b6143dc_43bb79f6",
        "filename": "lib/xlat_tables_v2/xlat_tables_core.c",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000043
      },
      "writtenOn": "2019-05-06T08:46:24Z",
      "side": 1,
      "message": "Ok thanks.",
      "parentUuid": "19a97c4d_2e7536ab",
      "revId": "58e5531d182b78cb94aabea9abd0bf936b886725",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "60e73b43_294763e6",
        "filename": "lib/xlat_tables_v2/xlat_tables_core.c",
        "patchSetId": 1
      },
      "lineNbr": 206,
      "author": {
        "id": 1000043
      },
      "writtenOn": "2019-05-03T09:10:45Z",
      "side": 1,
      "message": "Are guarded pages an EL3-only feature? If it is not, why not extending to S-EL1 pages for BL2 and TSP?",
      "range": {
        "startLine": 206,
        "startChar": 7,
        "endLine": 206,
        "endChar": 37
      },
      "revId": "58e5531d182b78cb94aabea9abd0bf936b886725",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    }
  ]
}