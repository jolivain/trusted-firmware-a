{
  "comments": [
    {
      "key": {
        "uuid": "3ec3d449_538f13f4",
        "filename": "Makefile",
        "patchSetId": 1
      },
      "lineNbr": 506,
      "author": {
        "id": 1000043
      },
      "writtenOn": "2019-05-03T09:10:45Z",
      "side": 1,
      "message": "Could we simplify this logic a bit by making ENABLE_PAUTH and ENABLE_BTI snippets independent? As in:\n\n ifeq ($(ENABLE_PAUTH),1)\n   # Check stuff specific to PAuth.\n   # Print messages specific to PAuth.\n endif\n\n ifeq ($(ENABLE_BTI),1)\n   # Check stuff specific to BTI.\n   # Print messages specific to BTI.\n endif\n\nI suspect you wanted to avoid printing 2 \"experimental feature\" message when both PAuth and BTI are enabled, but I don\u0027t think that\u0027s an issue.",
      "range": {
        "startLine": 481,
        "startChar": 0,
        "endLine": 506,
        "endChar": 5
      },
      "revId": "58e5531d182b78cb94aabea9abd0bf936b886725",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a7906ac8_3d1db3b1",
        "filename": "bl1/bl1.mk",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000043
      },
      "writtenOn": "2019-05-03T09:10:45Z",
      "side": 1,
      "message": "Do these changes mean we are dropping support for GCC compilers that only provided PAuth support?",
      "revId": "58e5531d182b78cb94aabea9abd0bf936b886725",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "caf6f13e_462d63b6",
        "filename": "bl2/aarch64/bl2_el3_entrypoint.S",
        "patchSetId": 1
      },
      "lineNbr": 60,
      "author": {
        "id": 1000043
      },
      "writtenOn": "2019-05-03T09:10:45Z",
      "side": 1,
      "message": "Given that we have to *clear* this bit to enable PAC branch type compatibility, I suppose we should set it by default in other configurations (as this bit resets to an architecturally unknown value).\n\nWhere is this done?",
      "range": {
        "startLine": 54,
        "startChar": 0,
        "endLine": 60,
        "endChar": 23
      },
      "revId": "58e5531d182b78cb94aabea9abd0bf936b886725",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "84e83884_0ea78a03",
        "filename": "docs/firmware-design.rst",
        "patchSetId": 1
      },
      "lineNbr": 2586,
      "author": {
        "id": 1000043
      },
      "writtenOn": "2019-05-03T09:10:45Z",
      "side": 1,
      "message": "(minor) Need an extra space here I think (for proper rst rendering).",
      "range": {
        "startLine": 2586,
        "startChar": 0,
        "endLine": 2586,
        "endChar": 2
      },
      "revId": "58e5531d182b78cb94aabea9abd0bf936b886725",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "053c1a5b_384d9df0",
        "filename": "docs/user-guide.rst",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000043
      },
      "writtenOn": "2019-05-03T09:10:45Z",
      "side": 1,
      "message": "The changes introduced in this file do not seem to render properly, it looks like the whole paragraph ends up on the same line. (You can easily see that by copying \u0026 pasting this text in some online rst renderer, e.g. http://rst.ninjs.org/)",
      "revId": "58e5531d182b78cb94aabea9abd0bf936b886725",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b537671d_ebb2e6c2",
        "filename": "docs/user-guide.rst",
        "patchSetId": 1
      },
      "lineNbr": 331,
      "author": {
        "id": 1000043
      },
      "writtenOn": "2019-05-03T09:10:45Z",
      "side": 1,
      "message": "Could we directly use the GCC options values (none, standard, pac-ret, pac-ret+leaf, bti) rather than using arbitrary numeric values? This would be clearer/easier to use.",
      "range": {
        "startLine": 327,
        "startChar": 0,
        "endLine": 331,
        "endChar": 48
      },
      "revId": "58e5531d182b78cb94aabea9abd0bf936b886725",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6dee442d_8faef8c7",
        "filename": "drivers/arm/pl011/aarch64/pl011_console.S",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000043
      },
      "writtenOn": "2019-05-03T09:10:45Z",
      "side": 1,
      "message": "How did you identify all assembly functions that needed a BTI instruction? And how did you figure out which type of BTI (c, j, cj) was needed? Did you just enable BTI support in the hardware and fixed all places that generated a branch target exception, until it did not crash anymore?",
      "revId": "58e5531d182b78cb94aabea9abd0bf936b886725",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fdc5521b_66c47ab7",
        "filename": "drivers/arm/pl011/aarch64/pl011_console.S",
        "patchSetId": 1
      },
      "lineNbr": 177,
      "author": {
        "id": 1000043
      },
      "writtenOn": "2019-05-03T09:10:45Z",
      "side": 1,
      "message": "We should try to limit the use of conditional code like that if we can, as it hurts readability.\n\nI think we might be able to handle that in the func macro. How about adding an optional macro argument that specifies whether this function is a valid BTI target? Then line 174 would become something like:\n\n func console_pl011_putc, bti\u003dc",
      "range": {
        "startLine": 175,
        "startChar": 0,
        "endLine": 177,
        "endChar": 6
      },
      "revId": "58e5531d182b78cb94aabea9abd0bf936b886725",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "687280b2_18aa8e42",
        "filename": "lib/libc/libc.mk",
        "patchSetId": 1
      },
      "lineNbr": 33,
      "author": {
        "id": 1000043
      },
      "writtenOn": "2019-05-03T09:10:45Z",
      "side": 1,
      "message": "Should this not be:\n\n ifneq (${BP_OPTION},none)\n\nlike in the other makefiles? Why is it different in this one?",
      "range": {
        "startLine": 33,
        "startChar": 0,
        "endLine": 33,
        "endChar": 22
      },
      "revId": "58e5531d182b78cb94aabea9abd0bf936b886725",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "833d82a5_cbe9c742",
        "filename": "lib/xlat_tables_v2/xlat_tables_core.c",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000043
      },
      "writtenOn": "2019-05-03T09:10:45Z",
      "side": 1,
      "message": "IIUC, only code pages are guarded here, data pages are not.\n\nI did not clearly understand how non-guarded pages are treated. Let\u0027s say I do an indirect branch to a non-guarded page, what happens? Will it be allowed/ignored, or will it generate a branch target exception?",
      "revId": "58e5531d182b78cb94aabea9abd0bf936b886725",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "60e73b43_294763e6",
        "filename": "lib/xlat_tables_v2/xlat_tables_core.c",
        "patchSetId": 1
      },
      "lineNbr": 206,
      "author": {
        "id": 1000043
      },
      "writtenOn": "2019-05-03T09:10:45Z",
      "side": 1,
      "message": "Are guarded pages an EL3-only feature? If it is not, why not extending to S-EL1 pages for BL2 and TSP?",
      "range": {
        "startLine": 206,
        "startChar": 7,
        "endLine": 206,
        "endChar": 37
      },
      "revId": "58e5531d182b78cb94aabea9abd0bf936b886725",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    }
  ]
}