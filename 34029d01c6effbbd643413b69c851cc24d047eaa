{
  "comments": [
    {
      "key": {
        "uuid": "4ad35a18_790510a7",
        "filename": "lib/el3_runtime/aarch64/context.S",
        "patchSetId": 1
      },
      "lineNbr": 484,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2020-09-14T17:21:28Z",
      "side": 0,
      "message": "I would rather see another build option introduced instead of deleting code. There are use cases where the secure physical timer is used by EL3 and the NS timer registers that are context switched are used by secure partitions on platforms that don\u0027t use OPTEE for example(and instead use FF-A based SPMC/SPMD etc).\n\n\nAlso some things to keep in mind: Not all platforms run OPTEE, not all platforms run linux. Not all platforms allow secure physical timer access to S-EL1/S-EL0. The use of timers should be a platform decision.",
      "revId": "34029d01c6effbbd643413b69c851cc24d047eaa",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "356b4a80_30668920",
        "filename": "lib/el3_runtime/aarch64/context.S",
        "patchSetId": 1
      },
      "lineNbr": 484,
      "author": {
        "id": 1000132
      },
      "writtenOn": "2020-09-15T07:09:40Z",
      "side": 0,
      "message": "I agree with you that there could be varying software stacks that could run in secure and non-secure worlds. But I am curious to know how a particular timer can be shared among secure and non-secure entity at runtime.\n\nAFAIK, a timer operates using a Private Peripheral Interrupt (PPI) and if we need to share a particular timer then this interrupt needs to be dynamically assigned during context switch as well and I can\u0027t find corresponding implementation in TF-A.\n\nAnd suppose if non-secure entity has setup a timer to fire every 10 ms and need to do context switch to secure entity. So would that timer fire reliably every 10 ms?\n\nIMO, EL3 should be able to reliably share secure physical timer with secure EL1 in case secure timer interrupt is routed via EL3.",
      "parentUuid": "4ad35a18_790510a7",
      "revId": "34029d01c6effbbd643413b69c851cc24d047eaa",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b0beb42a_53fb3532",
        "filename": "lib/el3_runtime/aarch64/context.S",
        "patchSetId": 1
      },
      "lineNbr": 484,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2020-09-15T14:32:08Z",
      "side": 0,
      "message": "Hi Sumit, your argument assumes that the only use of the timer is through interrupts. It can simply be used for delay loops in which case you don\u0027t need any interrupts.\n\nIf an NS entity has setup the timer to fire every 10ms, and decides to enter secure world, the way i view it is that the timer/counter is counting ticks accumulated in a particular world and the save restore of the registers would fairly accurately reflect that. At the end of 10ms of NS execution time, the timer would reliably fire. Moreover, even if you set the timer to fire every 10ms, and enter a trusted app that is written poorly or takes \u003e10ms, the NS timer interrupt handler would not reliably be triggered at 10 ms since secure world can block the NS interrupt until it completes.\n\nAgree with your statement that EL3 can reliably share the secure timer with S-EL1 but whether or not to do it, i think, should be a platform choice.\n\nAlso note that secure physical timer is not accessible from S-EL0 AFAIK so the only way to have delay loops in S-EL0 appears to be context-switching the timer registers.",
      "parentUuid": "356b4a80_30668920",
      "revId": "34029d01c6effbbd643413b69c851cc24d047eaa",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bd36bcc5_771976b0",
        "filename": "lib/el3_runtime/aarch64/context.S",
        "patchSetId": 1
      },
      "lineNbr": 484,
      "author": {
        "id": 1000132
      },
      "writtenOn": "2020-09-17T05:20:22Z",
      "side": 0,
      "message": "\u003e your argument assumes that the only use of the timer is through interrupts.\n\nLooking at section \"D6.1.5 Timers\" in the Armv8 Architecture reference manual, I could only observe timer operation in two modes as follows which relies on interrupts only:\n- Operation of the CompareValue views of the timers\n- Operation of the TimerValue views of the timers\n\nAnd there are three registers per timer as follows:\n- CompareValue register\n- TimerValue register\n- Control register\n\nSo these are the registers which doesn\u0027t seems to be shareable among non-secure and secure entities. And hence we shouldn\u0027t save/restore them.\n\n\u003e  It can simply be used for delay loops in which case you don\u0027t need any interrupts.\n\nFor delay loops we should use read only counter: CNTPCT_EL0 and frequency: CNTFRQ registers in order to calculate delays.\n\n\u003e If an NS entity has setup the timer to fire every 10ms, and decides to enter secure world, the way i view it is that the timer/counter is counting ticks accumulated in a particular world and the save restore of the registers would fairly accurately reflect that.\n\nWould timer value be decremented after its saved and prior to restore?\n\n\u003e Also note that secure physical timer is not accessible from S-EL0 AFAIK so the only way to have delay loops in S-EL0 appears to be context-switching the timer registers.\n\nAs I mentioned before we need to use CNTPCT_EL0 and CNTFRQ for delay loops. And to control their EL0 accessibility we use CNTKCTL, Counter-timer Kernel Control register which needs to be saved/restored, so that secure kernel and non-secure kernel can independently control corresponding EL0 accesses.",
      "parentUuid": "b0beb42a_53fb3532",
      "revId": "34029d01c6effbbd643413b69c851cc24d047eaa",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1379fe83_5512702c",
        "filename": "lib/el3_runtime/aarch64/context.S",
        "patchSetId": 1
      },
      "lineNbr": 484,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2020-09-21T18:36:24Z",
      "side": 0,
      "message": "Thanks Sumit.\n\n\u003eSo these are the registers which doesn\u0027t seems to be shareable among non-secure and secure entities.\n\nAll GPR\u0027s and all EL1 system registers fall under this category and are switched. Can you explain why the timer registers are special in this regard?\n\n\u003eFor delay loops we should use read only counter: CNTPCT_EL0 and frequency: CNTFRQ registers in order to calculate delays.\n\nFair point. Agree that should be how it is used.\n\n\u003eWould timer value be decremented after its saved and prior to restore?\n\nI would say no, but that would be a platform decision depending on what timer behavior they want(whether to decrement or not).\n\nIf we don\u0027t share cntp_ctl/cval_el0, and a platform does not want to share the secure physical timer between EL3 and S-EL1(configurable in SCR_EL3, and for whatever reason), what is your proposed solution in such a case?\nAlso if the secure kernel allows for access to these registers at S-EL0, are you suggesting that S-EL0 use NS timer values(security issue)?",
      "parentUuid": "bd36bcc5_771976b0",
      "revId": "34029d01c6effbbd643413b69c851cc24d047eaa",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    }
  ]
}