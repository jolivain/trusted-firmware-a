{
  "comments": [
    {
      "key": {
        "uuid": "4ad35a18_790510a7",
        "filename": "lib/el3_runtime/aarch64/context.S",
        "patchSetId": 1
      },
      "lineNbr": 484,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2020-09-14T17:21:28Z",
      "side": 0,
      "message": "I would rather see another build option introduced instead of deleting code. There are use cases where the secure physical timer is used by EL3 and the NS timer registers that are context switched are used by secure partitions on platforms that don\u0027t use OPTEE for example(and instead use FF-A based SPMC/SPMD etc).\n\n\nAlso some things to keep in mind: Not all platforms run OPTEE, not all platforms run linux. Not all platforms allow secure physical timer access to S-EL1/S-EL0. The use of timers should be a platform decision.",
      "revId": "34029d01c6effbbd643413b69c851cc24d047eaa",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "356b4a80_30668920",
        "filename": "lib/el3_runtime/aarch64/context.S",
        "patchSetId": 1
      },
      "lineNbr": 484,
      "author": {
        "id": 1000132
      },
      "writtenOn": "2020-09-15T07:09:40Z",
      "side": 0,
      "message": "I agree with you that there could be varying software stacks that could run in secure and non-secure worlds. But I am curious to know how a particular timer can be shared among secure and non-secure entity at runtime.\n\nAFAIK, a timer operates using a Private Peripheral Interrupt (PPI) and if we need to share a particular timer then this interrupt needs to be dynamically assigned during context switch as well and I can\u0027t find corresponding implementation in TF-A.\n\nAnd suppose if non-secure entity has setup a timer to fire every 10 ms and need to do context switch to secure entity. So would that timer fire reliably every 10 ms?\n\nIMO, EL3 should be able to reliably share secure physical timer with secure EL1 in case secure timer interrupt is routed via EL3.",
      "parentUuid": "4ad35a18_790510a7",
      "revId": "34029d01c6effbbd643413b69c851cc24d047eaa",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b0beb42a_53fb3532",
        "filename": "lib/el3_runtime/aarch64/context.S",
        "patchSetId": 1
      },
      "lineNbr": 484,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2020-09-15T14:32:08Z",
      "side": 0,
      "message": "Hi Sumit, your argument assumes that the only use of the timer is through interrupts. It can simply be used for delay loops in which case you don\u0027t need any interrupts.\n\nIf an NS entity has setup the timer to fire every 10ms, and decides to enter secure world, the way i view it is that the timer/counter is counting ticks accumulated in a particular world and the save restore of the registers would fairly accurately reflect that. At the end of 10ms of NS execution time, the timer would reliably fire. Moreover, even if you set the timer to fire every 10ms, and enter a trusted app that is written poorly or takes \u003e10ms, the NS timer interrupt handler would not reliably be triggered at 10 ms since secure world can block the NS interrupt until it completes.\n\nAgree with your statement that EL3 can reliably share the secure timer with S-EL1 but whether or not to do it, i think, should be a platform choice.\n\nAlso note that secure physical timer is not accessible from S-EL0 AFAIK so the only way to have delay loops in S-EL0 appears to be context-switching the timer registers.",
      "parentUuid": "356b4a80_30668920",
      "revId": "34029d01c6effbbd643413b69c851cc24d047eaa",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    }
  ]
}