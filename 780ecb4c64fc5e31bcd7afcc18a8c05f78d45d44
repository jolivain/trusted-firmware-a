{
  "comments": [
    {
      "key": {
        "uuid": "e96a6f10_7b2ef1f5",
        "filename": "drivers/arm/gic/v3/gicv3_helpers.c",
        "patchSetId": 2
      },
      "lineNbr": 337,
      "author": {
        "id": 1000162
      },
      "writtenOn": "2020-09-23T20:03:12Z",
      "side": 1,
      "message": "In general I am skeptical about adding these \"infinite\" loops in code. Is there any we can add an exit condition to the loop? This will help us catch issues on faulty or under development hardware e.g. FPGA.\n\nWe can maybe check if we have reached the end of the GICR MMIO aperture without seeing the TYPER_LAST_BIT (?)",
      "revId": "780ecb4c64fc5e31bcd7afcc18a8c05f78d45d44",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "43ee05c4_96be380f",
        "filename": "drivers/arm/gic/v3/gicv3_helpers.c",
        "patchSetId": 2
      },
      "lineNbr": 337,
      "author": {
        "id": 1000118
      },
      "writtenOn": "2020-09-23T20:06:06Z",
      "side": 1,
      "message": "Yeah, I see. Let me check how complicated it is to add a limit.",
      "parentUuid": "e96a6f10_7b2ef1f5",
      "revId": "780ecb4c64fc5e31bcd7afcc18a8c05f78d45d44",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b61f4f12_5ad52c70",
        "filename": "drivers/arm/gic/v3/gicv3_helpers.c",
        "patchSetId": 2
      },
      "lineNbr": 337,
      "author": {
        "id": 1000105
      },
      "writtenOn": "2020-09-24T11:45:04Z",
      "side": 1,
      "message": "Will PLATFORM_CORE_COUNT do the trick?",
      "parentUuid": "43ee05c4_96be380f",
      "revId": "780ecb4c64fc5e31bcd7afcc18a8c05f78d45d44",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ca140e31_4d191055",
        "filename": "drivers/arm/gic/v3/gicv3_helpers.c",
        "patchSetId": 2
      },
      "lineNbr": 340,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2020-09-23T16:24:39Z",
      "side": 1,
      "message": "Does this work if there are cores that are fused off?",
      "range": {
        "startLine": 338,
        "startChar": 1,
        "endLine": 340,
        "endChar": 46
      },
      "revId": "780ecb4c64fc5e31bcd7afcc18a8c05f78d45d44",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "59605947_3d81dba8",
        "filename": "drivers/arm/gic/v3/gicv3_helpers.c",
        "patchSetId": 2
      },
      "lineNbr": 340,
      "author": {
        "id": 1000118
      },
      "writtenOn": "2020-09-23T16:35:12Z",
      "side": 1,
      "message": "What do you mean with \"fused off\", exactly? If you mean: \"fuses burned at the fab to down-core SoCs\", then this better would cover the GICR as well.\nWe use this very same algorithm above, and also Linux iterates through the GICR frames until it finds the LAST bit set. If there is none, it panics (the reason for this patch, actually).\nSo I would hope silicon vendors have considered this ;-)",
      "parentUuid": "ca140e31_4d191055",
      "range": {
        "startLine": 338,
        "startChar": 1,
        "endLine": 340,
        "endChar": 46
      },
      "revId": "780ecb4c64fc5e31bcd7afcc18a8c05f78d45d44",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f8802989_b625e078",
        "filename": "drivers/arm/gic/v3/gicv3_helpers.c",
        "patchSetId": 2
      },
      "lineNbr": 340,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2020-09-23T16:50:06Z",
      "side": 1,
      "message": "Thanks. Fuses burned at the fab to down-core SoC\u0027s is what i meant. What you say is usually the case but i have seen cases where this is not true ;).\nAlso are we sure linux uses this algorithm? At least on ACPI systems, this information is provided in the ACPI tables and i thought linux would use ACPI to find number of cores. Fusing off cores does not necessarily mean fusing off access to GICR MMIO accesses or returning error responses to the MMIO accesses(some may just hang the bus ;)).\nIf this is valid, does the GIC spec or ARM ARM call this out as a valid method to determine number of cores?",
      "parentUuid": "59605947_3d81dba8",
      "range": {
        "startLine": 338,
        "startChar": 1,
        "endLine": 340,
        "endChar": 46
      },
      "revId": "780ecb4c64fc5e31bcd7afcc18a8c05f78d45d44",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7616d6da_4615a7c8",
        "filename": "drivers/arm/gic/v3/gicv3_helpers.c",
        "patchSetId": 2
      },
      "lineNbr": 340,
      "author": {
        "id": 1000118
      },
      "writtenOn": "2020-09-23T17:15:48Z",
      "side": 1,
      "message": "Linux\u0027 GICv3 driver uses this, regardless of the firmware table method used to discover the GIC: https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/irqchip/irq-gic-v3.c#n798\nIt is not used to discover the number of cores, but to initialise each GICR frame. As mentioned the reason for this patch is that if Linux does not find the LAST bit in the provided region, this won\u0027t end well. By mimicking this approach, I would think it\u0027s as safe as it can be.\n\nAlso: while this function is meant to be as generic as possible, it\u0027s not called by generic code. Instead it\u0027s up to the platform to call this, and we hope this would only be done on platforms where this would work.\n\nDo you have an example (that you can disclose) of where this is broken? If you can describe how it behaves, I could try to make this algorithm work nevertheless.",
      "parentUuid": "f8802989_b625e078",
      "range": {
        "startLine": 338,
        "startChar": 1,
        "endLine": 340,
        "endChar": 46
      },
      "revId": "780ecb4c64fc5e31bcd7afcc18a8c05f78d45d44",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "dc5c54d0_69669746",
        "filename": "drivers/arm/gic/v3/gicv3_helpers.c",
        "patchSetId": 2
      },
      "lineNbr": 340,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2020-09-23T18:25:20Z",
      "side": 1,
      "message": "Thanks. Agree with argument that it is safe is the kernel is doing it..Cannot tell you where it is broken but have had to skip redistributor frames on large core systems where cores are not linearly fused off, as in core 0,1,5,6 are present and 2,3,4 are fused off. I may be mis-remembering. It is also possible that the GICR frames are relocated to account for this to make all cores look linear.\nThe patch looks fine, i was just curious if we needed to consider this and if this was acceptable architecturally. seems like the case with the kernel driver.",
      "parentUuid": "7616d6da_4615a7c8",
      "range": {
        "startLine": 338,
        "startChar": 1,
        "endLine": 340,
        "endChar": 46
      },
      "revId": "780ecb4c64fc5e31bcd7afcc18a8c05f78d45d44",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b3f8462c_cb307147",
        "filename": "drivers/arm/gic/v3/gicv3_helpers.c",
        "patchSetId": 2
      },
      "lineNbr": 340,
      "author": {
        "id": 1000118
      },
      "writtenOn": "2020-09-23T20:04:23Z",
      "side": 1,
      "message": "I think originally the GIC spec stipulated that GICR frames need to be contiguous, but this was quickly overridden by reality (multi-socket SoCs with multiple GICR regions). Other vendors got the stride wrong (128K vs. 256K), that\u0027s why the DT allows to tune those two ;-)\nThis random fusing-off might work if all the GICR frames stay alive (at least GICR_TYPER should work), even though they don\u0027t need to \"work\" otherwise. TYPER contains a processor number and the MPIDR, so you can ignore those without matching cores. And as the GICR frames are typically part of the GIC, not the cores, this should not be a problem. But this is an implementation detail, so I can surely imagine this breaking in various ways.\nBut let\u0027s worry about this when we see it ;-)",
      "parentUuid": "dc5c54d0_69669746",
      "range": {
        "startLine": 338,
        "startChar": 1,
        "endLine": 340,
        "endChar": 46
      },
      "revId": "780ecb4c64fc5e31bcd7afcc18a8c05f78d45d44",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c1391070_6d7cfa6d",
        "filename": "drivers/arm/gic/v3/gicv3_helpers.c",
        "patchSetId": 2
      },
      "lineNbr": 340,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2020-09-23T21:21:24Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "b3f8462c_cb307147",
      "range": {
        "startLine": 338,
        "startChar": 1,
        "endLine": 340,
        "endChar": 46
      },
      "revId": "780ecb4c64fc5e31bcd7afcc18a8c05f78d45d44",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": false
    }
  ]
}