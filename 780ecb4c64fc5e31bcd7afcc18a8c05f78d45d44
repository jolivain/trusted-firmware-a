{
  "comments": [
    {
      "key": {
        "uuid": "ca140e31_4d191055",
        "filename": "drivers/arm/gic/v3/gicv3_helpers.c",
        "patchSetId": 2
      },
      "lineNbr": 340,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2020-09-23T16:24:39Z",
      "side": 1,
      "message": "Does this work if there are cores that are fused off?",
      "range": {
        "startLine": 338,
        "startChar": 1,
        "endLine": 340,
        "endChar": 46
      },
      "revId": "780ecb4c64fc5e31bcd7afcc18a8c05f78d45d44",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "59605947_3d81dba8",
        "filename": "drivers/arm/gic/v3/gicv3_helpers.c",
        "patchSetId": 2
      },
      "lineNbr": 340,
      "author": {
        "id": 1000118
      },
      "writtenOn": "2020-09-23T16:35:12Z",
      "side": 1,
      "message": "What do you mean with \"fused off\", exactly? If you mean: \"fuses burned at the fab to down-core SoCs\", then this better would cover the GICR as well.\nWe use this very same algorithm above, and also Linux iterates through the GICR frames until it finds the LAST bit set. If there is none, it panics (the reason for this patch, actually).\nSo I would hope silicon vendors have considered this ;-)",
      "parentUuid": "ca140e31_4d191055",
      "range": {
        "startLine": 338,
        "startChar": 1,
        "endLine": 340,
        "endChar": 46
      },
      "revId": "780ecb4c64fc5e31bcd7afcc18a8c05f78d45d44",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f8802989_b625e078",
        "filename": "drivers/arm/gic/v3/gicv3_helpers.c",
        "patchSetId": 2
      },
      "lineNbr": 340,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2020-09-23T16:50:06Z",
      "side": 1,
      "message": "Thanks. Fuses burned at the fab to down-core SoC\u0027s is what i meant. What you say is usually the case but i have seen cases where this is not true ;).\nAlso are we sure linux uses this algorithm? At least on ACPI systems, this information is provided in the ACPI tables and i thought linux would use ACPI to find number of cores. Fusing off cores does not necessarily mean fusing off access to GICR MMIO accesses or returning error responses to the MMIO accesses(some may just hang the bus ;)).\nIf this is valid, does the GIC spec or ARM ARM call this out as a valid method to determine number of cores?",
      "parentUuid": "59605947_3d81dba8",
      "range": {
        "startLine": 338,
        "startChar": 1,
        "endLine": 340,
        "endChar": 46
      },
      "revId": "780ecb4c64fc5e31bcd7afcc18a8c05f78d45d44",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7616d6da_4615a7c8",
        "filename": "drivers/arm/gic/v3/gicv3_helpers.c",
        "patchSetId": 2
      },
      "lineNbr": 340,
      "author": {
        "id": 1000118
      },
      "writtenOn": "2020-09-23T17:15:48Z",
      "side": 1,
      "message": "Linux\u0027 GICv3 driver uses this, regardless of the firmware table method used to discover the GIC: https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/irqchip/irq-gic-v3.c#n798\nIt is not used to discover the number of cores, but to initialise each GICR frame. As mentioned the reason for this patch is that if Linux does not find the LAST bit in the provided region, this won\u0027t end well. By mimicking this approach, I would think it\u0027s as safe as it can be.\n\nAlso: while this function is meant to be as generic as possible, it\u0027s not called by generic code. Instead it\u0027s up to the platform to call this, and we hope this would only be done on platforms where this would work.\n\nDo you have an example (that you can disclose) of where this is broken? If you can describe how it behaves, I could try to make this algorithm work nevertheless.",
      "parentUuid": "f8802989_b625e078",
      "range": {
        "startLine": 338,
        "startChar": 1,
        "endLine": 340,
        "endChar": 46
      },
      "revId": "780ecb4c64fc5e31bcd7afcc18a8c05f78d45d44",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "dc5c54d0_69669746",
        "filename": "drivers/arm/gic/v3/gicv3_helpers.c",
        "patchSetId": 2
      },
      "lineNbr": 340,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2020-09-23T18:25:20Z",
      "side": 1,
      "message": "Thanks. Agree with argument that it is safe is the kernel is doing it..Cannot tell you where it is broken but have had to skip redistributor frames on large core systems where cores are not linearly fused off, as in core 0,1,5,6 are present and 2,3,4 are fused off. I may be mis-remembering. It is also possible that the GICR frames are relocated to account for this to make all cores look linear.\nThe patch looks fine, i was just curious if we needed to consider this and if this was acceptable architecturally. seems like the case with the kernel driver.",
      "parentUuid": "7616d6da_4615a7c8",
      "range": {
        "startLine": 338,
        "startChar": 1,
        "endLine": 340,
        "endChar": 46
      },
      "revId": "780ecb4c64fc5e31bcd7afcc18a8c05f78d45d44",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    }
  ]
}