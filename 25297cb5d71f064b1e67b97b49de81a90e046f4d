{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "43ceeb06_aefc9ebf",
        "filename": "services/std_svc/spmd/spmd_main.c",
        "patchSetId": 4
      },
      "lineNbr": 46,
      "author": {
        "id": 1000341
      },
      "writtenOn": "2023-09-06T16:05:36Z",
      "side": 1,
      "message": "Use the SPM_PROTECT/UNPROTECT instead?",
      "range": {
        "startLine": 42,
        "startChar": 0,
        "endLine": 46,
        "endChar": 70
      },
      "revId": "25297cb5d71f064b1e67b97b49de81a90e046f4d",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "db56b207_61d6d743",
        "filename": "services/std_svc/spmd/spmd_main.c",
        "patchSetId": 4
      },
      "lineNbr": 866,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2023-09-06T16:23:08Z",
      "side": 1,
      "message": "There is a lock inside this API which is being locked and unlocked for every invocation. To ensure correct operation, the lock needs to be held for the entire range. I think you would need to introduce a gpt_delegate_pas_range() API.\n\nThere are some alternatives:\n\n1. Return the last address successfully delgated. Then the caller decide whether to stick with the reduced range, or undelegate the delegation so far.\n\n2. This SMC only delegates on a page basis, this way the caller has full control and can decide on corrective action if a single page delegation fails.",
      "range": {
        "startLine": 866,
        "startChar": 5,
        "endLine": 866,
        "endChar": 21
      },
      "revId": "25297cb5d71f064b1e67b97b49de81a90e046f4d",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    }
  ]
}