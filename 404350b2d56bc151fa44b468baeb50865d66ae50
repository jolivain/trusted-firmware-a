{
  "comments": [
    {
      "key": {
        "uuid": "3830e70c_e0bf9640",
        "filename": "lib/locks/bakery/bakery_lock_normal.c",
        "patchSetId": 1
      },
      "lineNbr": 80,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2020-02-19T16:12:56Z",
      "side": 1,
      "message": "do you not need the dsbish() even if not cached ? The memory in which the lock resides may be normal non-cacheable so accesses may still be reordered.",
      "revId": "404350b2d56bc151fa44b468baeb50865d66ae50",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e906dacb_0ce4dd51",
        "filename": "lib/locks/bakery/bakery_lock_normal.c",
        "patchSetId": 1
      },
      "lineNbr": 80,
      "author": {
        "id": 1000098
      },
      "writtenOn": "2020-02-19T17:05:42Z",
      "side": 1,
      "message": "DMB ensures that all explicit data accesses before DMB in program order are observed before any explicit data access after the DMB. All data cache operations are treated as explicit data accesses. Hence I believe a DMB is sufficient in this scenario instead of the heavy-weight DSB. \n\nI also agree the barrier should be placed irrespective of data being cacheable or not because non-cacheable normal memory can still be bufferable. I mean an older store instruction could be stuck in shadow buffers.",
      "parentUuid": "3830e70c_e0bf9640",
      "revId": "404350b2d56bc151fa44b468baeb50865d66ae50",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    }
  ]
}