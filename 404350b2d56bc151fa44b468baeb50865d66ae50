{
  "comments": [
    {
      "key": {
        "uuid": "3830e70c_e0bf9640",
        "filename": "lib/locks/bakery/bakery_lock_normal.c",
        "patchSetId": 1
      },
      "lineNbr": 80,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2020-02-19T16:12:56Z",
      "side": 1,
      "message": "do you not need the dsbish() even if not cached ? The memory in which the lock resides may be normal non-cacheable so accesses may still be reordered.",
      "revId": "404350b2d56bc151fa44b468baeb50865d66ae50",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e906dacb_0ce4dd51",
        "filename": "lib/locks/bakery/bakery_lock_normal.c",
        "patchSetId": 1
      },
      "lineNbr": 80,
      "author": {
        "id": 1000098
      },
      "writtenOn": "2020-02-19T17:05:42Z",
      "side": 1,
      "message": "DMB ensures that all explicit data accesses before DMB in program order are observed before any explicit data access after the DMB. All data cache operations are treated as explicit data accesses. Hence I believe a DMB is sufficient in this scenario instead of the heavy-weight DSB. \n\nI also agree the barrier should be placed irrespective of data being cacheable or not because non-cacheable normal memory can still be bufferable. I mean an older store instruction could be stuck in shadow buffers.",
      "parentUuid": "3830e70c_e0bf9640",
      "revId": "404350b2d56bc151fa44b468baeb50865d66ae50",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2e6b944b_30f8835c",
        "filename": "lib/locks/bakery/bakery_lock_normal.c",
        "patchSetId": 1
      },
      "lineNbr": 80,
      "author": {
        "id": 1000162
      },
      "writtenOn": "2020-02-19T17:49:13Z",
      "side": 1,
      "message": "Thanks. I will move dsbish() out of the if condition",
      "parentUuid": "e906dacb_0ce4dd51",
      "revId": "404350b2d56bc151fa44b468baeb50865d66ae50",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0ef80894_daa920ae",
        "filename": "lib/locks/bakery/bakery_lock_normal.c",
        "patchSetId": 1
      },
      "lineNbr": 80,
      "author": {
        "id": 1000098
      },
      "writtenOn": "2020-02-19T18:17:44Z",
      "side": 1,
      "message": "why not DMB instead of DSB as per my above explanation?",
      "parentUuid": "2e6b944b_30f8835c",
      "revId": "404350b2d56bc151fa44b468baeb50865d66ae50",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6687bdd4_0e6bfb32",
        "filename": "lib/locks/bakery/bakery_lock_normal.c",
        "patchSetId": 1
      },
      "lineNbr": 80,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2020-02-19T18:24:03Z",
      "side": 1,
      "message": "I don\u0027t think it is sufficient to use a DMB here. DMB marks store buffers(abstractly) but does not guarantee that the store from the dc instruction is complete and visible to all other observers. Without that, the ticket number chosen for a contender could sit in the buffers and not be visible to other contenders. If i understand correctly, before a thread attempts to acquire the lock, it\u0027s ticket number must be guaranteed to be visible to all observers and only DSB can do that.",
      "parentUuid": "0ef80894_daa920ae",
      "revId": "404350b2d56bc151fa44b468baeb50865d66ae50",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5233f755_0c3e53f7",
        "filename": "lib/locks/bakery/bakery_lock_normal.c",
        "patchSetId": 1
      },
      "lineNbr": 80,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2020-02-19T18:28:33Z",
      "side": 1,
      "message": "my mistake. I\u0027m thinking of write_cahce_op. For read_cache_op dmb should be sufficient.",
      "parentUuid": "6687bdd4_0e6bfb32",
      "revId": "404350b2d56bc151fa44b468baeb50865d66ae50",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    }
  ]
}