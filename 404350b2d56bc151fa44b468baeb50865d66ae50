{
  "comments": [
    {
      "key": {
        "uuid": "3830e70c_e0bf9640",
        "filename": "lib/locks/bakery/bakery_lock_normal.c",
        "patchSetId": 1
      },
      "lineNbr": 80,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2020-02-19T16:12:56Z",
      "side": 1,
      "message": "do you not need the dsbish() even if not cached ? The memory in which the lock resides may be normal non-cacheable so accesses may still be reordered.",
      "revId": "404350b2d56bc151fa44b468baeb50865d66ae50",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e906dacb_0ce4dd51",
        "filename": "lib/locks/bakery/bakery_lock_normal.c",
        "patchSetId": 1
      },
      "lineNbr": 80,
      "author": {
        "id": 1000098
      },
      "writtenOn": "2020-02-19T17:05:42Z",
      "side": 1,
      "message": "DMB ensures that all explicit data accesses before DMB in program order are observed before any explicit data access after the DMB. All data cache operations are treated as explicit data accesses. Hence I believe a DMB is sufficient in this scenario instead of the heavy-weight DSB. \n\nI also agree the barrier should be placed irrespective of data being cacheable or not because non-cacheable normal memory can still be bufferable. I mean an older store instruction could be stuck in shadow buffers.",
      "parentUuid": "3830e70c_e0bf9640",
      "revId": "404350b2d56bc151fa44b468baeb50865d66ae50",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2e6b944b_30f8835c",
        "filename": "lib/locks/bakery/bakery_lock_normal.c",
        "patchSetId": 1
      },
      "lineNbr": 80,
      "author": {
        "id": 1000162
      },
      "writtenOn": "2020-02-19T17:49:13Z",
      "side": 1,
      "message": "Thanks. I will move dsbish() out of the if condition",
      "parentUuid": "e906dacb_0ce4dd51",
      "revId": "404350b2d56bc151fa44b468baeb50865d66ae50",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0ef80894_daa920ae",
        "filename": "lib/locks/bakery/bakery_lock_normal.c",
        "patchSetId": 1
      },
      "lineNbr": 80,
      "author": {
        "id": 1000098
      },
      "writtenOn": "2020-02-19T18:17:44Z",
      "side": 1,
      "message": "why not DMB instead of DSB as per my above explanation?",
      "parentUuid": "2e6b944b_30f8835c",
      "revId": "404350b2d56bc151fa44b468baeb50865d66ae50",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6687bdd4_0e6bfb32",
        "filename": "lib/locks/bakery/bakery_lock_normal.c",
        "patchSetId": 1
      },
      "lineNbr": 80,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2020-02-19T18:24:03Z",
      "side": 1,
      "message": "I don\u0027t think it is sufficient to use a DMB here. DMB marks store buffers(abstractly) but does not guarantee that the store from the dc instruction is complete and visible to all other observers. Without that, the ticket number chosen for a contender could sit in the buffers and not be visible to other contenders. If i understand correctly, before a thread attempts to acquire the lock, it\u0027s ticket number must be guaranteed to be visible to all observers and only DSB can do that.",
      "parentUuid": "0ef80894_daa920ae",
      "revId": "404350b2d56bc151fa44b468baeb50865d66ae50",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5233f755_0c3e53f7",
        "filename": "lib/locks/bakery/bakery_lock_normal.c",
        "patchSetId": 1
      },
      "lineNbr": 80,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2020-02-19T18:28:33Z",
      "side": 1,
      "message": "my mistake. I\u0027m thinking of write_cahce_op. For read_cache_op dmb should be sufficient.",
      "parentUuid": "6687bdd4_0e6bfb32",
      "revId": "404350b2d56bc151fa44b468baeb50865d66ae50",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7cfa065e_0cbe9a89",
        "filename": "lib/locks/bakery/bakery_lock_normal.c",
        "patchSetId": 1
      },
      "lineNbr": 80,
      "author": {
        "id": 1000162
      },
      "writtenOn": "2020-02-21T20:18:23Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "5233f755_0c3e53f7",
      "revId": "404350b2d56bc151fa44b468baeb50865d66ae50",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8c5abab5_245ae6d6",
        "filename": "lib/locks/bakery/bakery_lock_normal.c",
        "patchSetId": 1
      },
      "lineNbr": 80,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2020-03-09T13:35:27Z",
      "side": 1,
      "message": "I still think a dsbish is required. This is just to ensure that the dccivac() is completed before the read is executed. \n\nSo perhaps this would be better way:\n\n\nstatic inline void read_cache_op(uintptr_t addr, bool cached)\n{\n\tif (cached) {\n\t\tdccivac(addr);\n\t\tdsbish();\n\t} else {\n\t\tdmbish();\n\t}\n}",
      "parentUuid": "7cfa065e_0cbe9a89",
      "revId": "404350b2d56bc151fa44b468baeb50865d66ae50",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f50129e1_0f879f3b",
        "filename": "lib/locks/bakery/bakery_lock_normal.c",
        "patchSetId": 1
      },
      "lineNbr": 80,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2020-03-09T17:57:28Z",
      "side": 1,
      "message": "If we are doing this, it would be nice to add some comments on why DSB is required when cached and why DMB is sufficient when not cached. I think the lighter DMB is sufficient here as Madhukar pointed out, since, here, we only want to make sure that the executing CPU see\u0027s a new value and not an already cached value. We don\u0027t need to ensure that the DC instruction is complete for all observers and only need to ensure that the invalidation is complete on the local CPU. DMB should be able to do this, based on my reading of K11.5 of the ARM ARM.",
      "parentUuid": "8c5abab5_245ae6d6",
      "revId": "404350b2d56bc151fa44b468baeb50865d66ae50",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": false
    }
  ]
}