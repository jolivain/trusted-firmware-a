{
  "comments": [
    {
      "key": {
        "uuid": "58145c0a_7b348f7c",
        "filename": "drivers/allwinner/axp/axp805.c",
        "patchSetId": 2
      },
      "lineNbr": 23,
      "author": {
        "id": 1000118
      },
      "writtenOn": "2019-11-27T15:49:52Z",
      "side": 1,
      "message": "According to (my copy of) the manual, ALDO2 goes up to 3.4 volts.\n\nIn general I was tending to just name those regulators that are actually used (as in: programmed by ATF), to avoid having untested data in here. This would apply to DCDCB, DCDCC, BLDO4, CLDO2, CLDO3, which wouldn\u0027t be enabled by ATF judging by the DTs in the kernel.",
      "revId": "5fdc76d61c85befb46711456439ee6c9b129997d",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a31a14d5_4c9ccbe6",
        "filename": "drivers/allwinner/axp/axp805.c",
        "patchSetId": 2
      },
      "lineNbr": 23,
      "author": {
        "id": 1000126
      },
      "writtenOn": "2019-12-04T09:29:05Z",
      "side": 1,
      "message": "\u003e According to (my copy of) the manual, ALDO2 goes up to 3.4 volts.\n\nThat\u0027s an error in the manual. It says 3.3V on page 7/16/24, and it\u0027s the same 27 100mV steps starting at 0.7V as ALDO1 and ALDO3.\n\n\u003e In general I was tending to just name those regulators that are actually used (as in: programmed by ATF), to avoid having untested data in here. This would apply to DCDCB, DCDCC, BLDO4, CLDO2, CLDO3, which wouldn\u0027t be enabled by ATF judging by the DTs in the kernel.\n\nI don\u0027t see any particular harm in putting all of the regulators here. The interface is consistent across all regulators, and it avoids needing to come back and add things later (like we\u0027re doing now for AXP803).\n\nI *do* think there\u0027s a case to be made for only touching regulators with a \"regulator-boot-on\" property, and not everything with a phandle. The obvious scenario is where the user disables the driver and/or DT node for a peripheral to save power, but the regulator \"magically\" gets turned on anyway.",
      "parentUuid": "58145c0a_7b348f7c",
      "revId": "5fdc76d61c85befb46711456439ee6c9b129997d",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "dce36c8b_273fdc30",
        "filename": "drivers/allwinner/axp/axp805.c",
        "patchSetId": 2
      },
      "lineNbr": 23,
      "author": {
        "id": 1000118
      },
      "writtenOn": "2019-12-17T16:48:59Z",
      "side": 1,
      "message": "\u003e I *do* think there\u0027s a case to be made for only touching regulators with a \"regulator-boot-on\" property, and not everything with a phandle.\n\nI see your point, but the problem at hand back then was the Ethernet and HDMI PHY power supply on the Pine64. Both are (potentially) used in U-Boot, thus should be enabled by then. I am not sure \"regulator-boot-on\" was meant for this use case.\n\n\u003e The obvious scenario is where the user disables the driver and/or DT node for a peripheral to save power, but the regulator \"magically\" gets turned on anyway.\n\nWhen there is no user of a device, Linux will turn off the regulator. This applies to disabled devices, unused devices (no driver at all) or drivers that fail to initialise. Any OS concerned about power consumption would probably do something similar.\n\nI am happy to keep all the regulators in (as in your patch), just wanted to comment on these issues.",
      "parentUuid": "a31a14d5_4c9ccbe6",
      "revId": "5fdc76d61c85befb46711456439ee6c9b129997d",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "213ca7e1_8e7946b7",
        "filename": "drivers/allwinner/axp/common.c",
        "patchSetId": 2
      },
      "lineNbr": 170,
      "author": {
        "id": 1000118
      },
      "writtenOn": "2019-11-27T15:49:52Z",
      "side": 1,
      "message": "Can you please split this up to explicitly compare against both chip IDs? Otherwise a new PMIC could accidentally trigger this register write. According to Murphy\u0027s law 0x11 would be the \"set-board-on-fire\" register there ;-)",
      "revId": "5fdc76d61c85befb46711456439ee6c9b129997d",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e5b5fe58_4942e21f",
        "filename": "drivers/allwinner/axp/common.c",
        "patchSetId": 2
      },
      "lineNbr": 170,
      "author": {
        "id": 1000126
      },
      "writtenOn": "2019-12-04T09:31:27Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "213ca7e1_8e7946b7",
      "revId": "5fdc76d61c85befb46711456439ee6c9b129997d",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "dec0034c_39a8cd10",
        "filename": "include/drivers/allwinner/axp.h",
        "patchSetId": 2
      },
      "lineNbr": 16,
      "author": {
        "id": 1000105
      },
      "writtenOn": "2019-11-04T09:58:18Z",
      "side": 1,
      "message": "remove \",\"",
      "revId": "5fdc76d61c85befb46711456439ee6c9b129997d",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9a2b9600_df57f4e7",
        "filename": "include/drivers/allwinner/axp.h",
        "patchSetId": 2
      },
      "lineNbr": 16,
      "author": {
        "id": 1000126
      },
      "writtenOn": "2019-11-05T04:22:43Z",
      "side": 1,
      "message": "I generally prefer to keep the trailing comma, so appending a new entry (exactly the situation in this commit) doesn\u0027t require modifying the preceding line. I see this pattern being used several places throughout the codebase.",
      "parentUuid": "dec0034c_39a8cd10",
      "revId": "5fdc76d61c85befb46711456439ee6c9b129997d",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    }
  ]
}