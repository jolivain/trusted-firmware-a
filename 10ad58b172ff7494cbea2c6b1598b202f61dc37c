{
  "comments": [
    {
      "key": {
        "uuid": "f4c156b3_8fb60b8f",
        "filename": "lib/xlat_tables_v2/xlat_tables_context.c",
        "patchSetId": 3
      },
      "lineNbr": 146,
      "author": {
        "id": 1000098
      },
      "writtenOn": "2020-02-12T00:10:54Z",
      "side": 1,
      "message": "Using this function, I understand that the pages holding the xlat tables are mapped as read only to stop an attacker from modifying a descriptor that contains the memory attributes of a page in secure memory. I was wondering why the base tables had to be allocated in \".rodata\" section.",
      "revId": "10ad58b172ff7494cbea2c6b1598b202f61dc37c",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "829445c1_49706091",
        "filename": "lib/xlat_tables_v2/xlat_tables_context.c",
        "patchSetId": 3
      },
      "lineNbr": 146,
      "author": {
        "id": 1000296
      },
      "writtenOn": "2020-02-12T17:22:14Z",
      "side": 1,
      "message": "The tables are created(well, initialized...) by the init_xlat_tables* family of functions. This function simply changes attributes in the page descriptors that resolve address translation to the tables themselves (my head hurts typing this lol). So, if the L2 and L3 tables occupy 5 pages in memory, it changes 5 descriptors to apply read-only permissions to those pages.\nIf we don\u0027t make the base table read-only, then the attacker can simply use that to create new L2 and L3 tables and map whatever memory they want. Why move them to .rodata instead of xlat_table? Because the base table is smaller (has like only 1-2 entries) than a full page table. The xlat_table section must be 4KB aligned, which means that if we put the base table there, the size of the BL image increases by a full 4KB page, whereas .rodata would only become 512B-aligned and thus we pay a smaller price.",
      "parentUuid": "f4c156b3_8fb60b8f",
      "revId": "10ad58b172ff7494cbea2c6b1598b202f61dc37c",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e99e1451_ffc609e5",
        "filename": "lib/xlat_tables_v2/xlat_tables_context.c",
        "patchSetId": 3
      },
      "lineNbr": 146,
      "author": {
        "id": 1000328
      },
      "writtenOn": "2020-02-12T21:29:29Z",
      "side": 1,
      "message": "Is TTBRx (translation base register) also protected from external attack? As per ARM documentation, there is \"CP15SDISABLE\" signal is asserted HIGH in order to protect access of system control registers.",
      "parentUuid": "829445c1_49706091",
      "revId": "10ad58b172ff7494cbea2c6b1598b202f61dc37c",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "22d5e321_0936e195",
        "filename": "lib/xlat_tables_v2/xlat_tables_context.c",
        "patchSetId": 3
      },
      "lineNbr": 146,
      "author": {
        "id": 1000296
      },
      "writtenOn": "2020-02-13T15:03:07Z",
      "side": 1,
      "message": "The ways in which \"CP15SDISABLE\" can be taken HIGH or LOW is implementation defined, so not under our control. So, for EL3 using AArch32, I don\u0027t think there is something we can do to prevent the secure world from writing to TTBR0/1. However, from my understanding of the manual, the normal world would not be able to write to the secure TTBRx (I see TTBRx_NS and TTBRx_S in the manual pseudo-code for accesses to TTBRx). Therefore, some kind of gadget would still be required. This could also happen on AArch64 - someone with a gadget that can, say, modify TTBR0_EL3 can completely remap the memory (well, they\u0027d probably need another gadget that can invalidate TLB entries to see the actual effects, but you get the idea).\nSo, to sum up, if by \"external\" you mean the Normal world, I believe the Secure TTBR is protected. If it\u0027s coming from the Secure world, then they would need two gadgets (one to modify TTBR, one to invalidate TLB entries to make their mapping changes take effect) on both AArch32 and AArch64 (AArch64 needs more specific gadgets due to the higher number of exception levels).",
      "parentUuid": "e99e1451_ffc609e5",
      "revId": "10ad58b172ff7494cbea2c6b1598b202f61dc37c",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "aa3183f1_b1df3f22",
        "filename": "lib/xlat_tables_v2/xlat_tables_context.c",
        "patchSetId": 3
      },
      "lineNbr": 146,
      "author": {
        "id": 1000098
      },
      "writtenOn": "2020-02-13T23:09:42Z",
      "side": 1,
      "message": "Thanks for the wonderful explanation. I had a tough time understanding how xlat table library is implemented in TF-A, probably because of the inherent complexity associated with translation tables.",
      "parentUuid": "22d5e321_0936e195",
      "revId": "10ad58b172ff7494cbea2c6b1598b202f61dc37c",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cc39f40f_119db3e5",
        "filename": "lib/xlat_tables_v2/xlat_tables_context.c",
        "patchSetId": 3
      },
      "lineNbr": 146,
      "author": {
        "id": 1000328
      },
      "writtenOn": "2020-02-14T09:07:04Z",
      "side": 1,
      "message": "Thanks Petre for nice information.Any real example where this signal(CP15SDISABLE) is being used in order to lock system control registers?",
      "parentUuid": "aa3183f1_b1df3f22",
      "revId": "10ad58b172ff7494cbea2c6b1598b202f61dc37c",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    }
  ]
}