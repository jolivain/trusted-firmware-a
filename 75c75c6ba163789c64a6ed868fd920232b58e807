{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "6e680991_606ca484",
        "filename": "services/std_svc/rmmd/rmmd_attest.c",
        "patchSetId": 2
      },
      "lineNbr": 194,
      "author": {
        "id": 1000328
      },
      "writtenOn": "2024-06-20T08:08:21Z",
      "side": 1,
      "message": "I\u0027m just curious why this is an input parameter. Shouldn\u0027t the received key provide its properties, indicating whether it is ECDSA or RSA and its curve details? I believe we are always expecting this key to be ECDSA with the P-384 curve. Is that a requirement from the specification?",
      "revId": "75c75c6ba163789c64a6ed868fd920232b58e807",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3520f686_8a22ebdf",
        "filename": "services/std_svc/rmmd/rmmd_attest.c",
        "patchSetId": 2
      },
      "lineNbr": 194,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2024-06-20T14:41:55Z",
      "side": 1,
      "message": "Hi Manish, that is one possible way, i followed this approach to keep it consistent with rmmd_attest_get_signing_key(), which takes the ECC curve. The key algorithm etc should really be agile and we should be able to either specify or return the algorithm for the key. I\u0027m happy to change, but pretty much left it this way for consistency. \nI dont this the spec requires P-384, it can be any of RSA or ECDSA.",
      "parentUuid": "6e680991_606ca484",
      "revId": "75c75c6ba163789c64a6ed868fd920232b58e807",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f7a2e11c_fc3db3df",
        "filename": "services/std_svc/rmmd/rmmd_attest.c",
        "patchSetId": 2
      },
      "lineNbr": 194,
      "author": {
        "id": 1000328
      },
      "writtenOn": "2024-06-20T16:44:20Z",
      "side": 1,
      "message": "\u003e the key algorithm etc should really be agile and we should be able to either specify or return the algorithm for the key\n\nI need to check the details about rmmd_attest_get_signing_key. Specifying it as an input is fine, but I\u0027m not sure how it is actually used by the underlying platform function. Does it serve solely for verification (matching the received key algorithm with the inputted one), or does it retrieve the public key with this input?\n\n\u003e I dont this the spec requires P-384, it can be any of RSA or ECDSA. \n\nOkay, then why do we strictly check for only one algorithm at line no. 203?",
      "parentUuid": "3520f686_8a22ebdf",
      "revId": "75c75c6ba163789c64a6ed868fd920232b58e807",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7b65a364_3701ad9b",
        "filename": "services/std_svc/rmmd/rmmd_attest.c",
        "patchSetId": 2
      },
      "lineNbr": 194,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2024-06-20T18:06:50Z",
      "side": 1,
      "message": "same reason, following attest_get_signing_key :) It is possible a platform may have multiple algorithms supported so not sure why it was done that way, but didnt want to deviate. Let me know if you\u0027d like me to remove the paramter or the check, or both. I\u0027d prefer to leave it, and do it as a separate patch when somebody really needs to get rid of it.",
      "parentUuid": "f7a2e11c_fc3db3df",
      "revId": "75c75c6ba163789c64a6ed868fd920232b58e807",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a69f79b4_036a2741",
        "filename": "services/std_svc/rmmd/rmmd_main.c",
        "patchSetId": 2
      },
      "lineNbr": 475,
      "author": {
        "id": 1000328
      },
      "writtenOn": "2024-06-20T08:08:21Z",
      "side": 1,
      "message": "Do we really need to guard these SMCs implementations? Is this an optional feature? It would be helpful to provide details about this in section [1] if we decide to go with this option.\n\n[1]:https://git.trustedfirmware.org/TF-A/trusted-firmware-a/+/refs/heads/integration/docs/getting_started/build-options.rst",
      "range": {
        "startLine": 475,
        "startChar": 4,
        "endLine": 475,
        "endChar": 28
      },
      "revId": "75c75c6ba163789c64a6ed868fd920232b58e807",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bf135cd6_b914f496",
        "filename": "services/std_svc/rmmd/rmmd_main.c",
        "patchSetId": 2
      },
      "lineNbr": 475,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2024-06-20T14:41:55Z",
      "side": 1,
      "message": "on the documentation, yes, i will add it :) want to be sure we do use this approach before documenting it. \nAs for guards, yes, originally i did not have it (see other patches in this revieew), but since there are plat hooks, other platforms fail to build. So added this guard and made this platform specific. These are only required, when the RMM uses EL3+HES for attestation signing so i figured this was a good approach. Let me know if you have alternatives.",
      "parentUuid": "a69f79b4_036a2741",
      "range": {
        "startLine": 475,
        "startChar": 4,
        "endLine": 475,
        "endChar": 28
      },
      "revId": "75c75c6ba163789c64a6ed868fd920232b58e807",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fc986939_276b3b5a",
        "filename": "services/std_svc/rmmd/rmmd_main.c",
        "patchSetId": 2
      },
      "lineNbr": 475,
      "author": {
        "id": 1000328
      },
      "writtenOn": "2024-06-20T16:44:20Z",
      "side": 1,
      "message": "Yes, I think it looks fine in that case. I was just wondering why we didn\u0027t follow this for the other SMCs (for example, RMM_ATTEST_GET_REALM_KEY which is also using platform call), but I understand the intent. \nSo, IIUC, EL3+HES attestation signing support is also not mandatory for the platform as per the specification?",
      "parentUuid": "bf135cd6_b914f496",
      "range": {
        "startLine": 475,
        "startChar": 4,
        "endLine": 475,
        "endChar": 28
      },
      "revId": "75c75c6ba163789c64a6ed868fd920232b58e807",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e8e871ef_daff0960",
        "filename": "services/std_svc/rmmd/rmmd_main.c",
        "patchSetId": 2
      },
      "lineNbr": 475,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2024-06-20T18:06:50Z",
      "side": 1,
      "message": "correct. this is purely for platforms that CHOOSE to do it with the HES.",
      "parentUuid": "fc986939_276b3b5a",
      "range": {
        "startLine": 475,
        "startChar": 4,
        "endLine": 475,
        "endChar": 28
      },
      "revId": "75c75c6ba163789c64a6ed868fd920232b58e807",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "54f8a09e_beddeb5b",
        "filename": "services/std_svc/rmmd/rmmd_main.c",
        "patchSetId": 2
      },
      "lineNbr": 480,
      "author": {
        "id": 1000328
      },
      "writtenOn": "2024-06-20T08:08:21Z",
      "side": 1,
      "message": "I\u0027m just curiousâ€”do we need to continue calling this SMC until we get a successful response from it? It seems to act as a notifier for Nwd that the given request is completed. \nI\u0027m wondering why the push request can\u0027t block the call until the operation is completed by HES. Is it because the operation takes longer, necessitating the use of PULL_ATTEST_RESP SMC?",
      "range": {
        "startLine": 479,
        "startChar": 0,
        "endLine": 480,
        "endChar": 47
      },
      "revId": "75c75c6ba163789c64a6ed868fd920232b58e807",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "360ee3cb_ad6f6670",
        "filename": "services/std_svc/rmmd/rmmd_main.c",
        "patchSetId": 2
      },
      "lineNbr": 480,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2024-06-20T14:41:55Z",
      "side": 1,
      "message": "actually, in this case, NWd is not involved at all. This is purely between RMM and EL3. The semantics (which i can certainly document better) is that RMM will try to push and pull from EL3, assuming there is a queue maintained to push/pull responses from the HES or a mailbox between EL3/HES, which also requires polling and is equivalent to a queue length of 1 in EL3. So yes, it is possible RMM calls this in a loop, if it so chooses (we dont, we simply call it the next time RMM is given cycles). But the goal is both of the push and pull can return -EAGAIN to indicate the queue is full or there is an already existing request being processed, and RMM must call again to get the responses or push requests.\nLet me know if i can explain further.",
      "parentUuid": "54f8a09e_beddeb5b",
      "range": {
        "startLine": 479,
        "startChar": 0,
        "endLine": 480,
        "endChar": 47
      },
      "revId": "75c75c6ba163789c64a6ed868fd920232b58e807",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "85bb9e6a_8f9c6fdf",
        "filename": "services/std_svc/rmmd/rmmd_main.c",
        "patchSetId": 2
      },
      "lineNbr": 480,
      "author": {
        "id": 1000328
      },
      "writtenOn": "2024-06-20T16:44:20Z",
      "side": 1,
      "message": "\u003e actually, in this case, NWd is not involved at all. \n\nAh yes, I mean RMM ðŸ˜Š\n\n\u003e  The semantics (which i can certainly document better) is that RMM will try to push and pull from EL3, assuming there is a queue maintained to push/pull responses from the HES or a mailbox between EL3/HES, which also requires polling and is equivalent to a queue length of 1 in EL3. So yes, it is possible RMM calls this in a loop, if it so chooses (we dont, we simply call it the next time RMM is given cycles). But the goal is both of the push and pull can return -EAGAIN to indicate the queue is full or there is an already existing request being processed, and RMM must call again to get the responses or push requests.\n\nYes, I understood so basically retries mechanism is available for both PUSH and PULL SMCs.",
      "parentUuid": "360ee3cb_ad6f6670",
      "range": {
        "startLine": 479,
        "startChar": 0,
        "endLine": 480,
        "endChar": 47
      },
      "revId": "75c75c6ba163789c64a6ed868fd920232b58e807",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    }
  ]
}