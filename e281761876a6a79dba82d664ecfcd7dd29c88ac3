{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "9667a67a_ac768f7e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000469
      },
      "writtenOn": "2022-08-01T09:07:16Z",
      "side": 1,
      "message": "Hm. You are definitely right but trying to understand why I select this address. It should be 0xfffe5000. Can you please instead of revert to DDR just fix that address to stay in OCM? ",
      "revId": "e281761876a6a79dba82d664ecfcd7dd29c88ac3",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ac2ee4c5_798bfc3f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000864
      },
      "writtenOn": "2022-08-01T11:02:46Z",
      "side": 1,
      "message": "I would love to keep both ATF and OP-TEE OS in OCM but unfortunately we have a bit of chicken egg problem in that and OCM is a bit small for that.\n\nI have tried to picture the boot flow in here:\nhttps://github.com/OP-TEE/optee_os/pull/5350#issuecomment-1200408103\n\n(Feel free to join the discussion to provide Xilinx/AMD view on things ðŸ˜Š)\n\nWhen ATF is compiled with OP-TEE support its memory usage is:\n\n$ nm -v deploy/arm-trusted-firmware.elf  | grep __BL31_\n0000000000001000 T __BL31_START__\n000000000001a000 B __BL31_END__\n\nWhich is 100 KiB.\n\nBut during the boot FSBL also occupies the OCM memory and that is the entity trying to load more stuff in memory.\n\nNow our FSBL build without PMUFW is about 114 KiB:\n\n-rw-r--r-- 2 vej vej   117448 heinÃ¤  29 23:01 boot-usb-0.18.0.unsigned.bin\n\nAnd if you observe source .elf for that:\n\n$ nm -v fsbl-usb.elf | grep -E \u0027 (_vector_table|_end)$\u0027\n00000000fffc0000 T _vector_table\n00000000fffffc40 B _end\n\nWhich more or less consumes the whole OCM.\n\nAnd it is not often a good idea to load next binary into the memory that would override running code.\n\nSo far only way that I have figured out to fix that issue would be to:\n\n- Make FSBL build for Cortex-R5/lock-step mode that gets initially executed from 0xFFFC0000 (OCM start) (ROM requirement)\n- Relocate code execution to R5\u0027s TCM memory (in lock-step mode we have 256 KiB there too)\n- Relocate interrupt vectors and such to TCM\n- Load next Xilinx Image container image containing:\n  - (verify \u0026 decrypt on the go)\n  - PMUFW (to PMU)\n  - Bitstream (to PL)\n  - ATF (to OCM)\n  - OP-TEE (to DDR)\n  - DTB (to DDR)\n  - U-Boot (to DDR)\n- Prepare ATF handoff in OCM(?)\n- Boot ATF from Cortex-A53#0\n- Move R5F to \"deep sleep\"\n- ATF: Shutdown R5F and make cleanups for memory\n- Continue the boot\n\nNow the problem with that is that the real Cortex-R5F image must be loaded after U-Boot has been started as R5F is reserved during the boot. And probably should be firewalled by ATF so that it cannot touch OCM or other Trust Zone protected memories.\n\nAnd then about the OP-TEE OS -- we are current at:\n-rw-r--r-- 2 vej vej  425240 heinÃ¤  29 22:29 tee_raw.bin\n\nWhich would not fit in OCM ðŸ˜¢.\n\nNow if we come back to the actual code (as previously):\n\n#ifndef ZYNQMP_ATF_MEM_BASE\n#if !DEBUG \u0026\u0026 defined(SPD_none) \u0026\u0026 !SDEI_SUPPORT\n# define BL31_BASE                      U(0xfffea000)\n# define BL31_LIMIT                     U(0x100000000)\n#else\n# define BL31_BASE                      U(0x1000)\n# define BL31_LIMIT                     U(0x7ffff)\n#endif\n#else\n# define BL31_BASE                      (ZYNQMP_ATF_MEM_BASE)\n# define BL31_LIMIT                     (ZYNQMP_ATF_MEM_BASE + ZYNQMP_ATF_MEM_SIZE - 1)\n# ifdef ZYNQMP_ATF_MEM_PROGBITS_SIZE\n#  define BL31_PROGBITS_LIMIT           (ZYNQMP_ATF_MEM_BASE + ZYNQMP_ATF_MEM_PROGBITS_SIZE - 1)\n# endif\n#endif\n\nNow if we would change the default address for OP-TEE enabled boot case (eg. SPD_none is not defined) then it would try to load ATF in OCM which would then override running FSBL which is not a good idea.\n\nI suppose this whole #ifdef structure would need to be thinked as a whole as there are different configurations and different allocations. To me that looks like if your ATF is small (\u003c 88 KiB) then we can try to put it on OCM assuming that FSBL would actually be is small enough (and would not use memory at ATF\u0027s point).\n\nEven if R5F boot flow would be in use (as described above) then I suppose that would need to be flagged somehow in ATF build so that one can use also A53 FSBL boot flow.\n\nAny thoughs?",
      "parentUuid": "9667a67a_ac768f7e",
      "revId": "e281761876a6a79dba82d664ecfcd7dd29c88ac3",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6b40896c_405f034a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000469
      },
      "writtenOn": "2022-08-01T11:53:06Z",
      "side": 1,
      "message": "No doubt that OCM size is limiting factor here. And we can\u0027t do much about it.\n\nThis year we optimize pinctrl implementation in TF-A to reduce size to make sure that we can stay within current footprint in near future. There are some other places which can be optimized to find some space but still this won\u0027t solve problem with adding SPD to TF-A binary. \n\nLet me comment your post but before I dig into it. BL31_BASE/LIMIT can be configured before building to fit any of use case. And the address which I wanted to setup is an address which works fine with U-Boot SPL (not sure why origin patch didn\u0027t have it). And intentional debug configuration is without any SPD which should be possible to fit to OCM. \n\nBefore I did try pinctrl optimization I was thinking about couple of changes in SPL or FSBL which is that both of these SW have some low level code (a lot of the part of psu_init...) which is called only once. It means there is a option with marking initial functions before loading another images as init code and then free this space for using for other SW. It means FSBL will load TF-A from OCM start. This could give you additional space for also including SPD to the image. \nThe only use case which won\u0027t are any PM related configuration where APU restart only requires to still have FSBL in OCM. \nIt means there are ways but depends on use case you need to solve.\nAlso as you write using TCM memory can be also consider if can be used or not. \n\nI am not FSBL developer but that base addr which is setup for !DEBUG case should never be used by fsbl. Last page is maybe used for something but that location which is used for some time should be without any issue. It means you should take a look at sections in elf file to see what it is loaded where. \n\nAnyway as I said these addresses are supposed to target default cases which is without any SPD and for that we should be able to fit to OCM. \n\nAnd OPTEE is not supported by Xilinx. There is a support for ZynqMP done by me and Soren long time ago but we are no longer maintaining it.",
      "parentUuid": "ac2ee4c5_798bfc3f",
      "revId": "e281761876a6a79dba82d664ecfcd7dd29c88ac3",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5881409a_958060e4",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000864
      },
      "writtenOn": "2022-08-01T14:02:46Z",
      "side": 1,
      "message": "Just to clarify. I am talking about SPD_opteed which does not embed actual OP-TEE OS in there.\n\nOP-TEE OS is stored in DDR as there was no space elsewhere for it.\n\nWith currently open OP-TEE PR about HUK support with USER eFuses OP-TEE for ZynqMP support is starting to be in quite good shape. We have been updating the support in recent years.\n\nNow there is TRNG support (from PL IP core), HUK with either PUF or with USER eFuses support that were the most important missing items.\n\nAll current xtest\u0027s passes too. Might be a good idea to check it out how it has evolved as OP-TEE seems to be getting some traction and being supported in quite many platforms. If you would like to get demonstration that could also be arranged.\n\n-----\n\nAbout PM operations I suppose you are talking about deep power saving modes where DDR is in self-refresh and cores are powered down and then waken up. In our use we are always powered up and there is no such need at the moment.\n\nDon\u0027t know if you could have necessary PM support code in ATF that would be present in OCM all the time. If it requires whole psu_init stuff then that gets a bit bloated.\n\n-----\n\nAbout OCM addresses from FSBL with a bit more symbols:\n\n00000000fffdd2a0 b Iv\n00000000fffdd2c0 B __bss_end__\n00000000fffdd2c0 B _heap\n00000000fffdd2c0 B HeapBase\n00000000fffdd2c0 B _heap_start\n00000000fffdd6c0 B _el3_stack_end\n00000000fffdd6c0 B _heap_end\n00000000fffdd6c0 B HeapLimit\n00000000fffdf6c0 B __dup_data_start\n00000000fffdf6c0 B __el0_stack\n00000000fffdf6c0 B __el1_stack\n00000000fffdf6c0 B __el2_stack\n00000000fffdf6c0 B __el3_stack\n00000000fffe0988 B __dup_data_end\n00000000fffe9e00 b $d\n00000000fffe9e00 b ATFHandoffParams\n00000000ffff0040 b $d\n00000000ffff0040 b ReadBuffer\n00000000ffffe040 b HashsOfChunks\n00000000fffffc40 B _end\n\nAnd the !DEBUG address was 0xfffea000.\n\nIf ATF handoff fits in 0x200 and ReadBuffer and HashsOfChunks would not be an issue then there would be some space there.\n\nI believe HashsOfChunks and ReadBuffer are related to loading bistream with secure boot:\n\nhttps://github.com/Xilinx/embeddedsw/blob/d37a0e8824182597abf31ac3f1087a5321b33ad7/lib/sw_apps/zynqmp_fsbl/src/xfsbl_partition_load.c#L144\n\nhttps://github.com/Xilinx/embeddedsw/blob/d37a0e8824182597abf31ac3f1087a5321b33ad7/lib/sw_apps/zynqmp_fsbl/src/xfsbl_bs.c#L51\n\nOnce bitstream has been handled then that memory should be free.\n\nIn our image we anyway load bitstream before ATF + OP-TEE as we have some IP cores that are utilized by OP-TEE. So in that kind of configuration that should not be a problem. (other than the ATF does not fit in that area in our case).\n\nTaking out 12k from FSBL might be a bit challenging. Haven\u0027t really studied if that could be even more trimmed down.\n\nYour idea of discarding part of the code like what kernel does might work thou.\n\nFrom practicality point of view I would perhaps do it so that FSBL is from start of OCM so that it never needs to be relocated anywhere. And then ATF would occupy the end. Then we could have in FSBL \"init\" section after those stacks which could be then discarded and that memory could then be re-used. Debugger might get a bit hairy at some point ;). I recall in linker options there was some overlay support for old banked memories so perhaps that mechanism could work.\n\nAs ATF handoff pointer was on PMU_GLOBAL_GEN_STORAGE6 so that could be relocated dynamically I suppose.\n\nDon\u0027t know if SPL would be any tighter fit in here? Can you shed some light on SPL details? In theory the same discardable psu_init section could work there too.\n\n\"late\" inits after PL has been loaded cloud be placed just before \"normal\" inits to scale a bit more during runtime. Or it might be just enough to draw line that PL is now done (or there was no PL bitstream at all) and now all previous sections can be discarded. But your mentioned PM problem might still be there. Don\u0027t know if we can have OCM PM wakeup section there as a separate.",
      "parentUuid": "6b40896c_405f034a",
      "revId": "e281761876a6a79dba82d664ecfcd7dd29c88ac3",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "16436314_7f7b4c10",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000469
      },
      "writtenOn": "2022-08-04T07:29:03Z",
      "side": 1,
      "message": "There are a lot of things in your post. Hopefully I won\u0027t miss any.\n\nSPD_opteed - Origin reason why we go to DDR was simply that CI loop was failing because\ncode was just bigger over years. At that time none invested time to change it. \nAnd CI loop never enabled any SPD for any OS.\n\nIn general enabling DEBUG is only for development purpose which means it doesn\u0027t matter\nif it is in OCM or DDR but intention was to get it back to OCM where it should be.\nAnd enabling any SPD is adding additional code and it depends on your system if you are able to fit \nto OCM or not. \n\nATFHnadoffParams have setup maximum size which is 192B. That means 0x200 (512B) should be more then enough for it. \n\nHere is code which we have in u-boot. \n\n#define FSBL_MAX_PARTITIONS             8\n\n/* Structure corresponding to each partition entry */\nstruct xfsbl_partition {\n        uint64_t entry_point;\n        uint64_t flags;\n};\n\n/* Structure for handoff parameters to ARM Trusted Firmware (ATF) */\nstruct xfsbl_atf_handoff_params {\n        uint8_t magic[4];\n        uint32_t num_entries;\n        struct xfsbl_partition partition[FSBL_MAX_PARTITIONS];\n};\n\nFSBL should be doing bitstream programming before loading other partitions from boot.bin\nthat\u0027s why that buffers at the end of OCM will be free to use when bitstream is loaded.\n\nDefinitely using init section can work also with SPL.",
      "parentUuid": "5881409a_958060e4",
      "revId": "e281761876a6a79dba82d664ecfcd7dd29c88ac3",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d5b6db80_11b1f74e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000469
      },
      "writtenOn": "2022-08-30T06:32:30Z",
      "side": 1,
      "message": "Are you going to continue on this patch or should we close it?",
      "parentUuid": "16436314_7f7b4c10",
      "revId": "e281761876a6a79dba82d664ecfcd7dd29c88ac3",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f7d9dd4a_d76d5688",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000864
      },
      "writtenOn": "2022-08-31T18:51:00Z",
      "side": 1,
      "message": "Hm... I am pretty sure I had replied this with some additional comments. Might be this gerrit UI that can be a bit confusing.\n\nLet me come back on the matter later this week.",
      "parentUuid": "d5b6db80_11b1f74e",
      "revId": "e281761876a6a79dba82d664ecfcd7dd29c88ac3",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "76606ed4_f23edd57",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000864
      },
      "writtenOn": "2022-09-03T16:38:14Z",
      "side": 1,
      "message": "Sorry for failing to submit the comment. So let\u0027s have a new take on it.\n\nI have studied the FSBL and ATF a bit more.\n\nThere seems to be warm reboot path in FSBL that seems to assume that OCM is kept with FSBL data and there is even a copy of \u0027.data\u0027 section that gets copied back into its normal place.\n\nIn addition to that I suppose the MMU tables need to stay there in place once MMU gets enabled. ATF seems to continue filling more details in here.\n\nIn special reboot cases it skips part of psu_init sequences so might be possibility to claim some space but I suppose this is something where Xilinx could help on SDK side so that matching psu_init\u0027s with segment configurations and support for FSBL would be in place for that. Before that happens I suppose we are stuck with current OCM memory layout.\n\nFSBL defines following layout (lscript.ld or lscript_a53.ld in newer FSBL):\n\npsu_ocm_ram_0_S_AXI_BASEADDR : ORIGIN \u003d 0xFFFC0000, LENGTH \u003d 0x00029E00\n- FSBL code and data\n-- Size of this depends highly on what features are enabled in FSBL (xfsbl_config.h)\n- MMU tables (shared) -- could possibly be located earlier in memory to enable more shrinking\n- Can\u0027t get rid of this due to warm start + DDR self-refresh features\n\npsu_ocm_ram_1_S_AXI_BASEADDR : ORIGIN \u003d 0xFFFE9E00, LENGTH \u003d 0x00000200\n- ATF handoff params\n\n--- in here we have ATF\u0027s loading address: 0xfffea000\n- Is right after ATF\u0027s handoff params section\n\npsu_ocm_ram_2_S_AXI_BASEADDR : ORIGIN \u003d 0xFFFF0040, LENGTH \u003d 0x0000FDC0\n- This collides with ATF but...\n- Here we have bitstream loading buffers so this area is free after that\n- There seems to be free space (0x200) left at end of the OCM memory?\n- And at the start (0x40)?\n\nNow to ATF side.\n\nTo get understanding what I was compiling with:\nmake -j 12 ZYNQMP_CONSOLE\u003dcadence ZYNQMP_ATF_MEM_SIZE\u003d0x16001 ZYNQMP_BL32_MEM_BASE\u003d0x60000000 ZYNQMP_BL32_MEM_SIZE\u003d0x80000 SPD\u003dopteed ZYNQMP_SECURE_EFUSES\u003d1\n\n; note there is no ZYNQMP_ATF_MEM_BASE defined as this is how meta-xilinx was defined at some point of time. Today there seems to be both with empty defaults. Which is more or less the same end result.\n; note2 there seems to be different BL32 address for provencore -- probably should send a patch to meta-xilinx to get op-tee also included in there now that most important bits are in OP-TEE\u0027s upstream.\n\nAs mentioned earlier and checked now also from bl31.map it needs 0x19000 bytes of RAM (after alignments):\n\n.text           0x0000000000001000     0xb000\n\n...\n\n                0x000000000001a000                . \u003d ALIGN (0x1000)\n *fill*         0x0000000000019070      0xf90 \n                0x000000000001a000                __COHERENT_RAM_END__ \u003d .\n\nWhich is a bit too much compared to 0x16000 that is allocated for OCM config. So we are 0x3000 short (a bit less due to *fill* was quite large).\n\nNow if we get back to original (annotated) code in here:\n\n/*\n * Put BL31 at the top of the Trusted SRAM (just below the shared memory, if\n * present). BL31_BASE is calculated using the current BL31 debug size plus a\n * little space for growth.\n */\n#ifndef ZYNQMP_ATF_MEM_BASE\n#if !DEBUG \u0026\u0026 defined(SPD_none) \u0026\u0026 !SDEI_SUPPORT\n# define BL31_BASE                      U(0xfffea000)\n# define BL31_LIMIT                     U(0x100000000)  // size \u003d\u003d 0x16000\n#else\n# define BL31_BASE                      U(0x1000)\n# define BL31_LIMIT                     U(0x7ffff)      // size \u003d\u003d 0x7EFFF\n#endif\n#else\n# define BL31_BASE                      (ZYNQMP_ATF_MEM_BASE)\n# define BL31_LIMIT                     (ZYNQMP_ATF_MEM_BASE + ZYNQMP_ATF_MEM_SIZE - 1)\n# ifdef ZYNQMP_ATF_MEM_PROGBITS_SIZE\n#  define BL31_PROGBITS_LIMIT           (ZYNQMP_ATF_MEM_BASE + ZYNQMP_ATF_MEM_PROGBITS_SIZE - 1)\n# endif\n#endif\n\nNow if we think about defines used in here \u0027ZYNQMP_ATF_MEM_BASE\u0027 could be used as a trigger for custom configuration as it is in here. So no need to change that I suppose.\n\nNow I suppose your use case was:\n#if !DEBUG \u0026\u0026 defined(SPD_none) \u0026\u0026 !SDEI_SUPPORT\n\nEg. no DEBUG and no SPD (don\u0027t know about SDEI_SUPPORT)?\n\nSo the original OCM location of 0xfffea000 should be OK?\n\nNow about the #else in there -- don\u0027t know if there are any good addresses. I suppose 0x0 is reserved for NULL reference catch fault handling thus the next page has been selected in here.\n\nYou mentioned address of 0xfffe5000 but that collides with FSBL\u0027s OCM memory layout. With that we would get 0x1B000 bytes free in OCM for ATF.\n\nThis would mean for FSBL\u0027s lscript.ld:\n\nMEMORY\n{\n   psu_ocm_ram_0_S_AXI_BASEADDR : ORIGIN \u003d 0xFFFC0000, LENGTH \u003d 0x00024E00\n   psu_ocm_ram_1_S_AXI_BASEADDR : ORIGIN \u003d 0xFFFE4E00, LENGTH \u003d 0x00000200\n   psu_ocm_ram_2_S_AXI_BASEADDR : ORIGIN \u003d 0xFFFE5040, LENGTH \u003d 0x0001ADC0\n}\n\nJust for fun -- applid patch for lscript.ld and compiled all of our FSBL variants (with Vitis 2021.2). Build succeeded. Did not have opportunity yet to test it out.\n\n$ aarch64-none-elf-nm -v fsbl-qspi.elf\n00000000fffdfdc0 B __dup_data_end\n00000000fffe4e00 b ATFHandoffParams\n\n$ aarch64-none-elf-nm -v fsbl-usb.elf\n00000000fffe09c8 B __dup_data_end\n00000000fffe4e00 b ATFHandoffParams\n\n$ aarch64-none-elf-nm -v fsbl-sd.elf\n00000000fffddba8 B __dup_data_end\n00000000fffe4e00 b ATFHandoffParams\n\nI don\u0027t think we can change the memory allocations in OCM unless both FSBL (xilinx) and U-Boot\u0027s SPL agree. I suppose you can affect both of these ;)\n\nCompiling FSBL already with some debug prints is a challenge of itself so there might be some grumpy people... We already need to compile it with different configurations for different boot mediums. Of course it reduces the available space for possible future changes/features.\n\nIn meanwhile to me the original configuration is good in sound. Thus I would apply the revert commit included in the PR to get back into working state.\n\nShould we be able to change the layout I suppose ATF\u0027s configuration should look like:\n\n#ifndef ZYNQMP_ATF_MEM_BASE\n# define BL31_BASE                      U(0xfffe5000)\n# define BL31_LIMIT                     U(0x100000000)\n#else\n# define BL31_BASE                      (ZYNQMP_ATF_MEM_BASE)\n# define BL31_LIMIT                     (ZYNQMP_ATF_MEM_BASE + ZYNQMP_ATF_MEM_SIZE - 1)\n# ifdef ZYNQMP_ATF_MEM_PROGBITS_SIZE\n#  define BL31_PROGBITS_LIMIT           (ZYNQMP_ATF_MEM_BASE + ZYNQMP_ATF_MEM_PROGBITS_SIZE - 1)\n# endif\n#endif\n\nor keeping DDR location visible with DEBUG build (or change that to other define):\n\n#ifndef ZYNQMP_ATF_MEM_BASE\n#if !DEBUG\n# define BL31_BASE                      U(0xfffe5000)\n# define BL31_LIMIT                     U(0x100000000)\n#else\n# define BL31_BASE                      U(0x1000)\n# define BL31_LIMIT                     U(0x7ffff)\n#endif\n#else\n# define BL31_BASE                      (ZYNQMP_ATF_MEM_BASE)\n# define BL31_LIMIT                     (ZYNQMP_ATF_MEM_BASE + ZYNQMP_ATF_MEM_SIZE - 1)\n# ifdef ZYNQMP_ATF_MEM_PROGBITS_SIZE\n#  define BL31_PROGBITS_LIMIT           (ZYNQMP_ATF_MEM_BASE + ZYNQMP_ATF_MEM_PROGBITS_SIZE - 1)\n# endif\n#endif\n\nWould you like to discuss with your FSBL team to agree the new layout?\n\nI suppose earliest change would be your 2022.2 release?\n\nI would also be interested to know what is on those free non-allocated spaces in OCM.",
      "parentUuid": "f7d9dd4a_d76d5688",
      "revId": "e281761876a6a79dba82d664ecfcd7dd29c88ac3",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8b61a794_3f06e9cd",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000469
      },
      "writtenOn": "2022-09-05T13:49:49Z",
      "side": 1,
      "message": "Xilinx should be using 0xfffea000 as default location for !DEBUG use case. Above you are using 0xfffe5000 for both cases and based on my experience I didn\u0027t see any issue with using this lower address for TF-A. \nI would like to avoid DDR location and suggest people where TF-A should be placed. If there is no choice I would use address at the end of 2GB range. Expectation is that none will really run system with just 1GB of memory. \n\nThere is no way how to aligned FSBL for 2022.2 release and I don\u0027t think they will be even open to change anything in their linker script. \n\nThat\u0027s why I would keep 0xfffea000 as default for !DEBUG and 0xfffe5000 for DEBUG.\nDefinitely fine if you want to add comment which suggest DDR location which could be used.",
      "parentUuid": "76606ed4_f23edd57",
      "revId": "e281761876a6a79dba82d664ecfcd7dd29c88ac3",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    }
  ]
}