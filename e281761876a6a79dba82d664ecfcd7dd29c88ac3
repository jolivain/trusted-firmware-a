{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "9667a67a_ac768f7e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000469
      },
      "writtenOn": "2022-08-01T09:07:16Z",
      "side": 1,
      "message": "Hm. You are definitely right but trying to understand why I select this address. It should be 0xfffe5000. Can you please instead of revert to DDR just fix that address to stay in OCM? ",
      "revId": "e281761876a6a79dba82d664ecfcd7dd29c88ac3",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ac2ee4c5_798bfc3f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000864
      },
      "writtenOn": "2022-08-01T11:02:46Z",
      "side": 1,
      "message": "I would love to keep both ATF and OP-TEE OS in OCM but unfortunately we have a bit of chicken egg problem in that and OCM is a bit small for that.\n\nI have tried to picture the boot flow in here:\nhttps://github.com/OP-TEE/optee_os/pull/5350#issuecomment-1200408103\n\n(Feel free to join the discussion to provide Xilinx/AMD view on things ðŸ˜Š)\n\nWhen ATF is compiled with OP-TEE support its memory usage is:\n\n$ nm -v deploy/arm-trusted-firmware.elf  | grep __BL31_\n0000000000001000 T __BL31_START__\n000000000001a000 B __BL31_END__\n\nWhich is 100 KiB.\n\nBut during the boot FSBL also occupies the OCM memory and that is the entity trying to load more stuff in memory.\n\nNow our FSBL build without PMUFW is about 114 KiB:\n\n-rw-r--r-- 2 vej vej   117448 heinÃ¤  29 23:01 boot-usb-0.18.0.unsigned.bin\n\nAnd if you observe source .elf for that:\n\n$ nm -v fsbl-usb.elf | grep -E \u0027 (_vector_table|_end)$\u0027\n00000000fffc0000 T _vector_table\n00000000fffffc40 B _end\n\nWhich more or less consumes the whole OCM.\n\nAnd it is not often a good idea to load next binary into the memory that would override running code.\n\nSo far only way that I have figured out to fix that issue would be to:\n\n- Make FSBL build for Cortex-R5/lock-step mode that gets initially executed from 0xFFFC0000 (OCM start) (ROM requirement)\n- Relocate code execution to R5\u0027s TCM memory (in lock-step mode we have 256 KiB there too)\n- Relocate interrupt vectors and such to TCM\n- Load next Xilinx Image container image containing:\n  - (verify \u0026 decrypt on the go)\n  - PMUFW (to PMU)\n  - Bitstream (to PL)\n  - ATF (to OCM)\n  - OP-TEE (to DDR)\n  - DTB (to DDR)\n  - U-Boot (to DDR)\n- Prepare ATF handoff in OCM(?)\n- Boot ATF from Cortex-A53#0\n- Move R5F to \"deep sleep\"\n- ATF: Shutdown R5F and make cleanups for memory\n- Continue the boot\n\nNow the problem with that is that the real Cortex-R5F image must be loaded after U-Boot has been started as R5F is reserved during the boot. And probably should be firewalled by ATF so that it cannot touch OCM or other Trust Zone protected memories.\n\nAnd then about the OP-TEE OS -- we are current at:\n-rw-r--r-- 2 vej vej  425240 heinÃ¤  29 22:29 tee_raw.bin\n\nWhich would not fit in OCM ðŸ˜¢.\n\nNow if we come back to the actual code (as previously):\n\n#ifndef ZYNQMP_ATF_MEM_BASE\n#if !DEBUG \u0026\u0026 defined(SPD_none) \u0026\u0026 !SDEI_SUPPORT\n# define BL31_BASE                      U(0xfffea000)\n# define BL31_LIMIT                     U(0x100000000)\n#else\n# define BL31_BASE                      U(0x1000)\n# define BL31_LIMIT                     U(0x7ffff)\n#endif\n#else\n# define BL31_BASE                      (ZYNQMP_ATF_MEM_BASE)\n# define BL31_LIMIT                     (ZYNQMP_ATF_MEM_BASE + ZYNQMP_ATF_MEM_SIZE - 1)\n# ifdef ZYNQMP_ATF_MEM_PROGBITS_SIZE\n#  define BL31_PROGBITS_LIMIT           (ZYNQMP_ATF_MEM_BASE + ZYNQMP_ATF_MEM_PROGBITS_SIZE - 1)\n# endif\n#endif\n\nNow if we would change the default address for OP-TEE enabled boot case (eg. SPD_none is not defined) then it would try to load ATF in OCM which would then override running FSBL which is not a good idea.\n\nI suppose this whole #ifdef structure would need to be thinked as a whole as there are different configurations and different allocations. To me that looks like if your ATF is small (\u003c 88 KiB) then we can try to put it on OCM assuming that FSBL would actually be is small enough (and would not use memory at ATF\u0027s point).\n\nEven if R5F boot flow would be in use (as described above) then I suppose that would need to be flagged somehow in ATF build so that one can use also A53 FSBL boot flow.\n\nAny thoughs?",
      "parentUuid": "9667a67a_ac768f7e",
      "revId": "e281761876a6a79dba82d664ecfcd7dd29c88ac3",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6b40896c_405f034a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000469
      },
      "writtenOn": "2022-08-01T11:53:06Z",
      "side": 1,
      "message": "No doubt that OCM size is limiting factor here. And we can\u0027t do much about it.\n\nThis year we optimize pinctrl implementation in TF-A to reduce size to make sure that we can stay within current footprint in near future. There are some other places which can be optimized to find some space but still this won\u0027t solve problem with adding SPD to TF-A binary. \n\nLet me comment your post but before I dig into it. BL31_BASE/LIMIT can be configured before building to fit any of use case. And the address which I wanted to setup is an address which works fine with U-Boot SPL (not sure why origin patch didn\u0027t have it). And intentional debug configuration is without any SPD which should be possible to fit to OCM. \n\nBefore I did try pinctrl optimization I was thinking about couple of changes in SPL or FSBL which is that both of these SW have some low level code (a lot of the part of psu_init...) which is called only once. It means there is a option with marking initial functions before loading another images as init code and then free this space for using for other SW. It means FSBL will load TF-A from OCM start. This could give you additional space for also including SPD to the image. \nThe only use case which won\u0027t are any PM related configuration where APU restart only requires to still have FSBL in OCM. \nIt means there are ways but depends on use case you need to solve.\nAlso as you write using TCM memory can be also consider if can be used or not. \n\nI am not FSBL developer but that base addr which is setup for !DEBUG case should never be used by fsbl. Last page is maybe used for something but that location which is used for some time should be without any issue. It means you should take a look at sections in elf file to see what it is loaded where. \n\nAnyway as I said these addresses are supposed to target default cases which is without any SPD and for that we should be able to fit to OCM. \n\nAnd OPTEE is not supported by Xilinx. There is a support for ZynqMP done by me and Soren long time ago but we are no longer maintaining it.",
      "parentUuid": "ac2ee4c5_798bfc3f",
      "revId": "e281761876a6a79dba82d664ecfcd7dd29c88ac3",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5881409a_958060e4",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000864
      },
      "writtenOn": "2022-08-01T14:02:46Z",
      "side": 1,
      "message": "Just to clarify. I am talking about SPD_opteed which does not embed actual OP-TEE OS in there.\n\nOP-TEE OS is stored in DDR as there was no space elsewhere for it.\n\nWith currently open OP-TEE PR about HUK support with USER eFuses OP-TEE for ZynqMP support is starting to be in quite good shape. We have been updating the support in recent years.\n\nNow there is TRNG support (from PL IP core), HUK with either PUF or with USER eFuses support that were the most important missing items.\n\nAll current xtest\u0027s passes too. Might be a good idea to check it out how it has evolved as OP-TEE seems to be getting some traction and being supported in quite many platforms. If you would like to get demonstration that could also be arranged.\n\n-----\n\nAbout PM operations I suppose you are talking about deep power saving modes where DDR is in self-refresh and cores are powered down and then waken up. In our use we are always powered up and there is no such need at the moment.\n\nDon\u0027t know if you could have necessary PM support code in ATF that would be present in OCM all the time. If it requires whole psu_init stuff then that gets a bit bloated.\n\n-----\n\nAbout OCM addresses from FSBL with a bit more symbols:\n\n00000000fffdd2a0 b Iv\n00000000fffdd2c0 B __bss_end__\n00000000fffdd2c0 B _heap\n00000000fffdd2c0 B HeapBase\n00000000fffdd2c0 B _heap_start\n00000000fffdd6c0 B _el3_stack_end\n00000000fffdd6c0 B _heap_end\n00000000fffdd6c0 B HeapLimit\n00000000fffdf6c0 B __dup_data_start\n00000000fffdf6c0 B __el0_stack\n00000000fffdf6c0 B __el1_stack\n00000000fffdf6c0 B __el2_stack\n00000000fffdf6c0 B __el3_stack\n00000000fffe0988 B __dup_data_end\n00000000fffe9e00 b $d\n00000000fffe9e00 b ATFHandoffParams\n00000000ffff0040 b $d\n00000000ffff0040 b ReadBuffer\n00000000ffffe040 b HashsOfChunks\n00000000fffffc40 B _end\n\nAnd the !DEBUG address was 0xfffea000.\n\nIf ATF handoff fits in 0x200 and ReadBuffer and HashsOfChunks would not be an issue then there would be some space there.\n\nI believe HashsOfChunks and ReadBuffer are related to loading bistream with secure boot:\n\nhttps://github.com/Xilinx/embeddedsw/blob/d37a0e8824182597abf31ac3f1087a5321b33ad7/lib/sw_apps/zynqmp_fsbl/src/xfsbl_partition_load.c#L144\n\nhttps://github.com/Xilinx/embeddedsw/blob/d37a0e8824182597abf31ac3f1087a5321b33ad7/lib/sw_apps/zynqmp_fsbl/src/xfsbl_bs.c#L51\n\nOnce bitstream has been handled then that memory should be free.\n\nIn our image we anyway load bitstream before ATF + OP-TEE as we have some IP cores that are utilized by OP-TEE. So in that kind of configuration that should not be a problem. (other than the ATF does not fit in that area in our case).\n\nTaking out 12k from FSBL might be a bit challenging. Haven\u0027t really studied if that could be even more trimmed down.\n\nYour idea of discarding part of the code like what kernel does might work thou.\n\nFrom practicality point of view I would perhaps do it so that FSBL is from start of OCM so that it never needs to be relocated anywhere. And then ATF would occupy the end. Then we could have in FSBL \"init\" section after those stacks which could be then discarded and that memory could then be re-used. Debugger might get a bit hairy at some point ;). I recall in linker options there was some overlay support for old banked memories so perhaps that mechanism could work.\n\nAs ATF handoff pointer was on PMU_GLOBAL_GEN_STORAGE6 so that could be relocated dynamically I suppose.\n\nDon\u0027t know if SPL would be any tighter fit in here? Can you shed some light on SPL details? In theory the same discardable psu_init section could work there too.\n\n\"late\" inits after PL has been loaded cloud be placed just before \"normal\" inits to scale a bit more during runtime. Or it might be just enough to draw line that PL is now done (or there was no PL bitstream at all) and now all previous sections can be discarded. But your mentioned PM problem might still be there. Don\u0027t know if we can have OCM PM wakeup section there as a separate.",
      "parentUuid": "6b40896c_405f034a",
      "revId": "e281761876a6a79dba82d664ecfcd7dd29c88ac3",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "16436314_7f7b4c10",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000469
      },
      "writtenOn": "2022-08-04T07:29:03Z",
      "side": 1,
      "message": "There are a lot of things in your post. Hopefully I won\u0027t miss any.\n\nSPD_opteed - Origin reason why we go to DDR was simply that CI loop was failing because\ncode was just bigger over years. At that time none invested time to change it. \nAnd CI loop never enabled any SPD for any OS.\n\nIn general enabling DEBUG is only for development purpose which means it doesn\u0027t matter\nif it is in OCM or DDR but intention was to get it back to OCM where it should be.\nAnd enabling any SPD is adding additional code and it depends on your system if you are able to fit \nto OCM or not. \n\nATFHnadoffParams have setup maximum size which is 192B. That means 0x200 (512B) should be more then enough for it. \n\nHere is code which we have in u-boot. \n\n#define FSBL_MAX_PARTITIONS             8\n\n/* Structure corresponding to each partition entry */\nstruct xfsbl_partition {\n        uint64_t entry_point;\n        uint64_t flags;\n};\n\n/* Structure for handoff parameters to ARM Trusted Firmware (ATF) */\nstruct xfsbl_atf_handoff_params {\n        uint8_t magic[4];\n        uint32_t num_entries;\n        struct xfsbl_partition partition[FSBL_MAX_PARTITIONS];\n};\n\nFSBL should be doing bitstream programming before loading other partitions from boot.bin\nthat\u0027s why that buffers at the end of OCM will be free to use when bitstream is loaded.\n\nDefinitely using init section can work also with SPL.",
      "parentUuid": "5881409a_958060e4",
      "revId": "e281761876a6a79dba82d664ecfcd7dd29c88ac3",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d5b6db80_11b1f74e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000469
      },
      "writtenOn": "2022-08-30T06:32:30Z",
      "side": 1,
      "message": "Are you going to continue on this patch or should we close it?",
      "parentUuid": "16436314_7f7b4c10",
      "revId": "e281761876a6a79dba82d664ecfcd7dd29c88ac3",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    }
  ]
}