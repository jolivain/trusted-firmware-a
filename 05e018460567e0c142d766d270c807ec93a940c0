{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "1a216757_8cbb870e",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 8,
      "author": {
        "id": 1000162
      },
      "writtenOn": "2021-06-07T20:20:56Z",
      "side": 1,
      "message": "Please add detailed information. e.g. what is the problem with today\u0027s code? how does thi patch fix the problem?",
      "revId": "05e018460567e0c142d766d270c807ec93a940c0",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8455f368_8525d57a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000655
      },
      "writtenOn": "2021-06-07T16:44:31Z",
      "side": 1,
      "message": "Our TEE, Kinibi, is used to receive the core linear ID in the x3 register of secondary cores.\nThis patch is necessary to bring up secondary cores with Kinibi as an SPMC in SEL1.\n\nIn Kinibi, the TEE is mostly platform-independent and all platform-specifics like topology is concentrated in ATF of our customers. That is why we don\u0027t have the MPIDR - linear ID mapping in Kinibi.\nWe need the correct linear ID to program the GICv2 target register, for example in power management case.",
      "revId": "05e018460567e0c142d766d270c807ec93a940c0",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b8a76560_c74f797e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000289
      },
      "writtenOn": "2021-06-07T18:51:44Z",
      "side": 1,
      "message": "Some questions inline.",
      "revId": "05e018460567e0c142d766d270c807ec93a940c0",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "372e7566_ecdad2a5",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000289
      },
      "writtenOn": "2021-06-07T18:51:44Z",
      "side": 1,
      "message": "Hi Lukas,\n\n\u003e Our TEE, Kinibi, is used to receive the core linear ID in the x3 register of secondary cores.\n\u003e This patch is necessary to bring up secondary cores with Kinibi as an SPMC in SEL1.\n\u003e \n\u003e In Kinibi, the TEE is mostly platform-independent and all platform-specifics like topology is concentrated in ATF of our customers. That is why we don\u0027t have the MPIDR - linear ID mapping in Kinibi.\n\u003e We need the correct linear ID to program the GICv2 target register, for example in power management case.\n\nI don\u0027t see an issue with the patch but could not help but think if the spec should describe a mechanism for passing the linear id. Some thoughts below to help me decide one way or the other. Could you please comment.\n\nThe mapping between an MPIDR and linear ID is not really platform dependent at least for the purpose of programming the GIC_ITARGETSR on both GICv2/v3. It could very well be a Kinibi specific mapping function as long as fn(mpidr) \u003d x such that 0 \u003c\u003d x \u003c\u003d 7. Using a linear ID calculated by TF-A is just more convenient.\n\nWhat I am trying to say is that for a given value of mpidr, it is possible that fn_tf-a(mpidr) \u003d x and fn_kinibi(mpidr) \u003d y such that x !\u003d y. This would not cause any issues since TF-A and Kinibi\u0027s respective mpidr to linear id mapping does not have to match. Do you agree with this claim?\n\nFurthermore, I am thinking if the need for TF-A to pass the linear id is specific to GICv2. On GICv3, can the Affinity value and Processor Number fields in the GICR_TYPER register be read to map an MPIDR to Linear id?\n\nI am also wondering if the same approach could be used when S-EL2 is enabled and a SP accesses the virtual GIC.\n\n@Olivier @Manish. I vaguely remember there was some issue in using the GICR_TYPER in this way. Do you see any?",
      "parentUuid": "8455f368_8525d57a",
      "revId": "05e018460567e0c142d766d270c807ec93a940c0",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "073d0a9c_43b5a323",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000228
      },
      "writtenOn": "2021-06-08T06:26:35Z",
      "side": 1,
      "message": "\u003e Patch Set 1: Validation-Bot-Review-1\n\u003e \n\u003e Build finished: 258 (https://qa-reports.linaro.org/tf/tf-gerrit-tforg-l2/build/258/)\n\u003e Some tests failed (4)\n\nSPM tests passed.\n\nFailures look to be test timeouts due to infrastructure.\n",
      "revId": "05e018460567e0c142d766d270c807ec93a940c0",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "dc0b109c_efde6bba",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000228
      },
      "writtenOn": "2021-06-08T07:46:48Z",
      "side": 1,
      "message": "@Lukas can you move the rationale in this comment to the commit message to give some background.\n\n@Achin few comments below:\n\n\u003e it is possible that fn_tf-a(mpidr) \u003d x and fn_kinibi(mpidr) \u003d y such that x !\u003d y\nThis might be theoretically possible, but I still have the feeling this doesn\u0027t look absolutely correct that the TEE/SPMC does not use the same mapping as the other system ingredients (OS kernel, TF-A etc.). To be checked further if it flies with any chipset implementation.\n\n\u003e I am thinking if the need for TF-A to pass the linear id \nI think the most important aspect is that a TEE/SPMC needs to figure out the core linear id very early so to setup a core-local stack. In general the early boot kernel head snippets run in a limited/constrained environment (possibly MMU off, no access to the whole TEE memory map etc.). With Hafnium we have a tricky extraction of the linear id from the cpu structs that are populated by the SPMC manifest parsing. But not all SPMC solutions have this processor topology information available. And an MPIDR to linear id conversion macro is highly chipset specific, not flying well with the desire for a generic code base/image.\n\n\u003e On GICv3, can the Affinity value and Processor Number fields in the GICR_TYPER register be read to map an MPIDR to Linear id?\nI did few experiments with the FVP and indeed it can be a path forward. The only hurdle is for the secondary core code path to figure out the running core GICR base address (again without a stack yet ready). Although not fully scalable when the system is GICv2 based.\n\n\u003e I am also wondering if the same approach could be used when S-EL2 is enabled and a SP accesses the virtual GIC.\nThe re-distributor might not accessible by a SP unless emulated (which doesn\u0027t look to be PoR at the moment). The virtual CPU interface does not expose the processor information AFAIK. With S-EL2 an SP reads the MPIDR as the virtual value exposed through VMPIDR. With Hafnium this value is the core linear id so it might be an easy solution when S-EL2/Hafnium is used.",
      "parentUuid": "372e7566_ecdad2a5",
      "revId": "05e018460567e0c142d766d270c807ec93a940c0",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cc421bda_7de9e355",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000655
      },
      "writtenOn": "2021-06-08T08:02:27Z",
      "side": 1,
      "message": "@Achin\nI agree, on GICv3 and GICv4 it is not needed. We use a fixed mapping from MPIDR to ICDIPTR/GICD_ITARGETSRn register.\nIn our code, it is only for GICv2, where we use the linear_id value from TF-A.\n\nFor debug and power management purpose, we also want a unified view to linear_id between Linux and the TEE. E.g. to disable a core, to see what cores are printing a trace / an event.\n\nIn the past, Kinibi had several other designs, but the complexity was getting out of control:\n* Platform-specific assembler macros in the kernel.\n* Then later, a per core SMC from Linux to tell the linear ID after the boot.\n* Also, not the forget DynamiQ and the ability to play with MPIDR register values, them not being fixed or unique.",
      "parentUuid": "dc0b109c_efde6bba",
      "revId": "05e018460567e0c142d766d270c807ec93a940c0",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "32281141_eeec192d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000289
      },
      "writtenOn": "2021-06-10T19:39:03Z",
      "side": 1,
      "message": "\u003e @Achin\n\u003e I agree, on GICv3 and GICv4 it is not needed. We use a fixed mapping from MPIDR to ICDIPTR/GICD_ITARGETSRn register.\n\u003e In our code, it is only for GICv2, where we use the linear_id value from TF-A.\n\u003e \n\u003e For debug and power management purpose, we also want a unified view to linear_id between Linux and the TEE. E.g. to disable a core, to see what cores are printing a trace / an event.\n\u003e \n\u003e In the past, Kinibi had several other designs, but the complexity was getting out of control:\n\u003e * Platform-specific assembler macros in the kernel.\n\u003e * Then later, a per core SMC from Linux to tell the linear ID after the boot.\n\u003e * Also, not the forget DynamiQ and the ability to play with MPIDR register values, them not being fixed or unique.\n\nI guess using the SMC is the only reliable way to obtain a MPIDR to linear ID mapping from Linux. Else we would have to assume that Linux uses the same hash function as TF-A or Kinibi so each will have exactly the same mapping.\n\n@Olivier. Some thoughts.\n\nI realise that today the linear id is calculated in a platform specific manner on almost all SoCs. There is a platform function for this in TF-A. I am asking whether it needs to be calculated in this way in future i.e. what would stop working if TF-A and TEE do not have the same mpidr to linear id mapping. \n\nI also realise that it is easy for the TOS to receive the linear id from TF-A instead of accessing a mapping table in assembler but this is not a gating issue. But is that the only reason?\n\nTF-A needs a platform specific hash function since all cpus could be released from reset at the same time and the complexity of synchronising accesses to the mapping table with MMU turned off (no exclusive monitor possibly) would be huge. \n\nHowever, a TEE would not suffer from the same problem as long as the OS calls PSCI CPU_ON on each secondary core serially instead of allowing multiple secondaries to boot up concurrently. \n\nSince TEEs are making changes to adopt FF-A, I see a choice between using a truly platform independent mechanism vs using the linear id calculated by TF-A.\n\nIf things cannot work without the linear id calculated by TF-A, then passing it to a TEE is trivial as demonstrated by this patch. I am more concerned about the definition of a linear id. Is it a number x such that 0 \u003c\u003d x \u003c NUM_CPUS? Is it guaranteed that the MPIDR to linear id mapping will not change until the next cold reset? Is this linear id related to a similar id being used in the Normal world? IIUC, these could easily be different today.\n\nThis might seem obvious but it is worth capturing in the documentation so that a strict contract is defined. What do you reckon?\n\nOn the topic of using the VMPIDR register to carry the linear id...\n\nThis would indeed be a simple solution as we have discussed before. But I am thinking that a SP would have to know whether it is virtualized or not to determine whether it can use the MPIDR directly or it should continue relying on the passed linear id. Is this desirable? In any case, the contract would need to be defined between the SPMC and a SP such that the latter can rely on it irrespective of the SPMC implementation.\n\nI am leaning towards not making any spec changes for now. Please let me know if this sounds reasonable to you. If the contracts are defined in Hafnium and TF-A documentation, they can be retrospectively added to the FF-A spec in future if the need arises.\n\nLastly, I think it would be safer to pick a register outside w0-w7. The boot protocol information from a SPMC to SP could be passed in any register between w0-w3. The cold boot reason could be specified in any register between w0-w7. This is specified in the manifest. The FF-A spec was not sure that it could simply choose registers in these ranges and this would not break some TEE. So choosing a register outside these ranges would be better to avoid a clash with the manifest.",
      "parentUuid": "cc421bda_7de9e355",
      "revId": "05e018460567e0c142d766d270c807ec93a940c0",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c42f973d_ea42decc",
        "filename": "services/std_svc/spmd/spmd_pm.c",
        "patchSetId": 1
      },
      "lineNbr": 101,
      "author": {
        "id": 1000228
      },
      "writtenOn": "2021-06-08T07:46:48Z",
      "side": 1,
      "message": "nit: can you add a brief comment here explaining what it does?",
      "revId": "05e018460567e0c142d766d270c807ec93a940c0",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    }
  ]
}