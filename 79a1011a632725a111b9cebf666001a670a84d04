{
  "comments": [
    {
      "key": {
        "uuid": "088afdc8_aabf0240",
        "filename": "drivers/arm/gic/v3/gicv3_helpers.c",
        "patchSetId": 4
      },
      "lineNbr": 349,
      "author": {
        "id": 1000162
      },
      "writtenOn": "2020-09-25T20:55:48Z",
      "side": 1,
      "message": "@Andre, for Tegra, the policy is a bit different. For \"missing\" CPU cores, there will be holes in the GICR region.",
      "range": {
        "startLine": 343,
        "startChar": 0,
        "endLine": 349,
        "endChar": 2
      },
      "revId": "79a1011a632725a111b9cebf666001a670a84d04",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "09b4937c_fab6d6d5",
        "filename": "drivers/arm/gic/v3/gicv3_helpers.c",
        "patchSetId": 4
      },
      "lineNbr": 349,
      "author": {
        "id": 1000118
      },
      "writtenOn": "2020-09-25T22:23:22Z",
      "side": 1,
      "message": "Holes as in \"SErrors on access\", or behaving as RAZ/WI? Or just doing nothing?\nAnd would that work Linux\u0027 gic_iterate_rdists() in drivers/irqchip/irq-gic-v3.c? Each core goes through the whole region until it finds its own MPIDR there.\n\nI would guess that the GICR is separate from the actual cores, so there is little reason to make those registers fault? And as mentioned, it\u0027s fine to have GICR frames which don\u0027t match any MPIDR in the system.",
      "parentUuid": "088afdc8_aabf0240",
      "range": {
        "startLine": 343,
        "startChar": 0,
        "endLine": 349,
        "endChar": 2
      },
      "revId": "79a1011a632725a111b9cebf666001a670a84d04",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1f2c64bc_45554e43",
        "filename": "drivers/arm/gic/v3/gicv3_helpers.c",
        "patchSetId": 4
      },
      "lineNbr": 349,
      "author": {
        "id": 1000162
      },
      "writtenOn": "2020-09-25T22:38:55Z",
      "side": 1,
      "message": "My understanding is that the register accesses wont cause SErrors. So although a TYPER read would still pass, the GICR would be disabled - set GICR_CTLR[DPG1S], GICR_CTLR[DPG1NS], and GICR_CTLR[DPG0] to 1.\n\nIIUC, with the current logic in this patch, you will always return PLATFORM_CORE_COUNT for such cases.",
      "parentUuid": "09b4937c_fab6d6d5",
      "range": {
        "startLine": 343,
        "startChar": 0,
        "endLine": 349,
        "endChar": 2
      },
      "revId": "79a1011a632725a111b9cebf666001a670a84d04",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ce357c61_dcd960e5",
        "filename": "drivers/arm/gic/v3/gicv3_helpers.c",
        "patchSetId": 4
      },
      "lineNbr": 349,
      "author": {
        "id": 1000118
      },
      "writtenOn": "2020-09-25T23:02:45Z",
      "side": 1,
      "message": "Well, yes, but as mentioned this is not a function to count the number of *active cores in the system*, but solely to determine how many cores the GIC redistributor interface supports.\nThat\u0027s basically to learn the number of cores that was configured during the GIC integration into the SoC.\nHence the gicv3_rdistif prefix for the function name and the comment on top.\nNot sure what else I could do to not disappoint any users?\n\nOriginally I thought about just using the number of cores that have shown up in BL31, but using that to size the GICR region would potentially omit redistributors, in case not all potential cores actually come up. Hence the idea to count what actually matters: the number of cores the GIC knows about.\n\nWhat about we address and fix this later when we see an actual problem? Happy to find a different solution then, to cover a specific problem. For now this is aimed for emulation systems like FPGAs, QEMU or the FVP, where the number of cores is widely variable.",
      "parentUuid": "1f2c64bc_45554e43",
      "range": {
        "startLine": 343,
        "startChar": 0,
        "endLine": 349,
        "endChar": 2
      },
      "revId": "79a1011a632725a111b9cebf666001a670a84d04",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    }
  ]
}