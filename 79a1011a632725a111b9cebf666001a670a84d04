{
  "comments": [
    {
      "key": {
        "uuid": "088afdc8_aabf0240",
        "filename": "drivers/arm/gic/v3/gicv3_helpers.c",
        "patchSetId": 4
      },
      "lineNbr": 349,
      "author": {
        "id": 1000162
      },
      "writtenOn": "2020-09-25T20:55:48Z",
      "side": 1,
      "message": "@Andre, for Tegra, the policy is a bit different. For \"missing\" CPU cores, there will be holes in the GICR region.",
      "range": {
        "startLine": 343,
        "startChar": 0,
        "endLine": 349,
        "endChar": 2
      },
      "revId": "79a1011a632725a111b9cebf666001a670a84d04",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "09b4937c_fab6d6d5",
        "filename": "drivers/arm/gic/v3/gicv3_helpers.c",
        "patchSetId": 4
      },
      "lineNbr": 349,
      "author": {
        "id": 1000118
      },
      "writtenOn": "2020-09-25T22:23:22Z",
      "side": 1,
      "message": "Holes as in \"SErrors on access\", or behaving as RAZ/WI? Or just doing nothing?\nAnd would that work Linux\u0027 gic_iterate_rdists() in drivers/irqchip/irq-gic-v3.c? Each core goes through the whole region until it finds its own MPIDR there.\n\nI would guess that the GICR is separate from the actual cores, so there is little reason to make those registers fault? And as mentioned, it\u0027s fine to have GICR frames which don\u0027t match any MPIDR in the system.",
      "parentUuid": "088afdc8_aabf0240",
      "range": {
        "startLine": 343,
        "startChar": 0,
        "endLine": 349,
        "endChar": 2
      },
      "revId": "79a1011a632725a111b9cebf666001a670a84d04",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1f2c64bc_45554e43",
        "filename": "drivers/arm/gic/v3/gicv3_helpers.c",
        "patchSetId": 4
      },
      "lineNbr": 349,
      "author": {
        "id": 1000162
      },
      "writtenOn": "2020-09-25T22:38:55Z",
      "side": 1,
      "message": "My understanding is that the register accesses wont cause SErrors. So although a TYPER read would still pass, the GICR would be disabled - set GICR_CTLR[DPG1S], GICR_CTLR[DPG1NS], and GICR_CTLR[DPG0] to 1.\n\nIIUC, with the current logic in this patch, you will always return PLATFORM_CORE_COUNT for such cases.",
      "parentUuid": "09b4937c_fab6d6d5",
      "range": {
        "startLine": 343,
        "startChar": 0,
        "endLine": 349,
        "endChar": 2
      },
      "revId": "79a1011a632725a111b9cebf666001a670a84d04",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ce357c61_dcd960e5",
        "filename": "drivers/arm/gic/v3/gicv3_helpers.c",
        "patchSetId": 4
      },
      "lineNbr": 349,
      "author": {
        "id": 1000118
      },
      "writtenOn": "2020-09-25T23:02:45Z",
      "side": 1,
      "message": "Well, yes, but as mentioned this is not a function to count the number of *active cores in the system*, but solely to determine how many cores the GIC redistributor interface supports.\nThat\u0027s basically to learn the number of cores that was configured during the GIC integration into the SoC.\nHence the gicv3_rdistif prefix for the function name and the comment on top.\nNot sure what else I could do to not disappoint any users?\n\nOriginally I thought about just using the number of cores that have shown up in BL31, but using that to size the GICR region would potentially omit redistributors, in case not all potential cores actually come up. Hence the idea to count what actually matters: the number of cores the GIC knows about.\n\nWhat about we address and fix this later when we see an actual problem? Happy to find a different solution then, to cover a specific problem. For now this is aimed for emulation systems like FPGAs, QEMU or the FVP, where the number of cores is widely variable.",
      "parentUuid": "1f2c64bc_45554e43",
      "range": {
        "startLine": 343,
        "startChar": 0,
        "endLine": 349,
        "endChar": 2
      },
      "revId": "79a1011a632725a111b9cebf666001a670a84d04",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "81ada1ad_44fede65",
        "filename": "drivers/arm/gic/v3/gicv3_helpers.c",
        "patchSetId": 4
      },
      "lineNbr": 349,
      "author": {
        "id": 1000162
      },
      "writtenOn": "2020-09-26T01:25:35Z",
      "side": 1,
      "message": "Yes, we can move ahead with the patch. I have some suggestions though. Can we remove PLATFORM_CORE_COUNT usage and scan from GICR region start to end?\n\nDo you see any problem with this approach? This modification will cover both platforms. Since this code resides in a common location, it would be odd to only design it for one platform.\n\nAnother approach would be to move this to the platform instead.",
      "parentUuid": "ce357c61_dcd960e5",
      "range": {
        "startLine": 343,
        "startChar": 0,
        "endLine": 349,
        "endChar": 2
      },
      "revId": "79a1011a632725a111b9cebf666001a670a84d04",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8922be4a_f80031e2",
        "filename": "drivers/arm/gic/v3/gicv3_helpers.c",
        "patchSetId": 4
      },
      "lineNbr": 349,
      "author": {
        "id": 1000118
      },
      "writtenOn": "2020-09-26T10:08:58Z",
      "side": 1,
      "message": "So my first impulse was to use the GICR region size as the limit, but this is exactly what I don\u0027t know! For the FPGAs, the entry in the DT is a dummy, if you like. So I use this function to learn that limit. PLATFORM_CORE_COUNT is just a failsafe mechanism to prevent an infinite loop.\n\nAnd yes, originally I wanted to put it in the platform code, but then figured there is exactly nothing platform specific about it. Plus, all the constants are defined in the driver include file only, which I would either need to duplicate or include from platform code.\n\nIn fact, most of the code was copied from above: check gicv3_rdistif_base_addrs_probe(). Actually there is no limit there, and to me it looks the very same limitations already apply to that function.\n\nI could add a warning that platforms calling this function should check for its eligibility first, but I would assume that people do this anyway - and the same would be true for that other function.",
      "parentUuid": "81ada1ad_44fede65",
      "range": {
        "startLine": 343,
        "startChar": 0,
        "endLine": 349,
        "endChar": 2
      },
      "revId": "79a1011a632725a111b9cebf666001a670a84d04",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ab691ed8_2cc4bd76",
        "filename": "drivers/arm/gic/v3/gicv3_helpers.c",
        "patchSetId": 4
      },
      "lineNbr": 349,
      "author": {
        "id": 1000162
      },
      "writtenOn": "2020-09-28T19:56:53Z",
      "side": 1,
      "message": "Common code should be general purpose and work across all platforms. But I am struggling to convince myself that this is really platform agnostic.\n\nBut, I agree with your reasoning and think that we can get this code in. One question - Can we rename the function to gicv3_rdistif_get_number_frames() to make the intention clear?",
      "parentUuid": "8922be4a_f80031e2",
      "range": {
        "startLine": 343,
        "startChar": 0,
        "endLine": 349,
        "endChar": 2
      },
      "revId": "79a1011a632725a111b9cebf666001a670a84d04",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "867e5bcc_c97762a3",
        "filename": "drivers/arm/gic/v3/gicv3_helpers.c",
        "patchSetId": 4
      },
      "lineNbr": 349,
      "author": {
        "id": 1000118
      },
      "writtenOn": "2020-09-29T12:37:18Z",
      "side": 1,
      "message": "I changed the function name and amended the comment to explain what\u0027s going on and what the limitations are.",
      "parentUuid": "ab691ed8_2cc4bd76",
      "range": {
        "startLine": 343,
        "startChar": 0,
        "endLine": 349,
        "endChar": 2
      },
      "revId": "79a1011a632725a111b9cebf666001a670a84d04",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    }
  ]
}