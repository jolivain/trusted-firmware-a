{
  "comments": [
    {
      "key": {
        "uuid": "0d4f011e_7b9e1628",
        "filename": "include/common/bl_common.ld.h",
        "patchSetId": 6
      },
      "lineNbr": 106,
      "author": {
        "id": 1000043
      },
      "writtenOn": "2020-04-27T08:45:07Z",
      "side": 1,
      "message": "We need to update this comment, as it will now be aligned on 4 bytes on AArch32.\n\nThat got me thinking about AArch32 PIE firmware images. The TF-A doc [1] says that ENABLE_PIE is supported on a few images only: BL2_AT_EL3, BL31 and BL32 (TSP). Amongst these, BL31 and TSP are not used on AArch32. So the only PIE firmware image we can build for AArch32 would be BL2_AT_EL3.\n\nAs a quick experiment, I tried to build an AArch32 BL2_AT_EL3 with ENABLE_PIE with this patch and it seems to build and run fine. I am not 100% sure my test environment is correct, though, as unfortunately the CI appears to have no test coverage for PIE testing whatsoever so I do not have a reference test environment...\n\nWhat kind of testing did you do for this patch? I just want to make sure we are confident about the effect of this patch before we merge it.\n\n[1] https://trustedfirmware-a.readthedocs.io/en/latest/getting_started/build-options.html",
      "range": {
        "startLine": 106,
        "startChar": 27,
        "endLine": 106,
        "endChar": 50
      },
      "revId": "75a42aa3171041fa155782492d2c1a3fb3fab3ad",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ca6bca51_6e215b09",
        "filename": "include/common/bl_common.ld.h",
        "patchSetId": 6
      },
      "lineNbr": 106,
      "author": {
        "id": 1000173
      },
      "writtenOn": "2020-05-07T11:52:26Z",
      "side": 1,
      "message": "I use my board (some evaluation boards for Socionext UniPhier SoC family).\nI do only boot test.\nThe run-time address is different from the link address.\nSo, booting the system proves the relocation has worked.\n\n\nI just wanted to ask the same question.\nHow does Arm test ENABLE_PIE? (or did Arm test it before?)\n\nWhen I tried ENABLE_PIE, it did not work at all.\n\nSo, I needed to commit 511046eaa28f89d0ae1d8577bc940ad02d129f19\nand some more to make it work.",
      "parentUuid": "0d4f011e_7b9e1628",
      "range": {
        "startLine": 106,
        "startChar": 27,
        "endLine": 106,
        "endChar": 50
      },
      "revId": "75a42aa3171041fa155782492d2c1a3fb3fab3ad",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d3232ec2_060cd3f8",
        "filename": "include/common/bl_common.ld.h",
        "patchSetId": 6
      },
      "lineNbr": 106,
      "author": {
        "id": 1000043
      },
      "writtenOn": "2020-05-11T09:48:28Z",
      "side": 1,
      "message": "\u003e I use my board (some evaluation boards for Socionext UniPhier SoC family).\n\u003e I do only boot test.\n\u003e The run-time address is different from the link address.\n\u003e So, booting the system proves the relocation has worked.\n\nOk thanks for the details, this seems good enough of a test to me.\n\n\u003e I just wanted to ask the same question.\n\u003e How does Arm test ENABLE_PIE? (or did Arm test it before?)\n\nI\u0027ve talked further with some team members and learnt that PIE is enabled when RESET_TO_BL31\u003d1 on Arm platforms (see [1]). So I stand corrected, we do have some PIE testing in the CI today, although it would be good to extend this to other configurations and firmware images as well.\n\nMoreover, I am convinced that the engineer who added the original PIE support in TF-A tested it manually at the time it was developed but I don\u0027t know the details of that.\n\n[1] https://git.trustedfirmware.org/TF-A/trusted-firmware-a.git/tree/plat/arm/common/arm_common.mk#n150 \n\n\u003e When I tried ENABLE_PIE, it did not work at all.\n\u003e \n\u003e So, I needed to commit 511046eaa28f89d0ae1d8577bc940ad02d129f19\n\u003e and some more to make it work.\n\nI\u0027ve just tried to revert commit 511046eaa28f89d0ae1d8577bc940ad02d129f19 and compiled BL31 with RESET_TO_BL31\u003d1 on Arm FVP platform, to see whether I would observe the same issue as you but I don\u0027t: no section is inserted before .text.\n\nI suspect we might not be using the same toolchain version, which could result in sections layouts differences I guess. I am using the GCC version indicated in the TF-A doc at [2], i.e.:\n\n $ aarch64-none-elf-gcc --version\n aarch64-none-elf-gcc (GNU Toolchain for the A-profile Architecture 9.2-2019.12 (arm-9.10)) 9.2.1 20191025\n\n[2] https://trustedfirmware-a.readthedocs.io/en/latest/getting_started/prerequisites.html#toolchain",
      "parentUuid": "ca6bca51_6e215b09",
      "range": {
        "startLine": 106,
        "startChar": 27,
        "endLine": 106,
        "endChar": 50
      },
      "revId": "75a42aa3171041fa155782492d2c1a3fb3fab3ad",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "13916681_898d2076",
        "filename": "include/common/bl_common.ld.h",
        "patchSetId": 6
      },
      "lineNbr": 106,
      "author": {
        "id": 1000173
      },
      "writtenOn": "2020-06-29T06:50:26Z",
      "side": 1,
      "message": "\u003e We need to update this comment, as it will now be aligned on 4 bytes on AArch32.\n\nOK. I will remove this comment.\n\n\u003e I suspect we might not be using the same toolchain version, which could result in sections layouts differences I guess. I am using the GCC version indicated in the TF-A doc at [2], i.e.:\n\n\nI do not think so.\nI compiled 511046eaa^ with the toolchain you suggested,\nI still get .dynsym and .dynstr at the head of BL31.\n\n$ git checkout 511046eaa^\n$ make PLAT\u003duniphier CROSS_COMPILE\u003daarch64-none-elf- ENABLE_PIE\u003d1 bl31",
      "parentUuid": "d3232ec2_060cd3f8",
      "range": {
        "startLine": 106,
        "startChar": 27,
        "endLine": 106,
        "endChar": 50
      },
      "revId": "75a42aa3171041fa155782492d2c1a3fb3fab3ad",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "96d819ea_8b9f5676",
        "filename": "include/common/bl_common.ld.h",
        "patchSetId": 6
      },
      "lineNbr": 106,
      "author": {
        "id": 1000043
      },
      "writtenOn": "2020-06-29T08:49:19Z",
      "side": 1,
      "message": "\u003e I do not think so.\n\u003e I compiled 511046eaa^ with the toolchain you suggested,\n\u003e I still get .dynsym and .dynstr at the head of BL31.\n\u003e \n\u003e $ git checkout 511046eaa^\n\u003e $ make PLAT\u003duniphier CROSS_COMPILE\u003daarch64-none-elf- ENABLE_PIE\u003d1 bl31\n\nRight, this seems to happen only when SEPARATE_CODE_AND_RODATA\u003d0, which is the case on the Uniphier platform, contrarily to the FVP platform I was looking at.\n\nNot sure why this makes a difference. I suspect this just changes the sections layout and as we let the freedom to the linker to place the .dynsym and .dynstr sections wherever it wants, it just chooses to put it before the .text section for the uniphier platform.",
      "parentUuid": "13916681_898d2076",
      "range": {
        "startLine": 106,
        "startChar": 27,
        "endLine": 106,
        "endChar": 50
      },
      "revId": "75a42aa3171041fa155782492d2c1a3fb3fab3ad",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "69109df4_e31b80fb",
        "filename": "include/common/bl_common.ld.h",
        "patchSetId": 6
      },
      "lineNbr": 112,
      "author": {
        "id": 1000043
      },
      "writtenOn": "2020-04-27T08:45:07Z",
      "side": 1,
      "message": "This is new AFAICS. What\u0027s the reason for including specific input section names instead of keeping the code as it was before this patch?",
      "range": {
        "startLine": 112,
        "startChar": 2,
        "endLine": 112,
        "endChar": 11
      },
      "revId": "75a42aa3171041fa155782492d2c1a3fb3fab3ad",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4361966f_240b36df",
        "filename": "include/common/bl_common.ld.h",
        "patchSetId": 6
      },
      "lineNbr": 112,
      "author": {
        "id": 1000173
      },
      "writtenOn": "2020-05-07T11:52:26Z",
      "side": 1,
      "message": "If I wrote as follows, both\n__RELA_START__ and __RELA_END__\npoint to the beginning of the .rela.dyn section.\n\n.rela.dyn : ALIGN(STRUCT_ALIGN) {\t\t\\\n        __RELA_START__ \u003d .;\t\t\t\\\n        __RELA_END__ \u003d .;\t\t\t\\\n}\n\n\nIf I get __RELA_END__ out of the section,\nI cannot do \u0027RELA_SECTION \u003eRAM\u0027.\n\n\nThis kind of restriction comes from the TF-A\nlinker style using \u0027 SOME_SECTION \u003e RAM\u0027 form.",
      "parentUuid": "69109df4_e31b80fb",
      "range": {
        "startLine": 112,
        "startChar": 2,
        "endLine": 112,
        "endChar": 11
      },
      "revId": "75a42aa3171041fa155782492d2c1a3fb3fab3ad",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a1c074a7_c219dfa2",
        "filename": "include/common/bl_common.ld.h",
        "patchSetId": 6
      },
      "lineNbr": 112,
      "author": {
        "id": 1000043
      },
      "writtenOn": "2020-05-11T09:48:28Z",
      "side": 1,
      "message": "I think we might be talking about 2 different things here.\n\nAs you know, the existing linker scripts use the following pattern:\n\n    . \u003d ALIGN(8);\n    __RELA_START__ \u003d .;\n    .rela.dyn . : {\n    } \u003eRAM\n    __RELA_END__ \u003d .;\n\nI now realize they are defining the __RELA_START/END__ symbols *outside* of the section, which is what you pointed out in your answer. Understood, I am OK with this change. So with this change, this would become:\n\n    .rela.dyn : ALIGN(8) {\n        __RELA_START__ \u003d .;\n        __RELA_END__ \u003d .;\n    } \u003eRAM\n\nThis still specifies no input section to pull into section .rela.dyn. Instead I think you\u0027re proposing in this patch:\n\n    .rela.dyn : ALIGN(8) {\n        __RELA_START__ \u003d .;\n        *(.rela*)\n        __RELA_END__ \u003d .;\n    } \u003eRAM\n\nMy original question was around line 112 specifically. I am wondering why it was OK to specify no input section before, and now we\u0027re specifying *(.rela*) explicitly.",
      "parentUuid": "4361966f_240b36df",
      "range": {
        "startLine": 112,
        "startChar": 2,
        "endLine": 112,
        "endChar": 11
      },
      "revId": "75a42aa3171041fa155782492d2c1a3fb3fab3ad",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2e2593f9_e1cac95e",
        "filename": "include/common/bl_common.ld.h",
        "patchSetId": 6
      },
      "lineNbr": 112,
      "author": {
        "id": 1000173
      },
      "writtenOn": "2020-06-29T06:50:26Z",
      "side": 1,
      "message": "I really do not know why it was working without the explicit input section.\n\n.rela.dyn : ALIGN(8) {\n        __RELA_START__ \u003d .;\n        __RELA_END__ \u003d .;\n} \u003eRAM\n\nObviously, this does not work since __RELA_START__ and __RELA_END__\nare set to the same address.\n\nSo, we need to have *(.rela*) between them.\n\nAnd, I think it is natural to specify the input section.\nFor example, see the linker script of Linux kernel:\nhttps://github.com/torvalds/linux/blob/v5.7/arch/arm64/kernel/vmlinux.lds.S#L205",
      "parentUuid": "a1c074a7_c219dfa2",
      "range": {
        "startLine": 112,
        "startChar": 2,
        "endLine": 112,
        "endChar": 11
      },
      "revId": "75a42aa3171041fa155782492d2c1a3fb3fab3ad",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "677e8e4e_f000efd0",
        "filename": "include/common/bl_common.ld.h",
        "patchSetId": 6
      },
      "lineNbr": 112,
      "author": {
        "id": 1000043
      },
      "writtenOn": "2020-06-29T08:49:19Z",
      "side": 1,
      "message": "\u003e I really do not know why it was working without the explicit input section.\n\nMe neither...\n\n\u003e .rela.dyn : ALIGN(8) {\n\u003e         __RELA_START__ \u003d .;\n\u003e         __RELA_END__ \u003d .;\n\u003e } \u003eRAM\n\u003e \n\u003e Obviously, this does not work since __RELA_START__ and __RELA_END__\n\u003e are set to the same address.\n\u003e \n\u003e So, we need to have *(.rela*) between them.\n\u003e \n\u003e And, I think it is natural to specify the input section.\n\u003e For example, see the linker script of Linux kernel:\n\u003e https://github.com/torvalds/linux/blob/v5.7/arch/arm64/kernel/vmlinux.lds.S#L205\n\nYes, I think so too. I am just trying to figure out how it was working before, to better understand the consequences of your changes.",
      "parentUuid": "2e2593f9_e1cac95e",
      "range": {
        "startLine": 112,
        "startChar": 2,
        "endLine": 112,
        "endChar": 11
      },
      "revId": "75a42aa3171041fa155782492d2c1a3fb3fab3ad",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    }
  ]
}