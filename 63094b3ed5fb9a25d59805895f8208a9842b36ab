{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "221aa289_cdfa6ea1",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2022-11-30T12:47:55Z",
      "side": 1,
      "message": "thinking further, I think the check needs to be bounded.",
      "revId": "63094b3ed5fb9a25d59805895f8208a9842b36ab",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "33f576fb_b9b6cc48",
        "filename": "include/arch/aarch64/arch_features.h",
        "patchSetId": 3
      },
      "lineNbr": 104,
      "author": {
        "id": 1000883
      },
      "writtenOn": "2022-12-01T12:13:46Z",
      "side": 1,
      "message": "This might be coming a bit late, and is probably a strange a idea but I think it\u0027s worth considering. Would it make sense to implement this function (only this one, not the other) in assembly?\n\nThe primary benefit of this would be in arch/aarch64/el3_common_macros.S, where this same operations is done and we could remove a bit of duplicate code this way.\n\nAnother reason is that these functions are highly similar, so they could even be defined with macros (kind of like the DEFINE_SYSREG_READ_FUNC c macro).\n\nWould this make sense? Is it worth it?",
      "revId": "63094b3ed5fb9a25d59805895f8208a9842b36ab",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "55cc3b70_3ce0f921",
        "filename": "include/arch/aarch64/arch_features.h",
        "patchSetId": 3
      },
      "lineNbr": 104,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2022-12-01T12:37:13Z",
      "side": 1,
      "message": "I am not sure it is worth to make an exception for a single function. Moving the check to asm is probably the wrong direction we want to take (even if it means some duplication in asm). Also this will be probably be inlined by compiler so having a branch to asm function is probably less efficient at runtime.  \n\nEven if we make a C macro to have inline asm , this cannot be called from early asm code.",
      "parentUuid": "33f576fb_b9b6cc48",
      "revId": "63094b3ed5fb9a25d59805895f8208a9842b36ab",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c1435bee_4a87f622",
        "filename": "include/arch/aarch64/arch_features.h",
        "patchSetId": 3
      },
      "lineNbr": 104,
      "author": {
        "id": 1000883
      },
      "writtenOn": "2022-12-01T13:23:18Z",
      "side": 1,
      "message": "Sorry, I meant all _field functions and none of the _supported functions. And why couldn\u0027t they be used at startup if they didn\u0027t use stack? \n\nAnyway, yeah it\u0027s probably not worth it in this case",
      "parentUuid": "55cc3b70_3ce0f921",
      "revId": "63094b3ed5fb9a25d59805895f8208a9842b36ab",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f7b3325b_f8dc32c6",
        "filename": "include/arch/aarch64/arch_features.h",
        "patchSetId": 3
      },
      "lineNbr": 104,
      "author": {
        "id": 1000118
      },
      "writtenOn": "2022-12-01T13:58:43Z",
      "side": 1,
      "message": "I couldn\u0027t find any instance of FGT checking or even any id_aa64mmfr0_el1 access in assembly, so is that the right function? I see that there are some ID register checks in the macros, and we might want to revisit them later, to see if they are actually needed or need to be amended (for instance I doubt we need to set trap filter controls for lower ELs in early code).\n\nIn general I would also say that it\u0027s not worth to share the three-ish instructions we need to read and mask an ID register.\n\nRegarding calling C functions from early assembly: it\u0027s up to the compiler to include stack usage or not, you cannot assume that just because the function is simple or because the compiler doesn\u0027t emit any stack accesses *today* that this is safe (think function annotation or instrumentation).",
      "parentUuid": "c1435bee_4a87f622",
      "revId": "63094b3ed5fb9a25d59805895f8208a9842b36ab",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "30d928f7_62565f5b",
        "filename": "include/arch/aarch64/arch_features.h",
        "patchSetId": 3
      },
      "lineNbr": 104,
      "author": {
        "id": 1000883
      },
      "writtenOn": "2022-12-01T14:43:46Z",
      "side": 1,
      "message": "I mean in general. FGT does not need this, but I found others that do. Since this will establish a pattern I thought it would be worth considering.\n\nYeah, I understand that about C and the stack hence the suggestions to put them in assembly.\n\nBut if the thought is it\u0027s not worth it, that\u0027s fine by me",
      "parentUuid": "f7b3325b_f8dc32c6",
      "revId": "63094b3ed5fb9a25d59805895f8208a9842b36ab",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f9361057_25db7596",
        "filename": "include/arch/aarch64/arch_features.h",
        "patchSetId": 3
      },
      "lineNbr": 113,
      "author": {
        "id": 1000660
      },
      "writtenOn": "2022-12-22T12:01:53Z",
      "side": 1,
      "message": "The approach of splitting the functions is good.\n\nOnly thing I am worried is, we need to set the FEATURE_DETECTION build flag by default. Currently it is set to zero and need to be explicitly enabled by the user.\nSo we need to mandate it or else it would be incorrect as we are returning true here, without actually reading the resgisters.",
      "revId": "63094b3ed5fb9a25d59805895f8208a9842b36ab",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c7b6542f_f266f663",
        "filename": "include/arch/aarch64/arch_features.h",
        "patchSetId": 3
      },
      "lineNbr": 113,
      "author": {
        "id": 1000118
      },
      "writtenOn": "2023-01-03T11:47:13Z",
      "side": 1,
      "message": "But this is exactly the idea of *this* function: iff you forcibly set the build flag to 1 (FEAT_STATE_ALWAYS), you assume that the feature is there and doesn\u0027t need checking. This is a very reasonable assumption for fixed hardware: a Cortex-A57 (for instance) will never lose or gain features over time, so there is no real need to do feature detection at runtime. We gain quite some optimisation with this, because the compiler can see that the result of this static function is fixed, so goes on to remove dependent code from the binary.\nIf you really want to read the ID registers, you explicitly use read_feat_fgt_field().\n\nThis is a different story for variable platforms like QEMU or the FVP, but the plan is to force those flags to \"2\" there.",
      "parentUuid": "f9361057_25db7596",
      "revId": "63094b3ed5fb9a25d59805895f8208a9842b36ab",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "98051fc3_f6116a9a",
        "filename": "include/arch/aarch64/arch_features.h",
        "patchSetId": 3
      },
      "lineNbr": 113,
      "author": {
        "id": 1000660
      },
      "writtenOn": "2023-01-03T15:11:51Z",
      "side": 1,
      "message": "Thanks for your explanation.\n\nJust to explain my understanding, excuse if its repetetion:\nIn our initial design, when the feature detection mechanism was introduced, we agreed on the following approach.\nWe split the feature flags usage across these sections:\nBoot   |  Context Management       | Save and Restore registers |\n\nAccordingly, during the boot phase, In the detect_arch_features function, if FEATURE-specific build flags are set to 1, they are evaluated at an early stage and if any failure panic at boot phase itself. If the detect_arch_features function is passed, then don\u0027t do any ID register read again at other sections ( Context and Save and restore routines).\n\nIn case the if FEATURE specific build flags are set to 2, they are evaluated at runtime ( at context management / save and restore routines). This wasn\u0027t covered but was thought of in the phase 1.\n\nWith your patch, I was worried because, if FEATURE_DETECTION is disabled, we never run \"detect_arch_features\" fucntion to read the registers. Also wasn\u0027t completely aware of this ( wherein for fixed platforms we could assume that the end user never enables any features which are not present in it by mistake, and hence we could potentially remove the ID check ) and for platforms like QEMU and FVP force the flags to 2.\n\nIf we are heading towards setting the build flags to 2 for FVP and QEMU, then your patch covers that explicitly here.\n\nHowever, I don\u0027t see setting the FEATURE_DETECTION flag to 1 causing any harm here.\nPlease do correct, If I am wrong, but we are running detect_arch_features function under FEATURE_DETECTION flag only at bootphase.\nSetting FEATURE_DETECTION to 1, will enable this function and reads through all registers once for all ( **if they are set to FEAT_STATE_ALWAYS). From there onwards, during context mangement phase and at save and restore-routine phase, we can use \"is_feat_fgt_supported\" function as per your patch. We are still not doing any runtime check here.",
      "parentUuid": "c7b6542f_f266f663",
      "revId": "63094b3ed5fb9a25d59805895f8208a9842b36ab",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2fa70fe9_8c7d1486",
        "filename": "include/arch/aarch64/arch_features.h",
        "patchSetId": 3
      },
      "lineNbr": 117,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2022-11-30T12:47:55Z",
      "side": 1,
      "message": "I think this check should have an upper bound of known values. Else there is a risk that a new version with unknown effects will get accidentally enabled for the 3 worlds.",
      "range": {
        "startLine": 117,
        "startChar": 30,
        "endLine": 117,
        "endChar": 35
      },
      "revId": "63094b3ed5fb9a25d59805895f8208a9842b36ab",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "91358c03_a22be3d1",
        "filename": "include/arch/aarch64/arch_features.h",
        "patchSetId": 3
      },
      "lineNbr": 117,
      "author": {
        "id": 1000118
      },
      "writtenOn": "2022-11-30T14:10:31Z",
      "side": 1,
      "message": "But that is one of the existing problems that we need to solve. Just putting in some arbitrary boundary is requiring heavy maintenance, and the cases where it breaks are really rare - I think the one you found might indeed be the only one so far. The cases where we miss a feature field update and upset NS world are much more frequent.\n\nI propose another solution for that: have a separate check function that verifies our highest-known-good values for each feature field against the hardware. I posted this patch internally, and am happy to put this up here as well.\nThis optional debug feature would then panic if a higher field number is encountered, and then we will most likely just need to look up the ARM ARM to confirm it\u0027s fine, and update the number in that check function.\n\nThe point is: both solutions (strictly compare against known versions only vs. allowing all versions) are wrong in one way or another. But we should settle for the one that causes less damage, and cover the rest separately.",
      "parentUuid": "2fa70fe9_8c7d1486",
      "range": {
        "startLine": 117,
        "startChar": 30,
        "endLine": 117,
        "endChar": 35
      },
      "revId": "63094b3ed5fb9a25d59805895f8208a9842b36ab",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5388282b_2905978c",
        "filename": "include/arch/aarch64/arch_features.h",
        "patchSetId": 3
      },
      "lineNbr": 117,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2022-12-01T12:37:13Z",
      "side": 1,
      "message": "hmm, ok, this one will do the enable and the separate check can verify the highest known good values and panic otherwise. works for me.",
      "parentUuid": "91358c03_a22be3d1",
      "range": {
        "startLine": 117,
        "startChar": 30,
        "endLine": 117,
        "endChar": 35
      },
      "revId": "63094b3ed5fb9a25d59805895f8208a9842b36ab",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    }
  ]
}