{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "221aa289_cdfa6ea1",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2022-11-30T12:47:55Z",
      "side": 1,
      "message": "thinking further, I think the check needs to be bounded.",
      "revId": "63094b3ed5fb9a25d59805895f8208a9842b36ab",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "33f576fb_b9b6cc48",
        "filename": "include/arch/aarch64/arch_features.h",
        "patchSetId": 3
      },
      "lineNbr": 104,
      "author": {
        "id": 1000883
      },
      "writtenOn": "2022-12-01T12:13:46Z",
      "side": 1,
      "message": "This might be coming a bit late, and is probably a strange a idea but I think it\u0027s worth considering. Would it make sense to implement this function (only this one, not the other) in assembly?\n\nThe primary benefit of this would be in arch/aarch64/el3_common_macros.S, where this same operations is done and we could remove a bit of duplicate code this way.\n\nAnother reason is that these functions are highly similar, so they could even be defined with macros (kind of like the DEFINE_SYSREG_READ_FUNC c macro).\n\nWould this make sense? Is it worth it?",
      "revId": "63094b3ed5fb9a25d59805895f8208a9842b36ab",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "55cc3b70_3ce0f921",
        "filename": "include/arch/aarch64/arch_features.h",
        "patchSetId": 3
      },
      "lineNbr": 104,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2022-12-01T12:37:13Z",
      "side": 1,
      "message": "I am not sure it is worth to make an exception for a single function. Moving the check to asm is probably the wrong direction we want to take (even if it means some duplication in asm). Also this will be probably be inlined by compiler so having a branch to asm function is probably less efficient at runtime.  \n\nEven if we make a C macro to have inline asm , this cannot be called from early asm code.",
      "parentUuid": "33f576fb_b9b6cc48",
      "revId": "63094b3ed5fb9a25d59805895f8208a9842b36ab",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c1435bee_4a87f622",
        "filename": "include/arch/aarch64/arch_features.h",
        "patchSetId": 3
      },
      "lineNbr": 104,
      "author": {
        "id": 1000883
      },
      "writtenOn": "2022-12-01T13:23:18Z",
      "side": 1,
      "message": "Sorry, I meant all _field functions and none of the _supported functions. And why couldn\u0027t they be used at startup if they didn\u0027t use stack? \n\nAnyway, yeah it\u0027s probably not worth it in this case",
      "parentUuid": "55cc3b70_3ce0f921",
      "revId": "63094b3ed5fb9a25d59805895f8208a9842b36ab",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f7b3325b_f8dc32c6",
        "filename": "include/arch/aarch64/arch_features.h",
        "patchSetId": 3
      },
      "lineNbr": 104,
      "author": {
        "id": 1000118
      },
      "writtenOn": "2022-12-01T13:58:43Z",
      "side": 1,
      "message": "I couldn\u0027t find any instance of FGT checking or even any id_aa64mmfr0_el1 access in assembly, so is that the right function? I see that there are some ID register checks in the macros, and we might want to revisit them later, to see if they are actually needed or need to be amended (for instance I doubt we need to set trap filter controls for lower ELs in early code).\n\nIn general I would also say that it\u0027s not worth to share the three-ish instructions we need to read and mask an ID register.\n\nRegarding calling C functions from early assembly: it\u0027s up to the compiler to include stack usage or not, you cannot assume that just because the function is simple or because the compiler doesn\u0027t emit any stack accesses *today* that this is safe (think function annotation or instrumentation).",
      "parentUuid": "c1435bee_4a87f622",
      "revId": "63094b3ed5fb9a25d59805895f8208a9842b36ab",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2fa70fe9_8c7d1486",
        "filename": "include/arch/aarch64/arch_features.h",
        "patchSetId": 3
      },
      "lineNbr": 117,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2022-11-30T12:47:55Z",
      "side": 1,
      "message": "I think this check should have an upper bound of known values. Else there is a risk that a new version with unknown effects will get accidentally enabled for the 3 worlds.",
      "range": {
        "startLine": 117,
        "startChar": 30,
        "endLine": 117,
        "endChar": 35
      },
      "revId": "63094b3ed5fb9a25d59805895f8208a9842b36ab",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "91358c03_a22be3d1",
        "filename": "include/arch/aarch64/arch_features.h",
        "patchSetId": 3
      },
      "lineNbr": 117,
      "author": {
        "id": 1000118
      },
      "writtenOn": "2022-11-30T14:10:31Z",
      "side": 1,
      "message": "But that is one of the existing problems that we need to solve. Just putting in some arbitrary boundary is requiring heavy maintenance, and the cases where it breaks are really rare - I think the one you found might indeed be the only one so far. The cases where we miss a feature field update and upset NS world are much more frequent.\n\nI propose another solution for that: have a separate check function that verifies our highest-known-good values for each feature field against the hardware. I posted this patch internally, and am happy to put this up here as well.\nThis optional debug feature would then panic if a higher field number is encountered, and then we will most likely just need to look up the ARM ARM to confirm it\u0027s fine, and update the number in that check function.\n\nThe point is: both solutions (strictly compare against known versions only vs. allowing all versions) are wrong in one way or another. But we should settle for the one that causes less damage, and cover the rest separately.",
      "parentUuid": "2fa70fe9_8c7d1486",
      "range": {
        "startLine": 117,
        "startChar": 30,
        "endLine": 117,
        "endChar": 35
      },
      "revId": "63094b3ed5fb9a25d59805895f8208a9842b36ab",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5388282b_2905978c",
        "filename": "include/arch/aarch64/arch_features.h",
        "patchSetId": 3
      },
      "lineNbr": 117,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2022-12-01T12:37:13Z",
      "side": 1,
      "message": "hmm, ok, this one will do the enable and the separate check can verify the highest known good values and panic otherwise. works for me.",
      "parentUuid": "91358c03_a22be3d1",
      "range": {
        "startLine": 117,
        "startChar": 30,
        "endLine": 117,
        "endChar": 35
      },
      "revId": "63094b3ed5fb9a25d59805895f8208a9842b36ab",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    }
  ]
}