{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "613d9bd8_e397fc5f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000272
      },
      "writtenOn": "2021-04-13T23:46:23Z",
      "side": 1,
      "message": "Thanks for the responses Julius! Agreed that it\u0027s hard to figure out what\u0027s going wrong here.",
      "revId": "0ff42b17c6a71cd4cb0ca6a93a3cace744bf7ec8",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d9791df1_c10bdf2b",
        "filename": "plat/rockchip/rk3399/drivers/dram/suspend.c",
        "patchSetId": 1
      },
      "lineNbr": 791,
      "author": {
        "id": 1000060
      },
      "writtenOn": "2021-04-13T22:08:30Z",
      "side": 1,
      "message": "Please don\u0027t just globally remove this for all platforms just because it didn\u0027t work for yours. We should try to figure out what the problem was for you and fix it, and if we can\u0027t do that we should make this configurable in a way that solves everyone\u0027s use case.\n\nThe way I think this works is that rockchip_soc_sys_pwr_dm_suspend() stores the old watchdog settings (including whether it was enabled or not) on the way down into suspend. Then here, very early in resume (before DRAM is up where we stored those settings), pmusram_enable_watchdog() unconditionally enables the watchdog and programs it to 8 seconds (which is useful in case anything hangs during DRAM resume). If all goes well, we should finish DRAM resume and get back into rockchip_soc_sys_pwr_dm_resume() long before those 8 seconds have passed, which will restore the previously stored watchdog settings (i.e. just disable it if it was previously disabled).\n\nIs it maybe possible that when you tested this you did something that prevented it from reaching rockchip_soc_sys_pwr_dm_resume() in time? Maybe put an extra delay or a lot of debugging output in somewhere that could have slowed it down too long?",
      "revId": "0ff42b17c6a71cd4cb0ca6a93a3cace744bf7ec8",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b17757d0_71d29bf7",
        "filename": "plat/rockchip/rk3399/drivers/dram/suspend.c",
        "patchSetId": 1
      },
      "lineNbr": 791,
      "author": {
        "id": 1000272
      },
      "writtenOn": "2021-04-13T23:46:23Z",
      "side": 1,
      "message": "I tested with only this patch, applied to master. It does seem to be missing a step where the watchdog is enabled, as it stops/crashes after it gets back into Linux as it\u0027s turning CPUs. For what it\u0027s worth, the timeout looked something like 250ms, which does not match the 8s figure in the code. Perhaps it\u0027s not running at the speed we think it\u0027s running at?",
      "parentUuid": "d9791df1_c10bdf2b",
      "revId": "0ff42b17c6a71cd4cb0ca6a93a3cace744bf7ec8",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2eceac0a_cb9eca2d",
        "filename": "plat/rockchip/rk3399/drivers/dram/suspend.c",
        "patchSetId": 1
      },
      "lineNbr": 791,
      "author": {
        "id": 1000060
      },
      "writtenOn": "2021-04-14T00:48:35Z",
      "side": 1,
      "message": "Do you have the watchdog enabled in Linux? Do you have a /dev/watchdog, and if you do an `echo x \u003e /dev/watchdog`, does it reboot your machine after a while? I guess it\u0027s possible that if you don\u0027t have the driver built in at all or something that leaves the watchdog in a state that our save/restore mechanism doesn\u0027t deal with right, although I wouldn\u0027t see how right now. (It could help if you instrument wdt_register_save()/_restore() to print which values are being saved/restored into the registers. Really these should be the same whether you remove the pmusram part or not, so I\u0027m surprised it makes a difference.)",
      "parentUuid": "b17757d0_71d29bf7",
      "revId": "0ff42b17c6a71cd4cb0ca6a93a3cace744bf7ec8",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "93101940_e3281e7c",
        "filename": "plat/rockchip/rk3399/drivers/dram/suspend.c",
        "patchSetId": 1
      },
      "lineNbr": 791,
      "author": {
        "id": 1000272
      },
      "writtenOn": "2021-04-14T01:52:32Z",
      "side": 1,
      "message": "Thanks for the debug suggestions. I dumped the registers, and it looks like it should be disabled by TF-A uppon resume. It seems that WDT0 remains on after the call to wdt_register_restore. This is very strange, and I\u0027m not sure what\u0027s going on with that. In particualr, WDT0_BASE + 4 is written with `0x0a` and reads back `0x0b`. I\u0027ve tried many things with the control registers, to no avail.\n\nDo you have any further suggestions on other things to check?",
      "parentUuid": "2eceac0a_cb9eca2d",
      "revId": "0ff42b17c6a71cd4cb0ca6a93a3cace744bf7ec8",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d98d070e_dde9280b",
        "filename": "plat/rockchip/rk3399/drivers/dram/suspend.c",
        "patchSetId": 1
      },
      "lineNbr": 791,
      "author": {
        "id": 1000272
      },
      "writtenOn": "2021-04-14T20:46:23Z",
      "side": 1,
      "message": "This behavior explains the quick timeout, actually, as it\u0027s replacing the timeout period, which is setup by pmusram to 8 seconds, with something 2^9 smaller or about 15ms, allowing linux to try to bring up a single CPU.",
      "parentUuid": "93101940_e3281e7c",
      "revId": "0ff42b17c6a71cd4cb0ca6a93a3cace744bf7ec8",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "839f7782_7ad005e8",
        "filename": "plat/rockchip/rk3399/drivers/dram/suspend.c",
        "patchSetId": 1
      },
      "lineNbr": 837,
      "author": {
        "id": 1000060
      },
      "writtenOn": "2021-04-13T22:08:30Z",
      "side": 1,
      "message": "(Gotta be honest, I know it\u0027s hard to do this without support from Rockchip and I understand it\u0027s better than LPDDR4 not working at all, but this doesn\u0027t look right at all. You\u0027re basically skipping the whole training step and then just running the controller with god knows what settings. Maybe this worked a few times in your test environment when you just suspend a device and resume it again a few seconds later, but I don\u0027t think it could really be reliable long-term when you suspend a device in one environment and resume it in another days later. Perhaps you comparing with the training code in U-Boot could help you figure out what is missing here?)",
      "revId": "0ff42b17c6a71cd4cb0ca6a93a3cace744bf7ec8",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5fc30eec_e76d5ea2",
        "filename": "plat/rockchip/rk3399/drivers/dram/suspend.c",
        "patchSetId": 1
      },
      "lineNbr": 837,
      "author": {
        "id": 1000272
      },
      "writtenOn": "2021-04-13T23:46:23Z",
      "side": 1,
      "message": "I appreciate the honesty. For what it\u0027s worth, `dram_switch_to_next_index` also does training, so we\u0027re not skipping all training, we\u0027re skipping the first set of training.",
      "parentUuid": "839f7782_7ad005e8",
      "revId": "0ff42b17c6a71cd4cb0ca6a93a3cace744bf7ec8",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c32156db_85236751",
        "filename": "plat/rockchip/rk3399/drivers/dram/suspend.c",
        "patchSetId": 1
      },
      "lineNbr": 837,
      "author": {
        "id": 1000060
      },
      "writtenOn": "2021-04-14T00:48:35Z",
      "side": 1,
      "message": "The RK3399 has two separate DRAM controller register blocks, so that it can instantly switch from one to the other for runtime DDR frequency switching. This here trains the first block and dram_switch_to_next_index() the second one. That probably explains why this is working for you at all, you probably don\u0027t have DDR frequency switching enabled in the kernel. If you did, I would expect it to break the first time it\u0027s trying to change frequencies after resume and switch back to index 0.",
      "parentUuid": "5fc30eec_e76d5ea2",
      "revId": "0ff42b17c6a71cd4cb0ca6a93a3cace744bf7ec8",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "eb4a274c_74da0352",
        "filename": "plat/rockchip/rk3399/drivers/dram/suspend.c",
        "patchSetId": 1
      },
      "lineNbr": 837,
      "author": {
        "id": 1000272
      },
      "writtenOn": "2021-04-14T01:52:32Z",
      "side": 1,
      "message": "True, I probably don\u0027t have DDR frequency switching enabled. I\u0027ll have a look at enabling DDR frequency switching in my test kernel. If we did enable training of 2 frequencies, I\u0027m worried we might no longer fit in pmusram. That being said, what we have here in still a step forward.",
      "parentUuid": "c32156db_85236751",
      "revId": "0ff42b17c6a71cd4cb0ca6a93a3cace744bf7ec8",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    }
  ]
}