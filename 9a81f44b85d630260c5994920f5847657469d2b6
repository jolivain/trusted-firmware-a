{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "fb480e46_e7c7838b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2023-02-28T12:12:50Z",
      "side": 1,
      "message": "I think it is good to initialize the values to sane values and then modify it later to more appropriate ones later. These values are used during cold boot path (i.e prior to exit to NS world) and would prevent SPM or RMM cold boot accessing SPE by mistake. \n\nAlso el3_common_macros are reused by all BL images running at EL3 (BL1/BL2/BL31). Hence would be good to have these reset values in.",
      "revId": "9a81f44b85d630260c5994920f5847657469d2b6",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "11649c7f_7ae02d92",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1000883
      },
      "writtenOn": "2023-02-28T14:41:42Z",
      "side": 1,
      "message": "I\u0027m not sure why this is relevant. \n\nSPE and TRBE are explicitly only enabled for nonsecure world (in manage_extensions_secure()). Secure and realm worlds aren\u0027t meant to have it available (the implementation seems to allow it but that\u0027s a different topic, no?). \n\nThen, why is preventing RMM/SPM accessing something by mistake a bad thing? If they aren\u0027t meant to do it, then they shouldn\u0027t be? If they are indeed meant to, then the context management code is (at least semantically) wrong.\n\nFinally, yes BL !\u003d 31 also use these macros, but they are not concerned with most of the extensions that are set up since they won\u0027t be used ({spe, trbe}_enable are only called on BL31 so I doubt the intention was to make them usable on BL1 for example). Doing this there unnecessarily convolutes tracking down what the feature enablement looks like.",
      "parentUuid": "fb480e46_e7c7838b",
      "revId": "9a81f44b85d630260c5994920f5847657469d2b6",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "43111937_5737f724",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2023-02-28T17:04:27Z",
      "side": 1,
      "message": "\u003e Then, why is preventing RMM/SPM accessing something by mistake a bad thing?\n\nPreventing SPM/RMM accessing TRBE by mistake is a good thing :). And hence we need to the setting in reset code which prevents this access for RMM and SPM.\n\nI see that the original code is doing the inverse which is wrong. it is enabling for secure world and I have no idea why it was done that way. This should corrected so that we set 0x11 for MDCR_NSTB_EL1 and clear MDCR_NSTBE bit.\n\nmov_imm\tx0, ((MDCR_EL3_RESET_VAL | MDCR_SDD_BIT | \\\n\t\t      MDCR_SPD32(MDCR_SPD32_DISABLE) | MDCR_SCCD_BIT | \\\n\t\t      MDCR_MCCD_BIT |  MDCR_NSTB(MDCR_NSTB_EL1) \u0026 ~(MDCR_SPME_BIT \n                      | MDCR_TDOSA_BIT | MDCR_TDA_BIT | MDCR_TPM_BIT |) | \\\n\t\t      MDCR_NSTBE | MDCR_TTRF_BIT))\n\n\nDoing this in reset code is important so that RMM and SPM init cannot accidently touch trace. The code comments should also be corrected.",
      "parentUuid": "11649c7f_7ae02d92",
      "revId": "9a81f44b85d630260c5994920f5847657469d2b6",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "13de686e_01257062",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2023-03-01T09:28:19Z",
      "side": 1,
      "message": "OK, I think some common fundamentals need to be set out so that we dont have adhoc policy for each feature.\n\nThe purpose of the reset initialization is to ensure EL3 firmware has a secure execution environment. The reset init is not related to \"feature enablement\" for lower ELs although sometimes this could match. \n\nThe feature enablement is on a per-world basis is done later in the boot sequence just prior to exiting to that world.\n\nWith this purpose in mind, the reset code is meant to initialize any security related bits which could have UNKNOWN reset values to a sane safe value. That is the case for these bits as Arm ARM says \"On a Warm reset, this field resets to an architecturally UNKNOWN value\".\n\nHence the code is supposed to set these UNKNOWN values. Now having looked at Arm ARM, clearing MDCR_NSTB_EL1 to 0x00 will make the trace buffers secure only and trap any access from EL2/EL1 to EL3. This means, trace buffers are not really usable by lower ELs as they cannot access any control registers. So from the reset purpose listed above , this is a safe sane initialization value. The comments in the code are a bit misleading without the full context of why this is done this way.\n\nLet me know if you have doubts.",
      "parentUuid": "43111937_5737f724",
      "revId": "9a81f44b85d630260c5994920f5847657469d2b6",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2f64fe2a_e3c748b0",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2023-03-01T09:29:52Z",
      "side": 1,
      "message": "Type in above comment. \n\n\"Hence the code is supposed to set these UNKNOWN values\" -\u003e \"Hence the code is supposed to set these KNOWN sane values.\"",
      "parentUuid": "13de686e_01257062",
      "revId": "9a81f44b85d630260c5994920f5847657469d2b6",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "93e75972_24e39b21",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1000328
      },
      "writtenOn": "2023-03-01T09:49:26Z",
      "side": 1,
      "message": "Hi Soby,\n\n\u003e Hence the code is supposed to set these UNKNOWN values. Now having looked at Arm ARM, clearing MDCR_NSTB_EL1 to 0x00 will make the trace buffers secure only and trap any access from EL2/EL1 to EL3. This means, trace buffers are not really usable by lower ELs as they cannot access any control registers. So from the reset purpose listed above , this is a safe sane initialization value. The comments in the code are a bit misleading without the full context of why this is done this way.\n\nAFAIU code comment implies to say the same thing that  \"Access to Trace Buffer control registers at EL2 and EL1 in any security state generates trap exceptions at EL3\" though it is not providing the full context so better amend the comment from that perspective.\n\nI agree that there is one missing comment here regarding MDCR_EL3.STE, It would be better to add a comment to the STE bit, which has blanket control to prevent tracing on the secure side. Currently it is set to 0 i.e. MDCR_EL3.STE\u003d0 on reset.\n\nNote, FEAT_TRBE requires FEAT_TRF, STE bit is available when FEAT_TRF is present. So putting STE to 0 ensures that tracing is not possible in the secure side.",
      "parentUuid": "2f64fe2a_e3c748b0",
      "revId": "9a81f44b85d630260c5994920f5847657469d2b6",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    }
  ]
}