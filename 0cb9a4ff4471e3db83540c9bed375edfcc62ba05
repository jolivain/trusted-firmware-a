{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "c21d8923_96af9d48",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 23
      },
      "lineNbr": 0,
      "author": {
        "id": 1000328
      },
      "writtenOn": "2024-05-10T12:54:42Z",
      "side": 1,
      "message": "Replaying Heiko\u0027s CoR+1 vote.",
      "revId": "0cb9a4ff4471e3db83540c9bed375edfcc62ba05",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "464c4c61_dd694a38",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 23
      },
      "lineNbr": 0,
      "author": {
        "id": 1000118
      },
      "writtenOn": "2024-05-10T13:35:23Z",
      "side": 1,
      "message": "So this doesn\u0027t boot for me on a Quartz64 model B. Using rk3568_bl31_v1.43.elf from rkbin works, but not the bl31.elf from here. It hangs after:\nINFO:    Maximum SPI INTID supported: 351\nI will try to debug this further, the log from the vendor BL31 suggests it touches the PMU next?",
      "revId": "0cb9a4ff4471e3db83540c9bed375edfcc62ba05",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "37ab37be_264590e9",
        "filename": "lib/cpus/aarch64/cortex_a55.S",
        "patchSetId": 23
      },
      "lineNbr": 127,
      "author": {
        "id": 1000118
      },
      "writtenOn": "2024-05-10T13:40:10Z",
      "side": 1,
      "message": "On second thought I wonder if this is really needed. If I understand the ARM ARM here correctly, this bit would reset to the value of EDPRCR[COREPURQ], an external debug register. This presumably allows an external debugger to veto a proper core shutdown, so it can stay connected and access the core still. I don\u0027t really see why we should tinker with this bit. Is that needed for a proper core shutdown? Maybe it was in some early bringup scenario in the lab only?",
      "revId": "0cb9a4ff4471e3db83540c9bed375edfcc62ba05",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "63186128_5fb4b867",
        "filename": "lib/cpus/aarch64/cortex_a55.S",
        "patchSetId": 23
      },
      "lineNbr": 127,
      "author": {
        "id": 1000879
      },
      "writtenOn": "2024-05-27T09:15:51Z",
      "side": 1,
      "message": "When this bit is set to 0bl and a core power-off is requested, the core will request OFF EMU as a minimum power mode, with the OFF EMU COREPACTIVE set HIGH. P-Channel requests to OFF will be denied. This power mode preserves debug state and allows debug access while the core functionally emulates an off state. \n\nOFF EMU: This power mode allows functional emulation of power-off, whilst still\nmaintaining debug state.\nOFF (SHUTDOWN): This power mode allows the core to be powered-off.\nThis mode powers-off the complete core domain, including all logic, TCMs, and\nL1 cache RAM.\n\nTo ensure successful powerdown, clear this register to zero.",
      "parentUuid": "37ab37be_264590e9",
      "revId": "0cb9a4ff4471e3db83540c9bed375edfcc62ba05",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "479119d3_15d73c01",
        "filename": "lib/cpus/aarch64/cortex_a55.S",
        "patchSetId": 23
      },
      "lineNbr": 127,
      "author": {
        "id": 1000879
      },
      "writtenOn": "2024-05-27T09:15:51Z",
      "side": 1,
      "message": "When this bit is set to 0bl and a core power-off is requested, the core will request OFF EMU as a minimum power mode, with the OFF EMU COREPACTIVE set HIGH. P-Channel requests to OFF will be denied. This power mode preserves debug state and allows debug access while the core functionally emulates an off state.\n\nOFF EMU: This power mode allows functional emulation of power-off, whilst still\nmaintaining debug state.\nOFF (SHUTDOWN): This power mode allows the core to be powered-off.\nThis mode powers-off the complete core domain, including all logic, TCMs, and\nL1 cache RAM.",
      "parentUuid": "37ab37be_264590e9",
      "revId": "0cb9a4ff4471e3db83540c9bed375edfcc62ba05",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5f63a00c_d9632f6a",
        "filename": "lib/cpus/aarch64/cortex_a55.S",
        "patchSetId": 23
      },
      "lineNbr": 127,
      "author": {
        "id": 1000118
      },
      "writtenOn": "2024-05-27T16:25:35Z",
      "side": 1,
      "message": "Right, this is what I got as well, but I don\u0027t understand why we override this default? The behaviour to *not* completely power off is intentional: if (and only if!) an external debugger is connected, you want to keep the connection alive, even when software powers off the system: to be able to restart it, or to query the core state.\n\nDuring normal operation (without an external debugger connected), everything should work as expected: this bit should be 0 (copied from the this one debug register), and a power down request should result in a complete shutdown.\n\nSo does this not work? Is there some errata that prevents a complete shutdown of the SoC?\n\nIf not, and the shutdown works, I think we should keep this bit untouched, to leave it under control of a debugger.",
      "parentUuid": "63186128_5fb4b867",
      "revId": "0cb9a4ff4471e3db83540c9bed375edfcc62ba05",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8d2a462b_1b689f7e",
        "filename": "lib/cpus/aarch64/cortex_a55.S",
        "patchSetId": 23
      },
      "lineNbr": 127,
      "author": {
        "id": 1000879
      },
      "writtenOn": "2024-05-28T02:59:39Z",
      "side": 1,
      "message": "This part of the code has been deleted.",
      "parentUuid": "5f63a00c_d9632f6a",
      "revId": "0cb9a4ff4471e3db83540c9bed375edfcc62ba05",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    }
  ]
}