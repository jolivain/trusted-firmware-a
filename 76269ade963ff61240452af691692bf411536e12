{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "e061aa68_c8614058",
        "filename": "lib/locks/exclusive/aarch64/spinlock.S",
        "patchSetId": 3
      },
      "lineNbr": 107,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2024-03-17T13:02:40Z",
      "side": 1,
      "message": "I don\u0027t believe this is correct. Unlocks need to use release operations so strictly speaking, what we need here is ldxrb to load byte exclusively. Then we need a store release to prevent operations in the critical section to get reordered after bit_unlcock.",
      "range": {
        "startLine": 104,
        "startChar": 1,
        "endLine": 107,
        "endChar": 12
      },
      "revId": "76269ade963ff61240452af691692bf411536e12",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "47984a88_7d4822ee",
        "filename": "lib/locks/exclusive/aarch64/spinlock.S",
        "patchSetId": 3
      },
      "lineNbr": 107,
      "author": {
        "id": 1000105
      },
      "writtenOn": "2024-03-18T13:00:10Z",
      "side": 1,
      "message": "Why don\u0027t we need Load-Acquire to ensure the required ordering as in bit_lock()?\nDo you mean by \"store release\" \"stlrb\" instruction? Shouldn\u0027t load/store exclusively come in pairs?",
      "parentUuid": "e061aa68_c8614058",
      "range": {
        "startLine": 104,
        "startChar": 1,
        "endLine": 107,
        "endChar": 12
      },
      "revId": "76269ade963ff61240452af691692bf411536e12",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "11cedf3f_ba134e80",
        "filename": "lib/locks/exclusive/aarch64/spinlock.S",
        "patchSetId": 3
      },
      "lineNbr": 107,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2024-03-19T03:39:55Z",
      "side": 1,
      "message": "yes, we do, and we are doing that in line 87. ldaxrb is a load acquire. yes, I mean stlrb. we don\u0027t need exclusive access on the store during unlock, since it is a just a write, which should already be single copy atomic and the lock release/unlock is not an atomic read modify write like in the acquiring of lock.",
      "parentUuid": "47984a88_7d4822ee",
      "range": {
        "startLine": 104,
        "startChar": 1,
        "endLine": 107,
        "endChar": 12
      },
      "revId": "76269ade963ff61240452af691692bf411536e12",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "44fe7167_a8dd3a5d",
        "filename": "lib/locks/exclusive/aarch64/spinlock.S",
        "patchSetId": 3
      },
      "lineNbr": 107,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2024-03-20T09:48:55Z",
      "side": 1,
      "message": "There is difference to bit lock from regular spin lock. For regular spin lock , once it is \"locked\", then there is a single owner holding the lock and only the owner can \"unlock\" it. Hence a normal str instruction will suffice for unlock.\n\nIn bit lock, we are overlaying 8 locks on a single byte. So even when a bit is locked, this byte is not owned by a single owner. It is potentially shared with 7 other owners who are racing to \"lock\" the other bits of the byte. Hence the unlock now need to perform a exclusive load-acquire store-release semantics to ensure that when the bit is unlocked, it does not inadvertently overwrite values set by other owners.\n\nSemantically a bit lock and unlock has the following behavior:\n  * locking: acquire a byte lock to set a bit.\n  * unlocking : acquire a byte lock to clear a bit.",
      "parentUuid": "11cedf3f_ba134e80",
      "range": {
        "startLine": 104,
        "startChar": 1,
        "endLine": 107,
        "endChar": 12
      },
      "revId": "76269ade963ff61240452af691692bf411536e12",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ce84a637_adfd3ed0",
        "filename": "lib/locks/exclusive/aarch64/spinlock.S",
        "patchSetId": 3
      },
      "lineNbr": 107,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2024-03-20T10:29:08Z",
      "side": 1,
      "message": "good point.\n\nI think semantically what we need is:\nlocking: load-acquire exclusive byte, set bit, store exclusive byte.\nunlocking: load exclusive byte, clear bit, store-release exclusive byte.\n\nI think semantically you only need atomic bit set and clear, and acquire and release semantics at the start and end of the critical section respectively.\n\nLet me know what you think.",
      "parentUuid": "44fe7167_a8dd3a5d",
      "range": {
        "startLine": 104,
        "startChar": 1,
        "endLine": 107,
        "endChar": 12
      },
      "revId": "76269ade963ff61240452af691692bf411536e12",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8f09c5ea_77775b23",
        "filename": "lib/locks/exclusive/aarch64/spinlock.S",
        "patchSetId": 3
      },
      "lineNbr": 107,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2024-03-20T11:05:33Z",
      "side": 1,
      "message": "OK, since we have a read-modify-write sequence for the lock/unlock, we still need to ensure that the access to modify the byte was done while the CPU had the exclusive access to the byte I think. Just atomicity and ordering may not be enough perhaps.\n\nIt is difficult to prove that a lock works unless we can formally prove the scheme holds good (using TLA or litmus tests). Hence the approach taken here is to try to use proven exclusive access sequence so as to avoid doing further verification.\n\nYour scheme may work, if you can send write down the asm sequence you have in mind, we can analyze it and we can take it from there.",
      "parentUuid": "ce84a637_adfd3ed0",
      "range": {
        "startLine": 104,
        "startChar": 1,
        "endLine": 107,
        "endChar": 12
      },
      "revId": "76269ade963ff61240452af691692bf411536e12",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "08a9e8c4_13f5cdf3",
        "filename": "lib/locks/exclusive/aarch64/spinlock.S",
        "patchSetId": 3
      },
      "lineNbr": 107,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2024-03-20T11:38:37Z",
      "side": 1,
      "message": "asm sequence for lock is good from my pov. that is what the code does today.\nfor unlock, the optimized code would be:\nsevl\n1: wfe\nldxrb w2, [x0] /* Here I\u0027m saying ldaxrb (load acquire) is not required, but this is an optimization. it can just be load exclusive. */\nbic w2,w2,w1\nstlxrb w3, w2, [x0] /* this is the real change, you need this release semantic here with store release */\ncbnz w3, 1b\nret\n\nAnother sequence that is less optimized:\nsevl\n1: wee\nldaxrb w2, [x0]\nbic w2, w2, 1\nstxrb w3, w2, [x0]\ncbnz w3, 1b\ndmb /* This barrier is critical */\nret\n\nIn both the sequences above, the release semantics or barrier is critical during unlock. If you don\u0027t have that, loads and stores inside the critical section, can be reordered after the bit unlock. load-acquire does not prevent older memory ops from being reordered after it. This means, critical section memory can leak out of the critical section past the unlock.",
      "parentUuid": "8f09c5ea_77775b23",
      "range": {
        "startLine": 104,
        "startChar": 1,
        "endLine": 107,
        "endChar": 12
      },
      "revId": "76269ade963ff61240452af691692bf411536e12",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a41678d9_bdc11039",
        "filename": "lib/locks/exclusive/aarch64/spinlock.S",
        "patchSetId": 3
      },
      "lineNbr": 107,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2024-03-20T11:40:34Z",
      "side": 1,
      "message": "also note in all cases we are using exclusive accesses to the byte with the bit locks.",
      "parentUuid": "08a9e8c4_13f5cdf3",
      "range": {
        "startLine": 104,
        "startChar": 1,
        "endLine": 107,
        "endChar": 12
      },
      "revId": "76269ade963ff61240452af691692bf411536e12",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "261b8357_3d25b07c",
        "filename": "lib/locks/exclusive/aarch64/spinlock.S",
        "patchSetId": 3
      },
      "lineNbr": 107,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2024-03-21T02:16:13Z",
      "side": 1,
      "message": "apologies. The dmb in the above less optimized sequence should be before the wfe. the dmb in my sequence above is too late, since loads and stores in critical section can reorder past the stxrb. so the less optimized sequence would be:\n\ndmb /* ensyre all memory ops in critical section complete/observed BEFORE the lock release */\nsevl\n1: wfe\nldaxrb w2, [x0]\nbic w2, w2, 1\nstern w3, w3, [x0]\ncbnz w3, 1b\nret",
      "parentUuid": "a41678d9_bdc11039",
      "range": {
        "startLine": 104,
        "startChar": 1,
        "endLine": 107,
        "endChar": 12
      },
      "revId": "76269ade963ff61240452af691692bf411536e12",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "945e54a0_40e49b29",
        "filename": "lib/locks/exclusive/aarch64/spinlock.S",
        "patchSetId": 3
      },
      "lineNbr": 107,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2024-03-21T16:29:05Z",
      "side": 1,
      "message": "Ah, indeed. I see your point. We need to unlock with store release semantics.\nAlexei is on holiday now, so he will be able to rework this after he is back in April. So the below sequence should be good for unlock ?\n\nsevl\n1: wfe\nldxrb w2, [x0]\nbic w2,w2,w1\nstlxrb w3, w2, [x0] \ncbnz w3, 1b\nret",
      "parentUuid": "261b8357_3d25b07c",
      "range": {
        "startLine": 104,
        "startChar": 1,
        "endLine": 107,
        "endChar": 12
      },
      "revId": "76269ade963ff61240452af691692bf411536e12",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "122ae17a_f7da8381",
        "filename": "lib/locks/exclusive/aarch64/spinlock.S",
        "patchSetId": 3
      },
      "lineNbr": 107,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2024-03-22T02:15:12Z",
      "side": 1,
      "message": "yes I believe that should work. if we want to be conservative we can make the ldxrb to be ldaxrb and I’m certain that will be correct. I will need to think a little more to be sure if ldxrb is sufficient.",
      "parentUuid": "945e54a0_40e49b29",
      "range": {
        "startLine": 104,
        "startChar": 1,
        "endLine": 107,
        "endChar": 12
      },
      "revId": "76269ade963ff61240452af691692bf411536e12",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c76bf25f_d3f0eebe",
        "filename": "lib/locks/exclusive/aarch64/spinlock.S",
        "patchSetId": 3
      },
      "lineNbr": 107,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2024-03-25T11:25:20Z",
      "side": 1,
      "message": "yes, since the bit_unlock is a lock operation followed by clear bit, it may be worth enforcing partial ordering wrt to the bit_lock(). I cant forsee any issues without the additional ordering, but would be better to be conservative.\n\n@Alexei, just for clarity, this is the proposed sequence for unlock:\n\nsevl\n1: wfe\nldaxrb w2, [x0]\nbic w2,w2,w1\nstlxrb w3, w2, [x0]\ncbnz w3, 1b\nret",
      "parentUuid": "122ae17a_f7da8381",
      "range": {
        "startLine": 104,
        "startChar": 1,
        "endLine": 107,
        "endChar": 12
      },
      "revId": "76269ade963ff61240452af691692bf411536e12",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a04ca3a5_c1b6db4d",
        "filename": "lib/locks/exclusive/aarch64/spinlock.S",
        "patchSetId": 3
      },
      "lineNbr": 107,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2024-03-25T14:50:55Z",
      "side": 1,
      "message": "ack, thanks. will leave open to resolve once patch is pushed (but feel free to resolve otherwise).",
      "parentUuid": "c76bf25f_d3f0eebe",
      "range": {
        "startLine": 104,
        "startChar": 1,
        "endLine": 107,
        "endChar": 12
      },
      "revId": "76269ade963ff61240452af691692bf411536e12",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0fb9e22f_b9b49106",
        "filename": "lib/locks/exclusive/aarch64/spinlock.S",
        "patchSetId": 3
      },
      "lineNbr": 107,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2024-03-27T11:48:33Z",
      "side": 1,
      "message": "since this is so much fun - CCA requires v9, which requires v8.1, which requires FEAT_LSE. with FEAT_LSE, we are guaranteed to have LDSETALB (atomic bit set acquire-release) and LDCLRALB (atomic bit set acquire-release) which we can use instead of the load acquire exclusive and store exclusive release.\nthat might save us a couple instructions.\nFeel free to ignore.\n\nSo something like this:\nacquire_lock:                           \n        mov     w8, #1                      \n        lsl     w8, w8, w1\n        sevl\n1:                               \n        wfe\n        ldsetalb        w8, w9, [x0]\n        tst     w8, w9\n        b.ne    1b\n        ret\n        \nrelease_lock:                        \n        mov     w8, #1                          \n        lsl     w8, w8, w1\n        ldclralb        w8, w8, [x0]\n        ret",
      "parentUuid": "a04ca3a5_c1b6db4d",
      "range": {
        "startLine": 104,
        "startChar": 1,
        "endLine": 107,
        "endChar": 12
      },
      "revId": "76269ade963ff61240452af691692bf411536e12",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "63ef3389_eb7f372b",
        "filename": "lib/locks/exclusive/aarch64/spinlock.S",
        "patchSetId": 3
      },
      "lineNbr": 107,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2024-03-28T09:53:52Z",
      "side": 1,
      "message": "Thanks Raghu for this pointer. Yes, indeed this could work and will be a good optimization. Since this does not have exclusive properties, we may have to couple it with regular exclusives to associate with send event for the wfe() (similar to the CASA lock). \n\nWe could guard it with #if ARM_ARCH_AT_LEAST(8, 1) to prevent older CPUs from compiling this code.",
      "parentUuid": "0fb9e22f_b9b49106",
      "range": {
        "startLine": 104,
        "startChar": 1,
        "endLine": 107,
        "endChar": 12
      },
      "revId": "76269ade963ff61240452af691692bf411536e12",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e4a605e5_9e66a513",
        "filename": "lib/locks/exclusive/aarch64/spinlock.S",
        "patchSetId": 3
      },
      "lineNbr": 107,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2024-03-28T12:39:20Z",
      "side": 1,
      "message": "ack. you’re right about the missing exclusive like casa. let me know if you want me to push a separate patch or if you want to do it right here.",
      "parentUuid": "63ef3389_eb7f372b",
      "range": {
        "startLine": 104,
        "startChar": 1,
        "endLine": 107,
        "endChar": 12
      },
      "revId": "76269ade963ff61240452af691692bf411536e12",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "644e6598_aaf7c6f8",
        "filename": "lib/locks/exclusive/aarch64/spinlock.S",
        "patchSetId": 3
      },
      "lineNbr": 107,
      "author": {
        "id": 1000105
      },
      "writtenOn": "2024-04-03T16:06:56Z",
      "side": 1,
      "message": "Although these LDSETALB \u0026 LDCLRALB instructions are atomic, they aren\u0027t exclusive.\nI pushed new patch with \u0027stlxrb\u0027 in bit_unlock.",
      "parentUuid": "e4a605e5_9e66a513",
      "range": {
        "startLine": 104,
        "startChar": 1,
        "endLine": 107,
        "endChar": 12
      },
      "revId": "76269ade963ff61240452af691692bf411536e12",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5dd38198_dca5f74e",
        "filename": "lib/locks/exclusive/aarch64/spinlock.S",
        "patchSetId": 3
      },
      "lineNbr": 107,
      "author": {
        "id": 1000105
      },
      "writtenOn": "2024-04-04T14:27:34Z",
      "side": 1,
      "message": "Shouldn\u0027t \u0027stlxrb\u0027 be used for bit_lock() as well? These functions differ only in set/clear bit.",
      "parentUuid": "644e6598_aaf7c6f8",
      "range": {
        "startLine": 104,
        "startChar": 1,
        "endLine": 107,
        "endChar": 12
      },
      "revId": "76269ade963ff61240452af691692bf411536e12",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1d3db4de_3985ed3b",
        "filename": "lib/locks/exclusive/aarch64/spinlock.S",
        "patchSetId": 3
      },
      "lineNbr": 107,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2024-04-07T13:40:44Z",
      "side": 1,
      "message": "TLDR; I don\u0027t believe it is strictly required, but that would be the more conservative approach, and would recommend that at this stage.\nFor a given lock acquire, only acquire semantics is required, and for releasing a lock, only release semantics is required (hence the names).  That is sufficient when we are doing traditional locks where we use the full byte/word for a single spin lock, but here we are using a single bit within a byte. I can\u0027t see why it wouldn\u0027t work here as well, since multiple threads wait on the bit value, instead of the entire byte/word value, but there can be no harm, other than some performance impact due to stronger barriers. This lock is likely highly contended, but is also security critical, so I would start with conservative approach, have some more analysis done (perhaps on the mailing list) and then optimize.",
      "parentUuid": "5dd38198_dca5f74e",
      "range": {
        "startLine": 104,
        "startChar": 1,
        "endLine": 107,
        "endChar": 12
      },
      "revId": "76269ade963ff61240452af691692bf411536e12",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3059a53b_37b6c6b9",
        "filename": "lib/locks/exclusive/aarch64/spinlock.S",
        "patchSetId": 3
      },
      "lineNbr": 107,
      "author": {
        "id": 1000105
      },
      "writtenOn": "2024-04-11T11:00:31Z",
      "side": 1,
      "message": "Proposed functions using atomic bit set/clear instructions:\n\n/*\n * Acquire bitlock using atomic bit set on byte.\n *\n * void bit_lock(bitlock_t *lock, uint8_t mask);\n */\nfunc bit_lock\n\tsevl\n1:\twfe\n\tldsetab\tw1, w2, [x0]\n\ttst\tw2, w1\n\tb.ne\t1b\n\tret\nendfunc bit_lock\n\n/*\n * Release bitlock previously acquired by bit_lock.\n *\n * void bit_unlock(bitlock_t *lock, uint8_t mask);\n */\nfunc bit_unlock\n\tstclrb\tw1, [x0]\n\tret\nendfunc bit_unlock",
      "parentUuid": "1d3db4de_3985ed3b",
      "range": {
        "startLine": 104,
        "startChar": 1,
        "endLine": 107,
        "endChar": 12
      },
      "revId": "76269ade963ff61240452af691692bf411536e12",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "086b916e_20401b2c",
        "filename": "lib/locks/exclusive/aarch64/spinlock.S",
        "patchSetId": 3
      },
      "lineNbr": 107,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2024-04-19T09:22:36Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "3059a53b_37b6c6b9",
      "range": {
        "startLine": 104,
        "startChar": 1,
        "endLine": 107,
        "endChar": 12
      },
      "revId": "76269ade963ff61240452af691692bf411536e12",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    }
  ]
}