{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "bf36ce23_78d592a2",
        "filename": "/COMMIT_MSG",
        "patchSetId": 21
      },
      "lineNbr": 9,
      "author": {
        "id": 1000098
      },
      "writtenOn": "2024-05-20T20:52:24Z",
      "side": 1,
      "message": "do you mean \"for\"? What I intend to ask is if EL3 should set this register for non-secure world if a supervisory software runs at NS-EL2.",
      "range": {
        "startLine": 9,
        "startChar": 43,
        "endLine": 9,
        "endChar": 45
      },
      "revId": "df5174f130d4c0822bedd9d6bde7ef92bf6e6cc1",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "975c773d_2e47c771",
        "filename": "/COMMIT_MSG",
        "patchSetId": 21
      },
      "lineNbr": 9,
      "author": {
        "id": 1000660
      },
      "writtenOn": "2024-05-21T11:16:24Z",
      "side": 1,
      "message": "Yes you are right. EL3 is initialising SCTLR_EL2 before the core exits to NS-EL2.",
      "parentUuid": "bf36ce23_78d592a2",
      "range": {
        "startLine": 9,
        "startChar": 43,
        "endLine": 9,
        "endChar": 45
      },
      "revId": "df5174f130d4c0822bedd9d6bde7ef92bf6e6cc1",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "dfaa10a0_ea49bf55",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 21
      },
      "lineNbr": 0,
      "author": {
        "id": 1000660
      },
      "writtenOn": "2024-05-18T12:11:52Z",
      "side": 1,
      "message": "Failed ones passed here : https://ci.trustedfirmware.org/job/tf-a-ci-gateway/73969/",
      "revId": "df5174f130d4c0822bedd9d6bde7ef92bf6e6cc1",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "dcb4ead9_7fe1896e",
        "filename": "lib/el3_runtime/aarch64/context_mgmt.c",
        "patchSetId": 21
      },
      "lineNbr": 47,
      "author": {
        "id": 1000098
      },
      "writtenOn": "2024-05-20T20:52:24Z",
      "side": 1,
      "message": "Hi Jayanth\nI am a bit confused. For which world are we trying to set SCTLR_EL2 value? From the commit message[1], I see we intend to configure SCTLR_EL2 for NWd(Normal World). Does it matter if the platform supports S-EL2 or not?\n\n[1] SCTLR_EL2 register needs to be initialised in non-secure world\nwhile we have a software component running at NS-EL2.",
      "revId": "df5174f130d4c0822bedd9d6bde7ef92bf6e6cc1",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "252495ec_8dd59cbb",
        "filename": "lib/el3_runtime/aarch64/context_mgmt.c",
        "patchSetId": 21
      },
      "lineNbr": 47,
      "author": {
        "id": 1000660
      },
      "writtenOn": "2024-05-21T11:16:24Z",
      "side": 1,
      "message": "Hi Madhu,\n\nWe have two scenarios here:\nI will explain both in brief. Kindly ignore it if its redundant.\n\nUltimately EL3 need to initialise the SCTLR_EL2 register when we have a software component at NS-EL2.\n\nNow, taking this into consideration, previously we had handled it in such a way that:\n\n* whenever we had SPMC_AT_SEL2(CTX_INCLUDE_EL2_REGS\u003d1), in these build configs, SCTLR_EL2 was getting initialised via the context. (Line no: 274 in setup_ns_context() API) and this value was getting restored into the SCTLR_EL2 register when we exit to NS-EL2 (cm_el2_sysregs_context_restore, line no: 1471). \n\n* When we did not had SPMC_AT_SEL2( or ...CTX_INCLUDE_EL2_REGS\u003d0)  in these build configs, SCTLR_EL2 was getting initiliased via SCTLR_EL1 in (cm_prepare_el3_exit) API.  The reasoning I could find here is, we dont have endianess value at the moment when we exit to NS-EL2. Hence they have tried to initilaise it via SCTLR_EL1 regsiter which was initialised by default irrespective of whether (CTX_INCLUDE_EL2_REGS\u003d0 Or 1).\n\nSo taking these into consideration and with the aim to decouple EL1 and EL2 context registers, I modified it in this way.\n\nTo answer the main part, \n``Does it matter if the platform supports S-EL2 or not?``\nYes. For systems where we have S-EL2, in this path, the code takes the following flow:\nvoid cm_prepare_el3_exit_ns(void) (line 1457), and in the other case it hits the api (cm_prepare_el3_exit), which has been modified here.\n\nHope this helps.",
      "parentUuid": "dcb4ead9_7fe1896e",
      "revId": "df5174f130d4c0822bedd9d6bde7ef92bf6e6cc1",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1d38e9e7_e4b09e8b",
        "filename": "lib/el3_runtime/aarch64/context_mgmt.c",
        "patchSetId": 21
      },
      "lineNbr": 47,
      "author": {
        "id": 1000098
      },
      "writtenOn": "2024-05-21T19:41:54Z",
      "side": 1,
      "message": "Acknowledged",
      "parentUuid": "252495ec_8dd59cbb",
      "revId": "df5174f130d4c0822bedd9d6bde7ef92bf6e6cc1",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5980817d_2245534c",
        "filename": "lib/el3_runtime/aarch64/context_mgmt.c",
        "patchSetId": 21
      },
      "lineNbr": 47,
      "author": {
        "id": 1000098
      },
      "writtenOn": "2024-05-21T19:41:54Z",
      "side": 1,
      "message": "Acknowledged",
      "parentUuid": "252495ec_8dd59cbb",
      "revId": "df5174f130d4c0822bedd9d6bde7ef92bf6e6cc1",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9def96f1_fbbb61c0",
        "filename": "lib/el3_runtime/aarch64/context_mgmt.c",
        "patchSetId": 21
      },
      "lineNbr": 309,
      "author": {
        "id": 1000098
      },
      "writtenOn": "2024-05-21T19:41:54Z",
      "side": 1,
      "message": "Does the entrypoint need to be in NS-EL2 to obtain info about the endianness of EL2? Can the entrypoint be in NS-EL1 rather than NS-EL2? for example, instead of uboot, platforms can choose to boot Linux kernel directly. I believe endianness doesn\u0027t change with EL but wanted to know your thoughts on this.",
      "range": {
        "startLine": 309,
        "startChar": 56,
        "endLine": 309,
        "endChar": 66
      },
      "revId": "df5174f130d4c0822bedd9d6bde7ef92bf6e6cc1",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "80be2ab6_ff22addb",
        "filename": "lib/el3_runtime/aarch64/context_mgmt.c",
        "patchSetId": 21
      },
      "lineNbr": 309,
      "author": {
        "id": 1000660
      },
      "writtenOn": "2024-06-03T12:03:48Z",
      "side": 1,
      "message": "Excuse me for the delayed response here. Somehow this comment got overlooked.\n\nIMO, we need entry point struct information to decide the endianness.\n\n```sctlr_elx \u003d (EP_GET_EE(ep-\u003eh.attr) !\u003d 0U) ? SCTLR_EE_BIT : 0UL;```\n\nThis logic remains the same for  NS-EL2 / EL1.\n\nSo, taking this into consideration we initialise SCTLR_EL2/EL1 register, depending on the exception where we run the non-secure image.\nYou are right, endianness won\u0027t change, it remains same either we run image at NS-EL1/EL2 as the logic checks for security state, (ep-\u003eh.attr), which is Non-secure in both cases.\n\nFurther, the existing implementation tries to initialise SCTLR_EL2 with SCTLR_EL1 value when we dont have a SPMC component at S-EL2 (or CTX_INCLUDE_EL2_REGS\u003d0).\n\nThe current change is aiming towards decoupling the EL2 dependency on EL1. Hence for build configs,\nwherein we have ( BL33 at NS-EL2, and no software component at S-EL2 ), for these configs, SCTLR2_EL2 initialisation is taken care explicitly in setup_ns_context API without relying on EL1 context.",
      "parentUuid": "9def96f1_fbbb61c0",
      "range": {
        "startLine": 309,
        "startChar": 56,
        "endLine": 309,
        "endChar": 66
      },
      "revId": "df5174f130d4c0822bedd9d6bde7ef92bf6e6cc1",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "dc2d050f_63fffcb8",
        "filename": "lib/el3_runtime/aarch64/context_mgmt.c",
        "patchSetId": 21
      },
      "lineNbr": 309,
      "author": {
        "id": 1000228
      },
      "writtenOn": "2024-06-03T14:21:00Z",
      "side": 1,
      "message": "\u003e when we dont have a SPMC component at S-EL2 (or CTX_INCLUDE_EL2_REGS\u003d0).\n\nCTX_INCLUDE_EL2_REGS isn\u0027t about S-EL2 use. It\u0027s about SPMD and RMMD saving/restoring EL2 system registers state prior to entering SPM or RMM.\n\nI\u0027m still missing the rationale for configuring the endianness when EL2 is present. It should normally be up to EL2 to configure any xxx_EL2 register?\nIs it because in order to eret into EL2 from EL3, that EL2 endianness must be setup beforehand?",
      "parentUuid": "80be2ab6_ff22addb",
      "range": {
        "startLine": 309,
        "startChar": 56,
        "endLine": 309,
        "endChar": 66
      },
      "revId": "df5174f130d4c0822bedd9d6bde7ef92bf6e6cc1",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e49e91b7_2643a75c",
        "filename": "lib/el3_runtime/aarch64/context_mgmt.c",
        "patchSetId": 21
      },
      "lineNbr": 314,
      "author": {
        "id": 1000098
      },
      "writtenOn": "2024-05-20T20:52:24Z",
      "side": 1,
      "message": "shouldn\u0027t the value of sctlr_el2_endian_val be set in the elif block? It will be consumed in line 1011 in either conditions right?",
      "revId": "df5174f130d4c0822bedd9d6bde7ef92bf6e6cc1",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2e1fd07b_453e8e12",
        "filename": "lib/el3_runtime/aarch64/context_mgmt.c",
        "patchSetId": 21
      },
      "lineNbr": 314,
      "author": {
        "id": 1000660
      },
      "writtenOn": "2024-05-21T11:16:24Z",
      "side": 1,
      "message": "Have explained in the other comment above.",
      "parentUuid": "e49e91b7_2643a75c",
      "revId": "df5174f130d4c0822bedd9d6bde7ef92bf6e6cc1",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1a280d84_2743fa1c",
        "filename": "lib/el3_runtime/aarch64/context_mgmt.c",
        "patchSetId": 21
      },
      "lineNbr": 314,
      "author": {
        "id": 1000098
      },
      "writtenOn": "2024-05-21T19:41:54Z",
      "side": 1,
      "message": "Acknowledged",
      "parentUuid": "2e1fd07b_453e8e12",
      "revId": "df5174f130d4c0822bedd9d6bde7ef92bf6e6cc1",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    }
  ]
}