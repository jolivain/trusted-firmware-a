{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "bf36ce23_78d592a2",
        "filename": "/COMMIT_MSG",
        "patchSetId": 21
      },
      "lineNbr": 9,
      "author": {
        "id": 1000098
      },
      "writtenOn": "2024-05-20T20:52:24Z",
      "side": 1,
      "message": "do you mean \"for\"? What I intend to ask is if EL3 should set this register for non-secure world if a supervisory software runs at NS-EL2.",
      "range": {
        "startLine": 9,
        "startChar": 43,
        "endLine": 9,
        "endChar": 45
      },
      "revId": "df5174f130d4c0822bedd9d6bde7ef92bf6e6cc1",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "975c773d_2e47c771",
        "filename": "/COMMIT_MSG",
        "patchSetId": 21
      },
      "lineNbr": 9,
      "author": {
        "id": 1000660
      },
      "writtenOn": "2024-05-21T11:16:24Z",
      "side": 1,
      "message": "Yes you are right. EL3 is initialising SCTLR_EL2 before the core exits to NS-EL2.",
      "parentUuid": "bf36ce23_78d592a2",
      "range": {
        "startLine": 9,
        "startChar": 43,
        "endLine": 9,
        "endChar": 45
      },
      "revId": "df5174f130d4c0822bedd9d6bde7ef92bf6e6cc1",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "dfaa10a0_ea49bf55",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 21
      },
      "lineNbr": 0,
      "author": {
        "id": 1000660
      },
      "writtenOn": "2024-05-18T12:11:52Z",
      "side": 1,
      "message": "Failed ones passed here : https://ci.trustedfirmware.org/job/tf-a-ci-gateway/73969/",
      "revId": "df5174f130d4c0822bedd9d6bde7ef92bf6e6cc1",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "dcb4ead9_7fe1896e",
        "filename": "lib/el3_runtime/aarch64/context_mgmt.c",
        "patchSetId": 21
      },
      "lineNbr": 47,
      "author": {
        "id": 1000098
      },
      "writtenOn": "2024-05-20T20:52:24Z",
      "side": 1,
      "message": "Hi Jayanth\nI am a bit confused. For which world are we trying to set SCTLR_EL2 value? From the commit message[1], I see we intend to configure SCTLR_EL2 for NWd(Normal World). Does it matter if the platform supports S-EL2 or not?\n\n[1] SCTLR_EL2 register needs to be initialised in non-secure world\nwhile we have a software component running at NS-EL2.",
      "revId": "df5174f130d4c0822bedd9d6bde7ef92bf6e6cc1",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "252495ec_8dd59cbb",
        "filename": "lib/el3_runtime/aarch64/context_mgmt.c",
        "patchSetId": 21
      },
      "lineNbr": 47,
      "author": {
        "id": 1000660
      },
      "writtenOn": "2024-05-21T11:16:24Z",
      "side": 1,
      "message": "Hi Madhu,\n\nWe have two scenarios here:\nI will explain both in brief. Kindly ignore it if its redundant.\n\nUltimately EL3 need to initialise the SCTLR_EL2 register when we have a software component at NS-EL2.\n\nNow, taking this into consideration, previously we had handled it in such a way that:\n\n* whenever we had SPMC_AT_SEL2(CTX_INCLUDE_EL2_REGS\u003d1), in these build configs, SCTLR_EL2 was getting initialised via the context. (Line no: 274 in setup_ns_context() API) and this value was getting restored into the SCTLR_EL2 register when we exit to NS-EL2 (cm_el2_sysregs_context_restore, line no: 1471). \n\n* When we did not had SPMC_AT_SEL2( or ...CTX_INCLUDE_EL2_REGS\u003d0)  in these build configs, SCTLR_EL2 was getting initiliased via SCTLR_EL1 in (cm_prepare_el3_exit) API.  The reasoning I could find here is, we dont have endianess value at the moment when we exit to NS-EL2. Hence they have tried to initilaise it via SCTLR_EL1 regsiter which was initialised by default irrespective of whether (CTX_INCLUDE_EL2_REGS\u003d0 Or 1).\n\nSo taking these into consideration and with the aim to decouple EL1 and EL2 context registers, I modified it in this way.\n\nTo answer the main part, \n``Does it matter if the platform supports S-EL2 or not?``\nYes. For systems where we have S-EL2, in this path, the code takes the following flow:\nvoid cm_prepare_el3_exit_ns(void) (line 1457), and in the other case it hits the api (cm_prepare_el3_exit), which has been modified here.\n\nHope this helps.",
      "parentUuid": "dcb4ead9_7fe1896e",
      "revId": "df5174f130d4c0822bedd9d6bde7ef92bf6e6cc1",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1d38e9e7_e4b09e8b",
        "filename": "lib/el3_runtime/aarch64/context_mgmt.c",
        "patchSetId": 21
      },
      "lineNbr": 47,
      "author": {
        "id": 1000098
      },
      "writtenOn": "2024-05-21T19:41:54Z",
      "side": 1,
      "message": "Acknowledged",
      "parentUuid": "252495ec_8dd59cbb",
      "revId": "df5174f130d4c0822bedd9d6bde7ef92bf6e6cc1",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5980817d_2245534c",
        "filename": "lib/el3_runtime/aarch64/context_mgmt.c",
        "patchSetId": 21
      },
      "lineNbr": 47,
      "author": {
        "id": 1000098
      },
      "writtenOn": "2024-05-21T19:41:54Z",
      "side": 1,
      "message": "Acknowledged",
      "parentUuid": "252495ec_8dd59cbb",
      "revId": "df5174f130d4c0822bedd9d6bde7ef92bf6e6cc1",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9def96f1_fbbb61c0",
        "filename": "lib/el3_runtime/aarch64/context_mgmt.c",
        "patchSetId": 21
      },
      "lineNbr": 309,
      "author": {
        "id": 1000098
      },
      "writtenOn": "2024-05-21T19:41:54Z",
      "side": 1,
      "message": "Does the entrypoint need to be in NS-EL2 to obtain info about the endianness of EL2? Can the entrypoint be in NS-EL1 rather than NS-EL2? for example, instead of uboot, platforms can choose to boot Linux kernel directly. I believe endianness doesn\u0027t change with EL but wanted to know your thoughts on this.",
      "range": {
        "startLine": 309,
        "startChar": 56,
        "endLine": 309,
        "endChar": 66
      },
      "revId": "df5174f130d4c0822bedd9d6bde7ef92bf6e6cc1",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "80be2ab6_ff22addb",
        "filename": "lib/el3_runtime/aarch64/context_mgmt.c",
        "patchSetId": 21
      },
      "lineNbr": 309,
      "author": {
        "id": 1000660
      },
      "writtenOn": "2024-06-03T12:03:48Z",
      "side": 1,
      "message": "Excuse me for the delayed response here. Somehow this comment got overlooked.\n\nIMO, we need entry point struct information to decide the endianness.\n\n```sctlr_elx \u003d (EP_GET_EE(ep-\u003eh.attr) !\u003d 0U) ? SCTLR_EE_BIT : 0UL;```\n\nThis logic remains the same for  NS-EL2 / EL1.\n\nSo, taking this into consideration we initialise SCTLR_EL2/EL1 register, depending on the exception where we run the non-secure image.\nYou are right, endianness won\u0027t change, it remains same either we run image at NS-EL1/EL2 as the logic checks for security state, (ep-\u003eh.attr), which is Non-secure in both cases.\n\nFurther, the existing implementation tries to initialise SCTLR_EL2 with SCTLR_EL1 value when we dont have a SPMC component at S-EL2 (or CTX_INCLUDE_EL2_REGS\u003d0).\n\nThe current change is aiming towards decoupling the EL2 dependency on EL1. Hence for build configs,\nwherein we have ( BL33 at NS-EL2, and no software component at S-EL2 ), for these configs, SCTLR2_EL2 initialisation is taken care explicitly in setup_ns_context API without relying on EL1 context.",
      "parentUuid": "9def96f1_fbbb61c0",
      "range": {
        "startLine": 309,
        "startChar": 56,
        "endLine": 309,
        "endChar": 66
      },
      "revId": "df5174f130d4c0822bedd9d6bde7ef92bf6e6cc1",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "dc2d050f_63fffcb8",
        "filename": "lib/el3_runtime/aarch64/context_mgmt.c",
        "patchSetId": 21
      },
      "lineNbr": 309,
      "author": {
        "id": 1000228
      },
      "writtenOn": "2024-06-03T14:21:00Z",
      "side": 1,
      "message": "\u003e when we dont have a SPMC component at S-EL2 (or CTX_INCLUDE_EL2_REGS\u003d0).\n\nCTX_INCLUDE_EL2_REGS isn\u0027t about S-EL2 use. It\u0027s about SPMD and RMMD saving/restoring EL2 system registers state prior to entering SPM or RMM.\n\nI\u0027m still missing the rationale for configuring the endianness when EL2 is present. It should normally be up to EL2 to configure any xxx_EL2 register?\nIs it because in order to eret into EL2 from EL3, that EL2 endianness must be setup beforehand?",
      "parentUuid": "80be2ab6_ff22addb",
      "range": {
        "startLine": 309,
        "startChar": 56,
        "endLine": 309,
        "endChar": 66
      },
      "revId": "df5174f130d4c0822bedd9d6bde7ef92bf6e6cc1",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c9f7e14b_baa4b0e2",
        "filename": "lib/el3_runtime/aarch64/context_mgmt.c",
        "patchSetId": 21
      },
      "lineNbr": 309,
      "author": {
        "id": 1000660
      },
      "writtenOn": "2024-06-03T18:44:55Z",
      "side": 1,
      "message": "\u003e CTX_INCLUDE_EL2_REGS isn\u0027t about S-EL2 use. It\u0027s about SPMD and RMMD saving/restoring EL2 system registers state prior to entering SPM or RMM.\n\nCompletely agree olivier. I was trying to comment from the code point of view wherein when CTX_INCLUDE_EL2_REGS\u003d0,  my change would get applied.\n\nIs it because in order to eret into EL2 from EL3, that EL2 endianness must be setup beforehand?\n\u003e I believe the same as at least from the code what we have at NS-EL2 (tf-a-tests), I dont see ```SCTLR_EE_BIT``` (getting set or being tested). Havent done the negative testing wherein If I remove this part and leave it for EL2 software component to initialise it.",
      "parentUuid": "dc2d050f_63fffcb8",
      "range": {
        "startLine": 309,
        "startChar": 56,
        "endLine": 309,
        "endChar": 66
      },
      "revId": "df5174f130d4c0822bedd9d6bde7ef92bf6e6cc1",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "68036f62_6cbb40db",
        "filename": "lib/el3_runtime/aarch64/context_mgmt.c",
        "patchSetId": 21
      },
      "lineNbr": 309,
      "author": {
        "id": 1000228
      },
      "writtenOn": "2024-06-04T10:48:23Z",
      "side": 1,
      "message": "On the second part, I\u0027m challenging the case about when EL2 implemented (and EL3 eret to EL2), then SCTLR_EL2 may not require an explicit initialisation from EL3 (apart from bits marked unknown at reset and deserving to apply a default value). I\u0027m not sure if setting the EE bit really is a special case. AFAIU this impact the way the CPU gets data from memory so EL2 probably needs to set the bit as early as possible before loading any data but I\u0027m not sure it justifies EL3 taking care of it.\n\n\u003e I dont see SCTLR_EE_BIT (getting set or being tested). \n\nYes this is probably a test gap.",
      "parentUuid": "c9f7e14b_baa4b0e2",
      "range": {
        "startLine": 309,
        "startChar": 56,
        "endLine": 309,
        "endChar": 66
      },
      "revId": "df5174f130d4c0822bedd9d6bde7ef92bf6e6cc1",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "96bcafbc_7c64264b",
        "filename": "lib/el3_runtime/aarch64/context_mgmt.c",
        "patchSetId": 21
      },
      "lineNbr": 309,
      "author": {
        "id": 1000102
      },
      "writtenOn": "2024-06-06T11:27:53Z",
      "side": 1,
      "message": "On whether to initialise SCTLR_EL2.EE bit?\nI would assume that any sane EL2 SW would set this bit early on. We can\u0027t rely on what tf-a-test does but should look at standard SWs running at EL2.\nHaving said that, the data structure we use in TF-A ep-\u003eh.attr provides EE info which means that EL3 would consume it. I would assume that it was to support legacy SWs (mostly starting at EL1) which do not initialise SCTLR_EL1.EE and it would have carried to EL2 as well (copying SCTLR_EL2 from SCTLR_EL1 value).\n\nWe can do an experiment where we just initialise SCTLR_EL2 with RESET value and run the CI to see how many tests failed.",
      "parentUuid": "68036f62_6cbb40db",
      "range": {
        "startLine": 309,
        "startChar": 56,
        "endLine": 309,
        "endChar": 66
      },
      "revId": "df5174f130d4c0822bedd9d6bde7ef92bf6e6cc1",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c9ca8a4b_6393e258",
        "filename": "lib/el3_runtime/aarch64/context_mgmt.c",
        "patchSetId": 21
      },
      "lineNbr": 309,
      "author": {
        "id": 1000660
      },
      "writtenOn": "2024-06-06T15:58:25Z",
      "side": 1,
      "message": "As insisted by @Manish P, I experimented with a trivial patch to check whether there are any CI failures, without endianness initialization. \n```Patch: ```: https://review.trustedfirmware.org/c/TF-A/trusted-firmware-a/+/29240\n```CI+2 (PASS)```: https://ci.trustedfirmware.org/job/tf-a-gerrit-tforg-l2/2214/\n```L3 jobs (PASS)```: https://ci.trustedfirmware.org/job/tf-a-ci-gateway/75321/\n\n\nSo, this portion of code, (endianness initialization) might have been introduced for supporting legacy cases EL1.  \n\nLet me know your thoughts here. Shall I remove the endianness init portion?",
      "parentUuid": "96bcafbc_7c64264b",
      "range": {
        "startLine": 309,
        "startChar": 56,
        "endLine": 309,
        "endChar": 66
      },
      "revId": "df5174f130d4c0822bedd9d6bde7ef92bf6e6cc1",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6e30c6f1_a514272d",
        "filename": "lib/el3_runtime/aarch64/context_mgmt.c",
        "patchSetId": 21
      },
      "lineNbr": 309,
      "author": {
        "id": 1000744
      },
      "writtenOn": "2024-06-11T10:11:35Z",
      "side": 1,
      "message": "Fwiw the kernel overrides SCTLR_ELx_EE in it\u0027s low level init code [1]. The picture in u-boot is less clear. From what I\u0027ve been able to find, the only reference to SCTLR_EL2_EE, is in a macro used by the SPL when switching from EL3 to EL2 [2]. This defaults to little-endian mode, and makes no effort to validate this value.\n\n[1] https://github.com/torvalds/linux/blob/master/arch/arm64/kernel/head.S#L153\n[2] https://github.com/u-boot/u-boot/blob/master/arch/arm/include/asm/macro.h#L171",
      "parentUuid": "c9ca8a4b_6393e258",
      "range": {
        "startLine": 309,
        "startChar": 56,
        "endLine": 309,
        "endChar": 66
      },
      "revId": "df5174f130d4c0822bedd9d6bde7ef92bf6e6cc1",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c28cb3f2_8fae46a1",
        "filename": "lib/el3_runtime/aarch64/context_mgmt.c",
        "patchSetId": 21
      },
      "lineNbr": 309,
      "author": {
        "id": 1000102
      },
      "writtenOn": "2024-06-11T13:33:06Z",
      "side": 1,
      "message": "I had a discussion with folks from linux, u-boot and edk2.\n- Linux does sets SCTLR_ELx.EE early on\n- U-Boot assumes it\u0027s entered in LE mode and executes in the mode. There was some idea earlier but that was discarded https://source.denx.de/u-boot/u-boot/-/commit/68f08966b0d07b5d9cd\n- edk2 in one boot path inits in LE while in other it does not and assumes it is running in LE. https://github.com/tianocore/edk2/blob/master/ArmPlatformPkg/PrePeiCore/AArch64/Helper.S#L22\nhttps://github.com/tianocore/edk2/blob/master/ArmPlatformPkg/PrePi/AArch64/ModuleEntryPoint.S\n\nGoing forward what should we do in TF-A ? \n- entry_point_info.header.attr not necessarily is endianness, we have just used it for this purpose.\n- TF-A should assume that following stage executes in LE mode (set EE to 0)\n- Make a request to U-boot/edk2 to set EE bit explicitly (early on)",
      "parentUuid": "6e30c6f1_a514272d",
      "range": {
        "startLine": 309,
        "startChar": 56,
        "endLine": 309,
        "endChar": 66
      },
      "revId": "df5174f130d4c0822bedd9d6bde7ef92bf6e6cc1",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e6c5f902_3cd6b495",
        "filename": "lib/el3_runtime/aarch64/context_mgmt.c",
        "patchSetId": 21
      },
      "lineNbr": 309,
      "author": {
        "id": 1000660
      },
      "writtenOn": "2024-06-11T15:12:23Z",
      "side": 1,
      "message": "Thanks @Harrison and @Manish for sharing these updates.\nI will modify the patch, wherein the SCTLR_EL2 will be initialised with the default reset value (EE\u003d0) and remove the endianess evaluation portion.",
      "parentUuid": "c28cb3f2_8fae46a1",
      "range": {
        "startLine": 309,
        "startChar": 56,
        "endLine": 309,
        "endChar": 66
      },
      "revId": "df5174f130d4c0822bedd9d6bde7ef92bf6e6cc1",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bde1b32b_8b77e075",
        "filename": "lib/el3_runtime/aarch64/context_mgmt.c",
        "patchSetId": 21
      },
      "lineNbr": 309,
      "author": {
        "id": 1000228
      },
      "writtenOn": "2024-06-13T14:13:20Z",
      "side": 1,
      "message": "Thanks all for investigating! Happy with the change, I guess this comment can be resolved now.",
      "parentUuid": "e6c5f902_3cd6b495",
      "range": {
        "startLine": 309,
        "startChar": 56,
        "endLine": 309,
        "endChar": 66
      },
      "revId": "df5174f130d4c0822bedd9d6bde7ef92bf6e6cc1",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e49e91b7_2643a75c",
        "filename": "lib/el3_runtime/aarch64/context_mgmt.c",
        "patchSetId": 21
      },
      "lineNbr": 314,
      "author": {
        "id": 1000098
      },
      "writtenOn": "2024-05-20T20:52:24Z",
      "side": 1,
      "message": "shouldn\u0027t the value of sctlr_el2_endian_val be set in the elif block? It will be consumed in line 1011 in either conditions right?",
      "revId": "df5174f130d4c0822bedd9d6bde7ef92bf6e6cc1",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2e1fd07b_453e8e12",
        "filename": "lib/el3_runtime/aarch64/context_mgmt.c",
        "patchSetId": 21
      },
      "lineNbr": 314,
      "author": {
        "id": 1000660
      },
      "writtenOn": "2024-05-21T11:16:24Z",
      "side": 1,
      "message": "Have explained in the other comment above.",
      "parentUuid": "e49e91b7_2643a75c",
      "revId": "df5174f130d4c0822bedd9d6bde7ef92bf6e6cc1",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1a280d84_2743fa1c",
        "filename": "lib/el3_runtime/aarch64/context_mgmt.c",
        "patchSetId": 21
      },
      "lineNbr": 314,
      "author": {
        "id": 1000098
      },
      "writtenOn": "2024-05-21T19:41:54Z",
      "side": 1,
      "message": "Acknowledged",
      "parentUuid": "2e1fd07b_453e8e12",
      "revId": "df5174f130d4c0822bedd9d6bde7ef92bf6e6cc1",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    }
  ]
}