{
  "comments": [
    {
      "key": {
        "uuid": "93bccab5_67a5ac6c",
        "filename": "plat/rpi/common/aarch64/plat_helpers.S",
        "patchSetId": 1
      },
      "lineNbr": 95,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2020-03-24T16:02:44Z",
      "side": 1,
      "message": "not sure i see the problem. Can you elaborate ? If the go condition is set by another PE, presumably it also executed an SEV. The WFE on this PE should consume it. What is the race condition here ?",
      "revId": "03bb779ea886f2ee221b3df8c4acf110db931caa",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "63e31591_24f00733",
        "filename": "plat/rpi/common/aarch64/plat_helpers.S",
        "patchSetId": 1
      },
      "lineNbr": 95,
      "author": {
        "id": 1000353
      },
      "writtenOn": "2020-03-25T04:02:31Z",
      "side": 1,
      "message": "If you look at https://github.com/andreiw/lampone-tf-a/commit/a7b6f7f5bb513a91738cf7cf5390cebdecd58541#diff-5a58b5ad8f4bf97eb9a36c54f18229afR86, here is what my thought process was. It was a flawed thought process\n\n- plat_wait_for_warm_boot runs on BSP in response to PSCI CPU_OFF\n- PSCI CPU_ON may occur asynchronously while BSP is executing plat_wait_for_warm_boot. Because the SEV from CPU_ON may come any time before plat_wait_for_warm_boot, I thought I couldn\u0027t rely on WFE on picking up that state (perhaps it got eaten earlier somewhere), hence the sevl + wfe in that code.\n\nIn practice there was no point, because the mailbox gets cleared with PLAT_RPI3_TM_HOLD_STATE_WAIT right above. So on a race between CPU_ON and BSP acting out the CPU_OFF, CPU_ON could fail.\n\nMy recommendation is to skip reordering wfe+ldr. Also, change the CPU_ON code to _wait_ for HOLD_STATE_WAIT iff core \u003d\u003d BSP and previous state was PLAT_RPI3_TM_HOLD_STATE_BSP_OFF. Well, that\u0027s in the next patch. So I suppose this whole patch can just be deleted.",
      "parentUuid": "93bccab5_67a5ac6c",
      "revId": "03bb779ea886f2ee221b3df8c4acf110db931caa",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "847d02f6_7c5353cd",
        "filename": "plat/rpi/common/aarch64/plat_helpers.S",
        "patchSetId": 1
      },
      "lineNbr": 95,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2020-03-25T21:24:53Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "63e31591_24f00733",
      "revId": "03bb779ea886f2ee221b3df8c4acf110db931caa",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ed11fad7_2a3c2281",
        "filename": "plat/rpi/common/aarch64/plat_helpers.S",
        "patchSetId": 1
      },
      "lineNbr": 95,
      "author": {
        "id": 1000118
      },
      "writtenOn": "2020-03-26T16:20:13Z",
      "side": 1,
      "message": "OK, so those kind of race conditions can get tricky, so maybe people can confirm:\n- There is a benign race here between a CPU_OFF and a CPU_ON on another core. And there is not much we can do about it. If an OS tries to do something stupid, we can\u0027t help it, it can\u0027t expect a particular action to win.\n- This patch indeed doesn\u0027t change that (it can\u0027t). A \"GO\" write will always be followed by a SEV, whether this happens before or after the WFE doesn\u0027t matter. In the first case (SEV before WFE), the WFE should return immediately. I think this would make it clear that this patch doesn\u0027t help.\n\nIf people can confirm, I will drop this patch.",
      "parentUuid": "847d02f6_7c5353cd",
      "revId": "03bb779ea886f2ee221b3df8c4acf110db931caa",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    }
  ]
}