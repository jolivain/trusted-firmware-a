{
  "comments": [
    {
      "key": {
        "uuid": "479e641f_f206e8d4",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 21,
      "author": {
        "id": 1000105
      },
      "writtenOn": "2021-01-22T14:50:37Z",
      "side": 1,
      "message": "The brackets are required to supress Coverity scan warnings.",
      "revId": "f4eb605a89857c65d255786cb43b3c13642ed22e",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9ee64376_85506dc9",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 21,
      "author": {
        "id": 1000372
      },
      "writtenOn": "2021-01-25T01:44:57Z",
      "side": 1,
      "message": "What are the warnings in details? Is it integer overflow? But int_id starts from MIN_ESPI_ID so it is obvious to be non-negative by subtracting MIN_ESPI_ID.",
      "parentUuid": "479e641f_f206e8d4",
      "revId": "f4eb605a89857c65d255786cb43b3c13642ed22e",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b8146ce9_dec67080",
        "filename": "include/drivers/arm/gicv3.h",
        "patchSetId": 2
      },
      "lineNbr": 59,
      "author": {
        "id": 1000105
      },
      "writtenOn": "2021-01-22T14:49:20Z",
      "side": 1,
      "message": "I would suggest to use\n#define TOTAL_SPI_NUM_ALIGNED\t((TOTAL_SPI_INTR_NUM + U(31)) \u0026 U(~31))\nand add comment about 32 bytes alignment instead of \"not well aligned\"\n\nIn giv3.h TOTAL_SHARED_INTR_NUM is used as aligned for:\n#define GICD_NUM_REGS(reg_name)\t\\\n\tDIV_ROUND_UP_2EVAL(TOTAL_SHARED_INTR_NUM, (1 \u003c\u003c reg_name##_SHIFT))\nbut not aligned for\n\tuint64_t gicd_irouter[TOTAL_SHARED_INTR_NUM];\nWould it be better to just use aligned value for the array above?",
      "revId": "f4eb605a89857c65d255786cb43b3c13642ed22e",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "edb36aa6_43db8452",
        "filename": "include/drivers/arm/gicv3.h",
        "patchSetId": 2
      },
      "lineNbr": 59,
      "author": {
        "id": 1000372
      },
      "writtenOn": "2021-01-25T01:44:57Z",
      "side": 1,
      "message": "\u003e I would suggest to use\n\u003e #define TOTAL_SPI_NUM_ALIGNED\t((TOTAL_SPI_INTR_NUM + U(31)) \u0026 U(~31))\n\u003e and add comment about 32 bytes alignment instead of \"not well aligned\"\n\nOriginally I used round_up() to get the 32 aligned value of TOTAL_SPI_INTR_NUM, but I finally chose the above code. Though it seems more generic to calculate TOTAL_SPI_NUM_ALIGNED from TOTAL_SPI_INTR_NUM, we still have lots of preconditions to make the code work, so I chose the straight forward one.\n\nAnyway, I\u0027m not insisting on this and I can change the code as you suggest.\n\n\u003e \n\u003e In giv3.h TOTAL_SHARED_INTR_NUM is used as aligned for:\n\u003e #define GICD_NUM_REGS(reg_name)\t\\\n\u003e \tDIV_ROUND_UP_2EVAL(TOTAL_SHARED_INTR_NUM, (1 \u003c\u003c reg_name##_SHIFT))\n\u003e but not aligned for\n\u003e \tuint64_t gicd_irouter[TOTAL_SHARED_INTR_NUM];\n\u003e Would it be better to just use aligned value for the array above?\n\nI don\u0027t see strong reason for this change. For ESPI enabled, TOTAL_SHARED_INTR_NUM comes from (TOTAL_SPI_NUM_ALIGNED + TOTAL_ESPI_INTR_NUM), which is already aligned. Do you mean round up TOTAL_SHARED_INTR_NUM as well for ESPI disabled?",
      "parentUuid": "b8146ce9_dec67080",
      "revId": "f4eb605a89857c65d255786cb43b3c13642ed22e",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3f7b05ca_dde32737",
        "filename": "include/drivers/arm/gicv3.h",
        "patchSetId": 2
      },
      "lineNbr": 59,
      "author": {
        "id": 1000105
      },
      "writtenOn": "2021-01-25T11:03:06Z",
      "side": 1,
      "message": "GICD_IROUTER(E) are 64-bit registers:\nuint64_t gicd_irouter[TOTAL_SHARED_INTR_NUM];\nwith IROUTER_SHIFT \u003d 0.\nPlease explain why it \"will cause trouble when saving and restoring GICD context with registers\" in \"shifting operation in RESTORE/SAVE_GICD_EREGS\"",
      "parentUuid": "edb36aa6_43db8452",
      "revId": "f4eb605a89857c65d255786cb43b3c13642ed22e",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e277bb31_630d2398",
        "filename": "include/drivers/arm/gicv3.h",
        "patchSetId": 2
      },
      "lineNbr": 59,
      "author": {
        "id": 1000372
      },
      "writtenOn": "2021-01-25T12:11:22Z",
      "side": 1,
      "message": "It is OK for gicd_irouter, for IROUTER_SHIFT \u003d 0 just as you mentioned. But it will trigger bug for registers with REG#R_SHIFT larger than 2. Shall I change the comments to mention this?",
      "parentUuid": "3f7b05ca_dde32737",
      "revId": "f4eb605a89857c65d255786cb43b3c13642ed22e",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "90fbe22d_5193b290",
        "filename": "include/drivers/arm/gicv3.h",
        "patchSetId": 2
      },
      "lineNbr": 59,
      "author": {
        "id": 1000105
      },
      "writtenOn": "2021-01-27T09:31:17Z",
      "side": 1,
      "message": "1. TOTAL_SPI_INTR_NUM is defined in gic_common.h as:\n#define TOTAL_SPI_INTR_NUM\t(MAX_SPI_ID - MIN_SPI_ID + U(1))\n\n2. TOTAL_SPI_INTR_NUM is used in 2 places in giv3.h to define TOTAL_SHARED_INTR_NUM:\na) on line #51:\n/* Total number of GICv3.1 SPIs and ESPIs */\n#define\tTOTAL_SHARED_INTR_NUM\t(TOTAL_SPI_INTR_NUM + TOTAL_ESPI_INTR_NUM)\nb) on line #69:\n/* Total number of GICv3 SPIs */\n#define\tTOTAL_SHARED_INTR_NUM\tTOTAL_SPI_INTR_NUM\n\n3. TOTAL_SHARED_INTR_NUM is used in\na) gic_v3.h line #458: \n\t/* 64 bits registers */\n\tuint64_t gicd_irouter[TOTAL_SHARED_INTR_NUM];\nand won\u0027t cause a problem as you mentioned above.\nb) gic_v3.h line #379:\n/*\n * This macro returns the total number of GICD/GICR registers corresponding to\n * the register name\n */\n#define GICD_NUM_REGS(reg_name)\t\\\n\tDIV_ROUND_UP_2EVAL(TOTAL_SHARED_INTR_NUM, (1 \u003c\u003c reg_name##_SHIFT))\n\nThis macro returns (1 \u003c\u003c reg_name##_SHIFT) bytes aligned value of TOTAL_SHARED_INTR_NUM, which used to define number of other than IROUTER registers, see lines #462-469:\n\tuint32_t gicd_igroupr[GICD_NUM_REGS(IGROUPR)];\n\tuint32_t gicd_isenabler[GICD_NUM_REGS(ISENABLER)];\n\tuint32_t gicd_ispendr[GICD_NUM_REGS(ISPENDR)];\n\tuint32_t gicd_isactiver[GICD_NUM_REGS(ISACTIVER)];\n\tuint32_t gicd_ipriorityr[GICD_NUM_REGS(IPRIORITYR)];\n\tuint32_t gicd_icfgr[GICD_NUM_REGS(ICFGR)];\n\tuint32_t gicd_igrpmodr[GICD_NUM_REGS(IGRPMODR)];\n\tuint32_t gicd_nsacr[GICD_NUM_REGS(NSACR)];\n\nAs the number of elements in each array is aligned to (1 \u003c\u003c reg_name##_SHIFT) bytes, will it cause an issue when saving/storing them?",
      "parentUuid": "e277bb31_630d2398",
      "revId": "f4eb605a89857c65d255786cb43b3c13642ed22e",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d0f3b431_c9ae8fbc",
        "filename": "include/drivers/arm/gicv3.h",
        "patchSetId": 2
      },
      "lineNbr": 83,
      "author": {
        "id": 1000105
      },
      "writtenOn": "2021-01-22T14:49:20Z",
      "side": 1,
      "message": "Should this TOTAL_SHARED_INTR_NUM be also aligned for GIC v3?",
      "revId": "f4eb605a89857c65d255786cb43b3c13642ed22e",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bb889479_da3b5025",
        "filename": "include/drivers/arm/gicv3.h",
        "patchSetId": 2
      },
      "lineNbr": 83,
      "author": {
        "id": 1000372
      },
      "writtenOn": "2021-01-25T01:44:57Z",
      "side": 1,
      "message": "I don\u0027t think so; only the last block is possible to be not 32 INT ID aligned (992 ~ 1019), so the current code will only cause the context of 1020~1023 to be unsaved, when the reg_name##_SHIFT is less than or equal to 2. Unless it is necessary to save the context of spurious interrupts, it should be all right for GICv3 without ESPI implementation.",
      "parentUuid": "d0f3b431_c9ae8fbc",
      "revId": "f4eb605a89857c65d255786cb43b3c13642ed22e",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    }
  ]
}