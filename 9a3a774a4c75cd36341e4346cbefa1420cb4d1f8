{
  "comments": [
    {
      "key": {
        "uuid": "eae8b15e_81fe399c",
        "filename": "plat/arm/board/fvp/fconf/fconf_hw_config_getter.c",
        "patchSetId": 5
      },
      "lineNbr": 55,
      "author": {
        "id": 1000118
      },
      "writtenOn": "2020-05-06T01:14:18Z",
      "side": 1,
      "message": "You can actually pass both \u0026addr and \u0026size in one function call. I just made both optional, since typically only the base address is interesting.\nWhich brings me to the more important question: Why do we read all those values? The size of the register region is architected in the GICv3 spec, it\u0027s just in the DT because \"reg\" is a generic DT property and always contains the size.",
      "revId": "9a3a774a4c75cd36341e4346cbefa1420cb4d1f8",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b7169dbd_c1f1b338",
        "filename": "plat/arm/board/fvp/fconf/fconf_hw_config_getter.c",
        "patchSetId": 5
      },
      "lineNbr": 55,
      "author": {
        "id": 1000101
      },
      "writtenOn": "2020-05-06T15:52:14Z",
      "side": 1,
      "message": "Definitely agree with the single function call, but if the additional information is not necessary then I agree it can just be removed.",
      "parentUuid": "eae8b15e_81fe399c",
      "revId": "9a3a774a4c75cd36341e4346cbefa1420cb4d1f8",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f0896e90_82c19b25",
        "filename": "plat/arm/board/fvp/fconf/fconf_hw_config_getter.c",
        "patchSetId": 5
      },
      "lineNbr": 75,
      "author": {
        "id": 1000118
      },
      "writtenOn": "2020-05-06T01:14:18Z",
      "side": 1,
      "message": "First: those indices \u003e 1 are optional, and they only exist if the GIC supports GICv2 compatibility mode. This is further limited by the CPU cores being required to support the GICv2 CPU interface, which recent CPU cores from Arm Ltd. do *not* do anymore (I think anything supporting \u003e\u003d v8.2). So any failure here must not be fatal, or the code will fail on any halfway recent system.\nSecondly: What do we need those values for? TF-A has definitely no interest whatsoever in those registers, especially not index 3 and 4, which are purely virtualisation related.\nSo why do we store those values at all?\n\nMy point is that there is no need for this whole patch, as all relevant information (GICD and GICR base) is already read by the current code.",
      "revId": "9a3a774a4c75cd36341e4346cbefa1420cb4d1f8",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3ccdbb85_dfb084fe",
        "filename": "plat/arm/board/fvp/fconf/fconf_hw_config_getter.c",
        "patchSetId": 5
      },
      "lineNbr": 75,
      "author": {
        "id": 1000101
      },
      "writtenOn": "2020-05-06T15:52:14Z",
      "side": 1,
      "message": "I had added the additional information for completeness and to future proof, but if as you\u0027re saying they are not needed for TF-A I will remove.",
      "parentUuid": "f0896e90_82c19b25",
      "revId": "9a3a774a4c75cd36341e4346cbefa1420cb4d1f8",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7d056e4a_526ab5f0",
        "filename": "plat/arm/board/fvp/fconf/fconf_hw_config_getter.c",
        "patchSetId": 5
      },
      "lineNbr": 131,
      "author": {
        "id": 1000118
      },
      "writtenOn": "2020-05-06T01:14:18Z",
      "side": 1,
      "message": "Why do we need the interrupt number? This is the GIC maintenance interrupt, only interesting for a hypervisor. TF-A does not have any use for that.",
      "revId": "9a3a774a4c75cd36341e4346cbefa1420cb4d1f8",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "95641275_267b117e",
        "filename": "plat/arm/board/fvp/fconf/fconf_hw_config_getter.c",
        "patchSetId": 5
      },
      "lineNbr": 131,
      "author": {
        "id": 1000101
      },
      "writtenOn": "2020-05-06T15:52:14Z",
      "side": 1,
      "message": "I will remove, I didn\u0027t realize this was exclusively used by the hypervisor",
      "parentUuid": "7d056e4a_526ab5f0",
      "revId": "9a3a774a4c75cd36341e4346cbefa1420cb4d1f8",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "505731ae_5caf3b72",
        "filename": "plat/arm/board/fvp/include/fconf_hw_config_getter.h",
        "patchSetId": 5
      },
      "lineNbr": 28,
      "author": {
        "id": 1000101
      },
      "writtenOn": "2020-05-06T15:52:14Z",
      "side": 1,
      "message": "Hi Andre, I was wondering if the uintptr_t should be changed to uint64_t since the base registers are 64 bits or if you had kept generic for A32 possibly?  Just wondering if this is worth changing or if it should remain uintptr_t. Thanks!",
      "range": {
        "startLine": 28,
        "startChar": 1,
        "endLine": 28,
        "endChar": 9
      },
      "revId": "9a3a774a4c75cd36341e4346cbefa1420cb4d1f8",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "91220714_920d1af2",
        "filename": "plat/arm/board/fvp/include/fconf_hw_config_getter.h",
        "patchSetId": 5
      },
      "lineNbr": 28,
      "author": {
        "id": 1000118
      },
      "writtenOn": "2020-05-06T16:06:04Z",
      "side": 1,
      "message": "That\u0027s a bit tricky indeed. The actual size of that value is dictated by the DTB provided, so can\u0027t be determined at compile time. It is legitimate to use any size (32-bit or 64-bit) in the DT, regardless of the underlying architecture.\nBut at the end of the day you need a physical MMIO address to actually use that device, which would limit it again to uintptr_t, or more precisely, phys_addr_t. I don\u0027t think TF-A cares about the latter, though.\nSo uint64_t sounds like the safest and more robust, but not sure how MISRA likes that when you compile for AArch32. Also you might run into trouble when later using that value, since you probably assign it to an uinptr_t variable or use it as an uintptr_t function argument.\n\nIf you really want to be paranoid, I think we should have a generic function that handles addresses, something like uintptr_t check_address(uint64_t addr). This would then check the upper word on AArch32 to be 0, failing otherwise. This should appease MISRA in this respect.",
      "parentUuid": "505731ae_5caf3b72",
      "range": {
        "startLine": 28,
        "startChar": 1,
        "endLine": 28,
        "endChar": 9
      },
      "revId": "9a3a774a4c75cd36341e4346cbefa1420cb4d1f8",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    }
  ]
}