{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "e34d70e6_66c87367",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 46
      },
      "lineNbr": 0,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2023-07-24T17:19:39Z",
      "side": 1,
      "message": "Revoking the score due to issues reported by James.",
      "revId": "9c776a9dc19b7ad43f63474677bb978d46e98b13",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f0296900_61174333",
        "filename": "bl31/aarch64/ea_delegate.S",
        "patchSetId": 46
      },
      "lineNbr": 215,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2023-07-24T17:19:39Z",
      "side": 1,
      "message": "Populating the error what James, yes, the case for lower SError is broken still. If there was no synced error, then it should go on to handle the original SError here. \n\nChecking the SError Error code is probably not helping.  This is not easily handled unlike the previous implementation wherein esb() was consuming the outstanding SError.\n\nI dont see any clean way out of this. The less problematic alternative is to return to the original handler unconditionally and cope with the case that there is a chance that the platform handler needs to be aware that error was already handled by the mechanism above.\n\n\nso you can do a ret from here unconditionally.",
      "range": {
        "startLine": 206,
        "startChar": 1,
        "endLine": 215,
        "endChar": 4
      },
      "revId": "9c776a9dc19b7ad43f63474677bb978d46e98b13",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8185784a_11527aee",
        "filename": "bl31/aarch64/ea_delegate.S",
        "patchSetId": 46
      },
      "lineNbr": 215,
      "author": {
        "id": 1000102
      },
      "writtenOn": "2023-07-25T10:29:07Z",
      "side": 1,
      "message": "If there are no synced error it won\u0027t come to this path at first place and the serror handler in vector entry will be called. This code path is only exercised when we came to vector because of lower EL SError and then we got one more pending SError. If this is the case then handling of SError is already done after line#192 and then we do exception return.",
      "parentUuid": "f0296900_61174333",
      "range": {
        "startLine": 206,
        "startChar": 1,
        "endLine": 215,
        "endChar": 4
      },
      "revId": "9c776a9dc19b7ad43f63474677bb978d46e98b13",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7b63a901_c08a3921",
        "filename": "bl31/aarch64/ea_delegate.S",
        "patchSetId": 46
      },
      "lineNbr": 215,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2023-07-25T13:06:48Z",
      "side": 1,
      "message": "Ah I see, yes, you are right. We enter this code path only on a outstanding EA which is checked before branching here.",
      "parentUuid": "8185784a_11527aee",
      "range": {
        "startLine": 206,
        "startChar": 1,
        "endLine": 215,
        "endChar": 4
      },
      "revId": "9c776a9dc19b7ad43f63474677bb978d46e98b13",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bd047e1d_6c53b230",
        "filename": "bl31/aarch64/ea_delegate.S",
        "patchSetId": 46
      },
      "lineNbr": 222,
      "author": {
        "id": 1000098
      },
      "writtenOn": "2023-07-26T01:43:13Z",
      "side": 1,
      "message": "At first glance, it would be confusing for someone to see SCR_EL3.EA \u003d 0 in FFH mode. I think we discussed that it is possible when the current execution is in secure world since EL3 doesn\u0027t want to trap SErrors, instead SPMC at S-EL2 does that. Could you capture it as a comment here?",
      "range": {
        "startLine": 222,
        "startChar": 52,
        "endLine": 222,
        "endChar": 76
      },
      "revId": "9c776a9dc19b7ad43f63474677bb978d46e98b13",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c83574ee_77265ae6",
        "filename": "bl31/aarch64/runtime_exceptions.S",
        "patchSetId": 46
      },
      "lineNbr": 60,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2023-07-25T13:13:32Z",
      "side": 1,
      "message": "need an isb here as it is possible for the CPU to read the value of ISR_EL1 before completion of dsb. This isb is not required with FEAT_IESB as the error sync is done on entry to EL3. \n\nThis is certainly a huge burden for all entry to EL3 and FEAT_IESB needs to be enabled on platforms which have the capability as it will be better for EL3 entry times.",
      "revId": "9c776a9dc19b7ad43f63474677bb978d46e98b13",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "360bb757_24fd5ace",
        "filename": "bl31/aarch64/runtime_exceptions.S",
        "patchSetId": 46
      },
      "lineNbr": 60,
      "author": {
        "id": 1000102
      },
      "writtenOn": "2023-07-25T13:15:38Z",
      "side": 1,
      "message": "Ack, Yes FEAT_IESB is already implemented in next patch in series.",
      "parentUuid": "c83574ee_77265ae6",
      "revId": "9c776a9dc19b7ad43f63474677bb978d46e98b13",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "208f383f_1550ae37",
        "filename": "bl31/aarch64/runtime_exceptions.S",
        "patchSetId": 46
      },
      "lineNbr": 259,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2023-07-24T17:19:39Z",
      "side": 1,
      "message": "add a comment :\n\n/* It is possible for the sync_and_handle_pending_serror to have already handled the SError if additional errors were synced and the below handler may receive be invoked spuriously */",
      "revId": "9c776a9dc19b7ad43f63474677bb978d46e98b13",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "da3644c7_4e4d9217",
        "filename": "bl31/aarch64/runtime_exceptions.S",
        "patchSetId": 46
      },
      "lineNbr": 259,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2023-07-25T13:06:48Z",
      "side": 1,
      "message": "Ignore.",
      "parentUuid": "208f383f_1550ae37",
      "revId": "9c776a9dc19b7ad43f63474677bb978d46e98b13",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    }
  ]
}