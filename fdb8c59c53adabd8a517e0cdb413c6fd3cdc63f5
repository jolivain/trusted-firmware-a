{
  "comments": [
    {
      "key": {
        "uuid": "3f725796_d16984fd",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 17,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2020-09-03T20:13:00Z",
      "side": 1,
      "message": "just realized something. when compiled for aarch32, is the expectation that the compiler will split the uint64_t dereferences to multiple 32 bit writes?",
      "range": {
        "startLine": 17,
        "startChar": 22,
        "endLine": 17,
        "endChar": 35
      },
      "revId": "fdb8c59c53adabd8a517e0cdb413c6fd3cdc63f5",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6980a737_991d463b",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 17,
      "author": {
        "id": 1000118
      },
      "writtenOn": "2020-09-03T21:45:30Z",
      "side": 1,
      "message": "How this 64-bit write actually happens is up to the compiler. On ARMv7/AArch32 there are multiple ways of doing larger-than-32-bit writes (strd, NEON, or ldmia/stmia, for instance). And later ARMv7 CPUs or even ARMv8 cores in AArch32 state surely have a memory bus wider than 32 bits. So on my test (with -O2) it chose strd. If the compiler decides to split it up, it probably would do for a reason (because it might be beneficial to do so on the selected -mcpu, for instance). That\u0027s the advantage of writing this in C, the author does not need to care about those hardware details.",
      "parentUuid": "3f725796_d16984fd",
      "range": {
        "startLine": 17,
        "startChar": 22,
        "endLine": 17,
        "endChar": 35
      },
      "revId": "fdb8c59c53adabd8a517e0cdb413c6fd3cdc63f5",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2c4e5812_e903b03f",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 17,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2020-09-04T00:23:07Z",
      "side": 1,
      "message": "thx. totally agree, i was the one who originally pushed back on the asm version, pretty much for the same reasons as you did, so i was pleased to see the (nearly) same algorithm from the assembly implementation implemented in C. The reason i asked this question was there were some concerns regarding efficiency of compiler generated aarch32 code so i was wondering if splitting of writes for ex, was what could cause the inefficiency.",
      "parentUuid": "6980a737_991d463b",
      "range": {
        "startLine": 17,
        "startChar": 22,
        "endLine": 17,
        "endChar": 35
      },
      "revId": "fdb8c59c53adabd8a517e0cdb413c6fd3cdc63f5",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9cbe0758_0654a1ec",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 17,
      "author": {
        "id": 1000118
      },
      "writtenOn": "2020-09-04T00:59:24Z",
      "side": 1,
      "message": "Yeah, those things are subtle, and are actually best kept to the compiler. I played around a bit with the code on a Cortex-A15 (Calxeda Midway server): With gcc -O2 I get into the same performance region as glibc (diff is in the userland noise). Alexei\u0027s aarch32 assembly code is about the same as glibc, if not a tiny smidge faster. The sequence generated by gcc for my code is:\n  34:   e9c4 5c00       strd    r5, ip, [r4]\n  38:   3408            adds    r4, #8\n  3a:   42b4            cmp     r4, r6\nWith -O1 it generates:\n  3c:   6017            str     r7, [r2, #0]\n  3e:   6055            str     r5, [r2, #4]\n  40:   3208            adds    r2, #8\n  42:   42b2            cmp     r2, r6\nwhich is about 5% slower (the formerly cited 95%). If I change this sequence to read:\n  3c:   e8e2 5702       strd    r5, r7, [r2], #8\n  40:   42b2            cmp     r2, r6\nI get the same numbers as with -O2 above.\nI think Thumb code size plays also a role here (post-indexed is 32 bits, so it\u0027s shorter to do (str, str, add). This all demonstrates that optimisation these days is quite tedious, and is best left to the compiler (and its intimate knowledge of machine specific behaviour, for instance).\nAnd this was with Ubuntu\u0027s stock GCC 7.5.0, maybe newer versions know another trick and a half?\n\nAlso on a ThunderX2, gcc -O3 brings this code here to the same performance level as glibc and Alexei\u0027s assembly.",
      "parentUuid": "2c4e5812_e903b03f",
      "range": {
        "startLine": 17,
        "startChar": 22,
        "endLine": 17,
        "endChar": 35
      },
      "revId": "fdb8c59c53adabd8a517e0cdb413c6fd3cdc63f5",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4f8cef62_44530752",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 17,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2020-09-04T14:54:20Z",
      "side": 1,
      "message": "Agree. Thanks!",
      "parentUuid": "9cbe0758_0654a1ec",
      "range": {
        "startLine": 17,
        "startChar": 22,
        "endLine": 17,
        "endChar": 35
      },
      "revId": "fdb8c59c53adabd8a517e0cdb413c6fd3cdc63f5",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": false
    }
  ]
}