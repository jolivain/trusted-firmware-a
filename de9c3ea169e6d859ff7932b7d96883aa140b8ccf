{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "e84703f6_4d675070",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1000102
      },
      "writtenOn": "2021-02-23T16:36:08Z",
      "side": 1,
      "message": "Hi Jeremy, please rebase your patches on latest and take care of outstanding comments (can see some merge conflicts)",
      "revId": "de9c3ea169e6d859ff7932b7d96883aa140b8ccf",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fea08236_68c1fe71",
        "filename": "include/services/pci_svc.h",
        "patchSetId": 4
      },
      "lineNbr": 9,
      "author": {
        "id": 1000043
      },
      "writtenOn": "2021-01-28T11:09:05Z",
      "side": 1,
      "message": "Need to include utils_def.h to get the definition of U() macro.",
      "revId": "de9c3ea169e6d859ff7932b7d96883aa140b8ccf",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1a9f6ab4_f656a227",
        "filename": "include/services/pci_svc.h",
        "patchSetId": 4
      },
      "lineNbr": 24,
      "author": {
        "id": 1000043
      },
      "writtenOn": "2021-01-28T11:09:05Z",
      "side": 1,
      "message": "Enclose dev in parentheses.",
      "range": {
        "startLine": 24,
        "startChar": 27,
        "endLine": 24,
        "endChar": 30
      },
      "revId": "de9c3ea169e6d859ff7932b7d96883aa140b8ccf",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d1034e53_77b92db4",
        "filename": "include/services/pci_svc.h",
        "patchSetId": 4
      },
      "lineNbr": 31,
      "author": {
        "id": 1000043
      },
      "writtenOn": "2021-01-28T11:09:05Z",
      "side": 1,
      "message": "(style) Use a lower-case \u0027m\u0027: minor.",
      "range": {
        "startLine": 31,
        "startChar": 11,
        "endLine": 31,
        "endChar": 16
      },
      "revId": "de9c3ea169e6d859ff7932b7d96883aa140b8ccf",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "144fc1c2_4535256f",
        "filename": "include/services/pci_svc.h",
        "patchSetId": 4
      },
      "lineNbr": 32,
      "author": {
        "id": 1000043
      },
      "writtenOn": "2021-01-28T11:09:05Z",
      "side": 1,
      "message": "(style) major",
      "range": {
        "startLine": 32,
        "startChar": 11,
        "endLine": 32,
        "endChar": 16
      },
      "revId": "de9c3ea169e6d859ff7932b7d96883aa140b8ccf",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a0e5129e_88a7e5a4",
        "filename": "include/services/pci_svc.h",
        "patchSetId": 4
      },
      "lineNbr": 43,
      "author": {
        "id": 1000043
      },
      "writtenOn": "2021-01-28T11:09:05Z",
      "side": 1,
      "message": "Should this be uint32_t? I see that the spec encodes the device address as a 32-bit value in the PCI_READ interface, plus pci_write_config() below already uses a uint32_t, which seems inconsistent.\n\nSame question for the second and third arguments (the offset and the size).",
      "range": {
        "startLine": 43,
        "startChar": 25,
        "endLine": 43,
        "endChar": 33
      },
      "revId": "de9c3ea169e6d859ff7932b7d96883aa140b8ccf",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6a6fa10f_36da36f1",
        "filename": "include/services/pci_svc.h",
        "patchSetId": 4
      },
      "lineNbr": 43,
      "author": {
        "id": 1000043
      },
      "writtenOn": "2021-01-28T11:09:05Z",
      "side": 1,
      "message": "I am assuming these functions return an error code (one of SMC_PCI_CALL_*), in which case, does it really matter to use exact-width types (uint32_t)? Could we use a simple int instead?",
      "range": {
        "startLine": 43,
        "startChar": 0,
        "endLine": 43,
        "endChar": 8
      },
      "revId": "de9c3ea169e6d859ff7932b7d96883aa140b8ccf",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3d8daafc_9f077159",
        "filename": "include/services/pci_svc.h",
        "patchSetId": 4
      },
      "lineNbr": 43,
      "author": {
        "id": 1000102
      },
      "writtenOn": "2021-02-23T16:36:08Z",
      "side": 1,
      "message": "+1 on Sandrine\u0027s comment",
      "parentUuid": "a0e5129e_88a7e5a4",
      "range": {
        "startLine": 43,
        "startChar": 25,
        "endLine": 43,
        "endChar": 33
      },
      "revId": "de9c3ea169e6d859ff7932b7d96883aa140b8ccf",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2513eee4_84aacae7",
        "filename": "include/services/pci_svc.h",
        "patchSetId": 4
      },
      "lineNbr": 43,
      "author": {
        "id": 1000503
      },
      "writtenOn": "2021-04-01T20:46:37Z",
      "side": 1,
      "message": "The spec defines a negative 32-bit return, which TF-A doesn\u0027t assure via its macros. So this has the side effect of explicitly assuring the high 32-bits aren\u0027t set on 64-bit platforms. This doesn\u0027t matter as much for read_config() but it does for the others, so making this consistent isn\u0027t a bad plan.",
      "parentUuid": "6a6fa10f_36da36f1",
      "range": {
        "startLine": 43,
        "startChar": 0,
        "endLine": 43,
        "endChar": 8
      },
      "revId": "de9c3ea169e6d859ff7932b7d96883aa140b8ccf",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7a6eafd4_fa7b5b5c",
        "filename": "include/services/pci_svc.h",
        "patchSetId": 4
      },
      "lineNbr": 43,
      "author": {
        "id": 1000503
      },
      "writtenOn": "2021-04-01T20:46:37Z",
      "side": 1,
      "message": "I think this is a side effect of trying to move more of the address computation into the common code. But I agree, in the current version it makes more sense to leave it 32-bit.\n\nBTW: so this is a 32-bit calling convention, to leave open the possibility of 32-bit OSs/HW, but at the moment that is not possible because the precondition for use (ACPI) only exists on 64-bit hardware, with a 64-bit OS. The only way this really changes is if we come up with a DT binding for it.",
      "parentUuid": "3d8daafc_9f077159",
      "range": {
        "startLine": 43,
        "startChar": 25,
        "endLine": 43,
        "endChar": 33
      },
      "revId": "de9c3ea169e6d859ff7932b7d96883aa140b8ccf",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    }
  ]
}