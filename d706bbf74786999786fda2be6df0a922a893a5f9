{
  "comments": [
    {
      "key": {
        "uuid": "ac7b073c_2586e435",
        "filename": "CMakeLists.txt",
        "patchSetId": 8
      },
      "lineNbr": 33,
      "author": {
        "id": 1000206
      },
      "writtenOn": "2020-08-11T16:31:35Z",
      "side": 1,
      "message": "`PROJECT_SOURCE_DIR` exists for this purpose: https://cmake.org/cmake/help/v3.0/variable/PROJECT_SOURCE_DIR.html",
      "range": {
        "startLine": 32,
        "startChar": 0,
        "endLine": 33,
        "endChar": 43
      },
      "revId": "d706bbf74786999786fda2be6df0a922a893a5f9",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "aa43c662_35b479cd",
        "filename": "CMakeLists.txt",
        "patchSetId": 8
      },
      "lineNbr": 33,
      "author": {
        "id": 1000391
      },
      "writtenOn": "2020-08-18T14:01:18Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "ac7b073c_2586e435",
      "range": {
        "startLine": 32,
        "startChar": 0,
        "endLine": 33,
        "endChar": 43
      },
      "revId": "d706bbf74786999786fda2be6df0a922a893a5f9",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7b213f5a_b5301689",
        "filename": "CMakeLists.txt",
        "patchSetId": 8
      },
      "lineNbr": 33,
      "author": {
        "id": 1000018
      },
      "writtenOn": "2020-08-18T20:32:08Z",
      "side": 1,
      "message": "Yes, but the documentation indicates unwanted side effects. \"This is the source directory of the last call to the project() command made in the current directory scope or one of its parents.\"\n* Are you 100% sure this will point to the top of the TF-A tree under all circumstances? \n* The project command is only called at line 100. What will be the value here?\n\nI think if I would add a super project above TF-A then PROJECT_SOURCE_DIR here would refer to the directory of the super project and this the build will break.\n\nFor me using PROJECT_SOURCE_DIR does not seem to be safe. We want a variable which refers to TF-A root under any circumstances.",
      "parentUuid": "aa43c662_35b479cd",
      "range": {
        "startLine": 32,
        "startChar": 0,
        "endLine": 33,
        "endChar": 43
      },
      "revId": "d706bbf74786999786fda2be6df0a922a893a5f9",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c5b1f156_3f2bf239",
        "filename": "CMakeLists.txt",
        "patchSetId": 8
      },
      "lineNbr": 33,
      "author": {
        "id": 1000206
      },
      "writtenOn": "2020-08-19T10:49:58Z",
      "side": 1,
      "message": "I\u0027m not sure what you mean by it being unsafe - it is quite well-defined. It is precisely equivalent to `set(PROJECT_SOURCE_DIR ...)` at the point of the `project()` call.",
      "parentUuid": "7b213f5a_b5301689",
      "range": {
        "startLine": 32,
        "startChar": 0,
        "endLine": 33,
        "endChar": 43
      },
      "revId": "d706bbf74786999786fda2be6df0a922a893a5f9",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7d58fef1_85d7a327",
        "filename": "CMakeLists.txt",
        "patchSetId": 8
      },
      "lineNbr": 33,
      "author": {
        "id": 1000391
      },
      "writtenOn": "2020-08-20T13:51:05Z",
      "side": 1,
      "message": "As Chris says, as far as I\u0027m aware in all cases this is functionally equivalent to the previous solution. Thus it\u0027s probably best to use PROJECT_SOURCE_DIR as it is standard CMake. Re: the project() command line being called quite late, PROJECT_SOURCE_DIR still provides a lot of value as it is used whenever any source files are included later on (e.g. in platform.cmake) - in place of where TFA_ROOT_DIR was used before.\nI briefly tested the situation you mentioned - a super project above TF-A which calls project() then add_subdirectory()s TF-A. This still works fine, when TF-A calls project() it sets PROJECT_SOURCE_DIR to the correct path at this scope level.",
      "parentUuid": "c5b1f156_3f2bf239",
      "range": {
        "startLine": 32,
        "startChar": 0,
        "endLine": 33,
        "endChar": 43
      },
      "revId": "d706bbf74786999786fda2be6df0a922a893a5f9",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d588b9c1_33f4c4ac",
        "filename": "CMakeLists.txt",
        "patchSetId": 8
      },
      "lineNbr": 33,
      "author": {
        "id": 1000018
      },
      "writtenOn": "2020-08-26T06:20:16Z",
      "side": 1,
      "message": "Well, if the test result is positive, then feel free to go with  PROJECT_SOURCE_DIR.",
      "parentUuid": "7d58fef1_85d7a327",
      "range": {
        "startLine": 32,
        "startChar": 0,
        "endLine": 33,
        "endChar": 43
      },
      "revId": "d706bbf74786999786fda2be6df0a922a893a5f9",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b3af8e7b_2b258cc3",
        "filename": "CMakeLists.txt",
        "patchSetId": 8
      },
      "lineNbr": 41,
      "author": {
        "id": 1000206
      },
      "writtenOn": "2020-08-11T16:31:35Z",
      "side": 1,
      "message": "If you add `${TFA_ROOT_DIR}/cmake` to `CMAKE_MODULE_PATH`, you can simply use:\n\n    include(GetTFACMF)",
      "range": {
        "startLine": 35,
        "startChar": 0,
        "endLine": 41,
        "endChar": 46
      },
      "revId": "d706bbf74786999786fda2be6df0a922a893a5f9",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e392b5d5_2c231a59",
        "filename": "CMakeLists.txt",
        "patchSetId": 8
      },
      "lineNbr": 41,
      "author": {
        "id": 1000391
      },
      "writtenOn": "2020-08-18T14:01:18Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "b3af8e7b_2b258cc3",
      "range": {
        "startLine": 35,
        "startChar": 0,
        "endLine": 41,
        "endChar": 46
      },
      "revId": "d706bbf74786999786fda2be6df0a922a893a5f9",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d5f13cae_db6822a1",
        "filename": "CMakeLists.txt",
        "patchSetId": 8
      },
      "lineNbr": 60,
      "author": {
        "id": 1000206
      },
      "writtenOn": "2020-08-11T16:31:35Z",
      "side": 1,
      "message": "We shouldn\u0027t be setting this explicitly within CMakeLists.txt. `CMAKE_C_COMPILER_ID` exists for this purpose, and is derived from the toolchain file: https://cmake.org/cmake/help/latest/variable/CMAKE_LANG_COMPILER_ID.html",
      "range": {
        "startLine": 60,
        "startChar": 0,
        "endLine": 60,
        "endChar": 49
      },
      "revId": "d706bbf74786999786fda2be6df0a922a893a5f9",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9e1d96ed_749c5a67",
        "filename": "CMakeLists.txt",
        "patchSetId": 8
      },
      "lineNbr": 60,
      "author": {
        "id": 1000018
      },
      "writtenOn": "2020-08-18T20:32:08Z",
      "side": 1,
      "message": "Our compiler specific files work different to toolchain files. Also compiler id is not well defined.\n* For example amrclang 6.x comes with two assemblers, and thus supports two different dialects. Shall the two assemblers be covered with the same compiler id? Or a different one?\n* Which documentation is valid for the compiler id if behavior is project specific, CMake or project documentation?\n\nYes, cmake has build in methodology to select the compiler and to communicate the information to build files. But the documentation is not clear, and if the behavior is project specific it generates confusion.",
      "parentUuid": "d5f13cae_db6822a1",
      "range": {
        "startLine": 60,
        "startChar": 0,
        "endLine": 60,
        "endChar": 49
      },
      "revId": "d706bbf74786999786fda2be6df0a922a893a5f9",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6ce3b7e4_1b906066",
        "filename": "CMakeLists.txt",
        "patchSetId": 8
      },
      "lineNbr": 60,
      "author": {
        "id": 1000206
      },
      "writtenOn": "2020-08-19T10:49:58Z",
      "side": 1,
      "message": "\u003e For example amrclang 6.x comes with two assemblers, and thus supports two different dialects. Shall the two assemblers be covered with the same compiler id? Or a different one?\n\nI\u0027m unsure of what you mean by armclang coming with two assemblers. An Arm Compiler 6 toolchain file is expected to set `CMAKE_ASM_COMPILER` to `armclang` (as is the behaviour with GCC/Clang):\n\nhttps://github.com/Kitware/CMake/blob/64a7f491ef8ab6f70a77f89c91d1e7e9d549333e/Modules/Compiler/ARMClang-ASM.cmake\n\n`armclang` itself, when parsing assembly files, defaults to Arm\u0027s unified assembly syntax, but an assembly file can always switch back to divided assembly syntax with the `.syntax divided` directive.\n\n\u003e Which documentation is valid for the compiler id if behavior is project specific, CMake or project documentation.\n\nThe compiler identifier should never be project-specific - project-specific toolchain information *has* to come through project-specific means, either by deriving information from the toolchain file, or directly through the toolchain file itself. Not doing so means potentially breaking things like `find_package()` (uses `CMAKE_FIND_ROOT_PATH_MODE_*`), `try_compile()` (`CMAKE_TRY_COMPILE_TARGET_TYPE`), and anything else that derives information from variables expected to have been created by the toolchain machinery.\n\nIf you\u0027re setting variables like `TFA_MY_COMPILER_METADATA` from the toolchain file, that\u0027s perfectly fine and that should be documented by the project, but the compiler identifiers are standardised and many third-party libraries rely on them (e.g. the `Generic` compiler ID for baremetal targets)",
      "parentUuid": "9e1d96ed_749c5a67",
      "range": {
        "startLine": 60,
        "startChar": 0,
        "endLine": 60,
        "endChar": 49
      },
      "revId": "d706bbf74786999786fda2be6df0a922a893a5f9",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5a5c6813_3596096e",
        "filename": "CMakeLists.txt",
        "patchSetId": 8
      },
      "lineNbr": 60,
      "author": {
        "id": 1000018
      },
      "writtenOn": "2020-08-26T06:20:16Z",
      "side": 1,
      "message": "⭕amclang comes with two assemblers:\narclang has two assemblers, the built in one and the legacy armasm. This has to be handled in the build system, since the two talk different assembly dialects. Since does not support having two assemblers in one build, you have to use external_project() and move all legacy assembly files to a dedicated project to be able to run different tools. But you will need two toolchain files and two compiler IDs. \nBut let\u0027s ignore this, it was just an example for unexpected complexities with cmakes built-in compiler handling.\n\n⭕try_compile() and it\u0027s friends:\nIn bare metal you want to compile the code with specific compiler configured in a specific way. In turn when you compile an application you want to compile with any compiler available in the environment. As a result for bare-metal compiler feature detection has no benefit. It will just slow down the configuration run and will always provide the same result for the same version of a compiler. Unfortunately this can not be turned off easily and we have to live with it. But using toolchain files is not mandatory and we can drop that part.\n\n⭕\"The compiler identifier should never be project-specific\"\nWell, the compiler ID drives compiler handling of cmake. Since it should be possible to add new compilers, and projects shall not depend on compiler specific details, there must be an abstraction layer for that purpose. But is all that is true setting a specific compiler ID in the project shall not harm. The case is the same when you add support for a new compiler.\n\nThe compiler ID tells cmake, that the current compiler is a specific one, and it shall use the \"built-in\" compiler specific files. This actually is a risk for us, since for bare-metal projects there are no standards. built-in compiler specific files will make assumptions for specific uses cases (i.e. cross compiling linux applications), which may be bad for us. For example the \"standard way\" how target and host specific libraries are separated when cross compiling linux apps will not work for us.\n\n⭕The armclang  toolchain file.\nIt is nice that armclang finally got official support in cmake. But is it good for us? As I mentioned our use-case is quite different to building applications for rich OSs (linux, android, windows, etc...).\n\n⭕So with all that my point is: this is bare-metal and we want to control what compiler is used. CMake does not play really well with this use case, and the whole compiler machinery is more in our way than our help. As a result we have our own project specific methodology for compiler handling.",
      "parentUuid": "6ce3b7e4_1b906066",
      "range": {
        "startLine": 60,
        "startChar": 0,
        "endLine": 60,
        "endChar": 49
      },
      "revId": "d706bbf74786999786fda2be6df0a922a893a5f9",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e614d2d6_6e1858a3",
        "filename": "CMakeLists.txt",
        "patchSetId": 8
      },
      "lineNbr": 60,
      "author": {
        "id": 1000206
      },
      "writtenOn": "2020-08-26T10:12:45Z",
      "side": 1,
      "message": "\u003e amclang comes with two assemblers:\narclang has two assemblers, the built in one and the legacy armasm. This has to be handled in the build system, since the two talk different assembly dialects. Since does not support having two assemblers in one build, you have to use external_project() and move all legacy assembly files to a dedicated project to be able to run different tools. But you will need two toolchain files and two compiler IDs. \nBut let\u0027s ignore this, it was just an example for unexpected complexities with cmakes built-in compiler handling.\n\nIn my view at least, that\u0027s the project that needs addressing rather than something the build system needs to handle. `armasm` is a legacy tool from Arm Compiler 5, whilst `armclang` is the Arm Compiler 6 assembler. If TF-A wants to claim to support Arm Compiler 6, then we need to migrate any Arm Compiler 5 assembly files, just as it would need to migrate its C file syntax. With that said, it looks like all of TF-A\u0027s assembly is already in the modern syntax, so I don\u0027t think this is something we need to be concerned with.\n\n\u003e try_compile() and it\u0027s friends:\nIn bare metal you want to compile the code with specific compiler configured in a specific way. In turn when you compile an application you want to compile with any compiler available in the environment. As a result for bare-metal compiler feature detection has no benefit. It will just slow down the configuration run and will always provide the same result for the same version of a compiler. Unfortunately this can not be turned off easily and we have to live with it. But using toolchain files is not mandatory and we can drop that part.\n\nIt\u0027s not necessarily true that for baremetal you want a truly fixed compiler configuration, and it\u0027s absolutely untrue that feature detection is of no use. Certainly, there are things that partners will likely wish to fiddle with - optimisation settings, log/trace filters, debug profiles, etc. Sure, for a given platform they generally want to build for a single processor with a single linker script, but there\u0027s no reason at all to prevent them from being able to fiddle on the fly - from experience, it is *very* useful to be able to experiment with compiler flags when bringing up a new system. It\u0027s also no guarantee at all that partners will be using the same version of each compiler. We can specify as many minimum versions or maximum versions of a given compiler as we like, but there will always be partners whose primary interest is in minimising the infrastructure changes they need to make on their side, and feature tests, generally, age pretty well.\n\nI\u0027m not sure I can see the concern with slowing down a configuration run - even the most behemoth CMake projects I have worked with have had a configuration run of, at most, a few seconds.\n\n\u003e The armclang  toolchain file.\nIt is nice that armclang finally got official support in cmake. But is it good for us? As I mentioned our use-case is quite different to building applications for rich OSs (linux, android, windows, etc...).\n\nI\u0027ve had no problems building bare-metal applications with CMake and Arm Compiler 6. You simply need to set `CMAKE_SYSTEM_NAME` to `Generic` to build for bare metal, and `CMAKE_PROCESSOR_NAME` to one of the CPUs supported by `armclang -mcpu\u003dlist` (e.g. `cortex-a53`, `cortex-m4f`, etc.). CMake is not solely intended for building rich OS applications, and its support for bare metal projects has been solid for several years at this point.\n\n\u003e So with all that my point is: this is bare-metal and we want to control what compiler is used. CMake does not play really well with this use case, and the whole compiler machinery is more in our way than our help. As a result we have our own project specific methodology for compiler handling.\n\nI *strongly* disagree. I have been working with bare metal CMake projects for a long time, and I\u0027ve never felt that CMake stood in the way of doing so, and it provides numerous very helpful facilities that only operate reliably when a valid toolchain is in place. As I understand it, TF-M is also finalising their move to toolchain files over custom compiler logic, so it might be worth having a chat with them to see how they have found the experience.\n\nI am far more in favour of user-friendliness and familiarity and, to me, customising the toolchain logic at a lower level than CMake expects is a) bound to bite us in the future, if not now, and b) makes it extraordinarily difficult for newcomers to get comprehend and involve themselves in the build system.",
      "parentUuid": "5a5c6813_3596096e",
      "range": {
        "startLine": 60,
        "startChar": 0,
        "endLine": 60,
        "endChar": 49
      },
      "revId": "d706bbf74786999786fda2be6df0a922a893a5f9",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b72daa50_72bd8623",
        "filename": "CMakeLists.txt",
        "patchSetId": 8
      },
      "lineNbr": 61,
      "author": {
        "id": 1000206
      },
      "writtenOn": "2020-08-11T16:31:35Z",
      "side": 1,
      "message": "As cache variables, these should be given an adequate namespace (`TFA`?). This allows them to be grouped within the CMake GUI.",
      "range": {
        "startLine": 59,
        "startChar": 0,
        "endLine": 61,
        "endChar": 72
      },
      "revId": "d706bbf74786999786fda2be6df0a922a893a5f9",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8c9e6ef1_d55e7ad6",
        "filename": "CMakeLists.txt",
        "patchSetId": 8
      },
      "lineNbr": 61,
      "author": {
        "id": 1000391
      },
      "writtenOn": "2020-08-18T14:01:18Z",
      "side": 1,
      "message": "Sorry, I\u0027m not sure quite what you mean when you say namespace wrt. cache variables. Does this consist of just prefixing the cache variables with `TFA_` or something like this?",
      "parentUuid": "b72daa50_72bd8623",
      "range": {
        "startLine": 59,
        "startChar": 0,
        "endLine": 61,
        "endChar": 72
      },
      "revId": "d706bbf74786999786fda2be6df0a922a893a5f9",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "187ef440_23bb8fc0",
        "filename": "CMakeLists.txt",
        "patchSetId": 8
      },
      "lineNbr": 61,
      "author": {
        "id": 1000018
      },
      "writtenOn": "2020-08-18T20:32:08Z",
      "side": 1,
      "message": "TF-A is not planning to use the cmake-gui to edit the configuration. Also this setting has an effect on multiple components. So there is no benefit adding a prefix but it may generate confusion. If the variable is prefixed with TF-A will it affect the whole project or just TF-A core?",
      "parentUuid": "8c9e6ef1_d55e7ad6",
      "range": {
        "startLine": 59,
        "startChar": 0,
        "endLine": 61,
        "endChar": 72
      },
      "revId": "d706bbf74786999786fda2be6df0a922a893a5f9",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e009acdb_4a4ccb23",
        "filename": "CMakeLists.txt",
        "patchSetId": 8
      },
      "lineNbr": 61,
      "author": {
        "id": 1000206
      },
      "writtenOn": "2020-08-19T10:49:58Z",
      "side": 1,
      "message": "\u003e TF-A is not planning to use the cmake-gui to edit the configuration.\n\nI\u0027m not sure what you mean by \"TF-A is not planning to use the cmake-gui to edit the configuration\"... that\u0027s a choice for the user, and is not something that a well-formed CMake project should ever dictate. Many people will be familiar with CMake\u0027s existing configuration toolchain from using other large-scale CMake projects like LLVM, Boost, OpenCV, etc. so making it impossible to do is going to make things very unergonomic indeed for a lot of people, especially for people who configure their projects through their IDE (like JetBrains IntelliJ/CLion and Visual Studio allow).\n\n\u003e Also this setting has an effect on multiple components. So there is no benefit adding a prefix but it may generate confusion. If the variable is prefixed with TF-A will it affect the whole project or just TF-A core?\n\nI\u0027m not sure I understand what you mean, I\u0027m unsure of how it would namespacing would generate confusion.",
      "parentUuid": "187ef440_23bb8fc0",
      "range": {
        "startLine": 59,
        "startChar": 0,
        "endLine": 61,
        "endChar": 72
      },
      "revId": "d706bbf74786999786fda2be6df0a922a893a5f9",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "0c3f2cb9_244f69ae",
        "filename": "CMakeLists.txt",
        "patchSetId": 8
      },
      "lineNbr": 61,
      "author": {
        "id": 1000018
      },
      "writtenOn": "2020-08-26T06:20:16Z",
      "side": 1,
      "message": "\"I\u0027m not sure what you mean by \"TF-A is not planning to use the cmake-gui to edit the configuration\"... that\u0027s a choice for the user, and is not something that a well-formed CMake project should ever dictate\"\nThis is not true. As a design principle CMake scripts will not contain any validation of configuration space values and this will be handled by kconfig. As a result editing the cache manually will be a disaster.\nAgain, this is a bare-metal project and a lot of things work different compared to application development.\n\n\"I\u0027m not sure I understand what you mean, I\u0027m unsure of how it would namespacing would generate confusion.\"\nLet\u0027s ignore this thread as it is a minor and negligible issue. I am happy with whatever variable name.",
      "parentUuid": "e009acdb_4a4ccb23",
      "range": {
        "startLine": 59,
        "startChar": 0,
        "endLine": 61,
        "endChar": 72
      },
      "revId": "d706bbf74786999786fda2be6df0a922a893a5f9",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "968714cf_23c0323f",
        "filename": "CMakeLists.txt",
        "patchSetId": 8
      },
      "lineNbr": 61,
      "author": {
        "id": 1000206
      },
      "writtenOn": "2020-08-26T10:12:45Z",
      "side": 1,
      "message": "\u003e This is not true. As a design principle CMake scripts will not contain any validation of configuration space values and this will be handled by kconfig. As a result editing the cache manually will be a disaster.\nAgain, this is a bare-metal project and a lot of things work different compared to application development.\n\nI do not understand the emphasis here on application development. Cache variables and configuration methods have nothing to do with application development, and in fact almost all of the work I have ever done with CMake has been on bare metal applications. With that said, using CMake for rich applications is little different from using it for firmware.\n\nPerhaps it\u0027s simply that I\u0027m not familiar with the Kconfig/CMake approach, but as far as I know the only widely-available project using this approach is Zephyr, and based on my experience and chats I\u0027ve had with people around build systems I would like to do everything possible to avoid a Zephyr-like approach to CMake for TF-A.",
      "parentUuid": "0c3f2cb9_244f69ae",
      "range": {
        "startLine": 59,
        "startChar": 0,
        "endLine": 61,
        "endChar": 72
      },
      "revId": "d706bbf74786999786fda2be6df0a922a893a5f9",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2dfe3c62_b4edc1fd",
        "filename": "CMakeLists.txt",
        "patchSetId": 8
      },
      "lineNbr": 86,
      "author": {
        "id": 1000206
      },
      "writtenOn": "2020-08-11T16:31:35Z",
      "side": 1,
      "message": "Why are these being set within the CMakeLists.txt as opposed to dedicated toolchain files, per: https://cmake.org/cmake/help/v3.18/manual/cmake-toolchains.7.html#cross-compiling-toolchain",
      "range": {
        "startLine": 85,
        "startChar": 0,
        "endLine": 86,
        "endChar": 31
      },
      "revId": "d706bbf74786999786fda2be6df0a922a893a5f9",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "44fe6fd1_4d4b042f",
        "filename": "CMakeLists.txt",
        "patchSetId": 8
      },
      "lineNbr": 86,
      "author": {
        "id": 1000206
      },
      "writtenOn": "2020-08-11T16:31:35Z",
      "side": 1,
      "message": "Why are these being set within the CMakeLists.txt as opposed to a dedicated toolchain file per: https://cmake.org/cmake/help/v3.18/manual/cmake-toolchains.7.html#cross-compiling-toolchain\n\nThis is asking for pain if we need to pull in dependencies via `find_package()` at any point, as the search paths and target information are going to be incorrect.",
      "range": {
        "startLine": 85,
        "startChar": 0,
        "endLine": 86,
        "endChar": 31
      },
      "revId": "d706bbf74786999786fda2be6df0a922a893a5f9",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "de278470_82b2b8a6",
        "filename": "CMakeLists.txt",
        "patchSetId": 8
      },
      "lineNbr": 86,
      "author": {
        "id": 1000018
      },
      "writtenOn": "2020-08-18T20:32:08Z",
      "side": 1,
      "message": "Because this is a bare-metal project and we need more control. For bare-metal projects the standard \"build with any compiler available\" operation is bad.\n\nCan you please explain how and why find_package() is going to misbehave?",
      "parentUuid": "44fe6fd1_4d4b042f",
      "range": {
        "startLine": 85,
        "startChar": 0,
        "endLine": 86,
        "endChar": 31
      },
      "revId": "d706bbf74786999786fda2be6df0a922a893a5f9",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "24f665dc_7f49c18a",
        "filename": "CMakeLists.txt",
        "patchSetId": 8
      },
      "lineNbr": 86,
      "author": {
        "id": 1000018
      },
      "writtenOn": "2020-08-26T06:20:16Z",
      "side": 1,
      "message": "Because this is a bare-metal project and no cross compilation use case supported by cmake does match ours.",
      "parentUuid": "2dfe3c62_b4edc1fd",
      "range": {
        "startLine": 85,
        "startChar": 0,
        "endLine": 86,
        "endChar": 31
      },
      "revId": "d706bbf74786999786fda2be6df0a922a893a5f9",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "58ee2217_4df1005b",
        "filename": "CMakeLists.txt",
        "patchSetId": 8
      },
      "lineNbr": 86,
      "author": {
        "id": 1000206
      },
      "writtenOn": "2020-08-26T10:12:45Z",
      "side": 1,
      "message": "\u003e Because this is a bare-metal project and we need more control. For bare-metal projects the standard \"build with any compiler available\" operation is bad.\n\nThe only difference between the \"build with any compiler available\" approach and the \"build with a single compiler\" approach is simply that you can make more assumptions about the features the toolchain provides. What it doesn\u0027t mean is forcing the compiler directly through the build system, because then you are dictating to the user far more than the vendor of their compiler, but also their compiler version and location.\n\n\u003e Can you please explain how and why find_package() is going to misbehave?\n\n`find_package()` and its siblings use a set of variables set before the CMake proper is invoked to locate external packages, programs, libraries, etc.\n\nhttps://cmake.org/cmake/help/v3.0/variable/CMAKE_FIND_ROOT_PATH_MODE_PROGRAM.html\nhttps://cmake.org/cmake/help/v3.0/variable/CMAKE_FIND_ROOT_PATH_MODE_LIBRARY.html\nhttps://cmake.org/cmake/help/v3.0/variable/CMAKE_FIND_ROOT_PATH_MODE_INCLUDE.html\nhttps://cmake.org/cmake/help/v3.0/variable/CMAKE_FIND_ROOT_PATH_MODE_PACKAGE.html\n\nIf these are configured incorrectly, it can mean locating libraries or programs for entirely different systems or toolchains.",
      "parentUuid": "de278470_82b2b8a6",
      "range": {
        "startLine": 85,
        "startChar": 0,
        "endLine": 86,
        "endChar": 31
      },
      "revId": "d706bbf74786999786fda2be6df0a922a893a5f9",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e35bf5e5_b53586c2",
        "filename": "CMakeLists.txt",
        "patchSetId": 8
      },
      "lineNbr": 93,
      "author": {
        "id": 1000206
      },
      "writtenOn": "2020-08-11T16:31:35Z",
      "side": 1,
      "message": "Are all of these includes necessary? Can some of them be moved to a more a local scope or removed altogether? This seems like a very large number of top-level dependencies.",
      "range": {
        "startLine": 89,
        "startChar": 0,
        "endLine": 93,
        "endChar": 29
      },
      "revId": "d706bbf74786999786fda2be6df0a922a893a5f9",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e2031398_475c3448",
        "filename": "CMakeLists.txt",
        "patchSetId": 8
      },
      "lineNbr": 93,
      "author": {
        "id": 1000391
      },
      "writtenOn": "2020-08-18T14:01:18Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "e35bf5e5_b53586c2",
      "range": {
        "startLine": 89,
        "startChar": 0,
        "endLine": 93,
        "endChar": 29
      },
      "revId": "d706bbf74786999786fda2be6df0a922a893a5f9",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ed8ce30c_ad223716",
        "filename": "CMakeLists.txt",
        "patchSetId": 8
      },
      "lineNbr": 93,
      "author": {
        "id": 1000018
      },
      "writtenOn": "2020-08-18T20:32:08Z",
      "side": 1,
      "message": "We should use the \"include what you use\" principle, so +1 for this. At the same time this fix may be out of scope for the first version.",
      "parentUuid": "e2031398_475c3448",
      "range": {
        "startLine": 89,
        "startChar": 0,
        "endLine": 93,
        "endChar": 29
      },
      "revId": "d706bbf74786999786fda2be6df0a922a893a5f9",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "de60bea9_149931e0",
        "filename": "CMakeLists.txt",
        "patchSetId": 8
      },
      "lineNbr": 93,
      "author": {
        "id": 1000391
      },
      "writtenOn": "2020-08-20T13:51:05Z",
      "side": 1,
      "message": "I did make this fix. It is quite hard to validate that it is 100% correct due to the fact that, as far as I can tell, once I include one of these library files in any of the included CMake files below, it becomes available to all of the files included later. So there could be a few missing includes due to the fact this would not error in the current ordering. These situations can hopefully be caught by review/fixed later if they surface.",
      "parentUuid": "ed8ce30c_ad223716",
      "range": {
        "startLine": 89,
        "startChar": 0,
        "endLine": 93,
        "endChar": 29
      },
      "revId": "d706bbf74786999786fda2be6df0a922a893a5f9",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "01bea393_a0eff002",
        "filename": "CMakeLists.txt",
        "patchSetId": 8
      },
      "lineNbr": 93,
      "author": {
        "id": 1000018
      },
      "writtenOn": "2020-08-26T06:20:16Z",
      "side": 1,
      "message": "I think that is ok. Perhaps we shall have a tool for this purpose like [1] but for cmake.\n\n[1] https://include-what-you-use.org/",
      "parentUuid": "de60bea9_149931e0",
      "range": {
        "startLine": 89,
        "startChar": 0,
        "endLine": 93,
        "endChar": 29
      },
      "revId": "d706bbf74786999786fda2be6df0a922a893a5f9",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "5f928bc3_f5fbc474",
        "filename": "CMakeLists.txt",
        "patchSetId": 8
      },
      "lineNbr": 103,
      "author": {
        "id": 1000206
      },
      "writtenOn": "2020-08-11T16:31:35Z",
      "side": 1,
      "message": "These can all be set to `${PROJECT_SOURCE_DIR}`.",
      "range": {
        "startLine": 103,
        "startChar": 8,
        "endLine": 103,
        "endChar": 23
      },
      "revId": "d706bbf74786999786fda2be6df0a922a893a5f9",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "052f84c1_5261206d",
        "filename": "CMakeLists.txt",
        "patchSetId": 8
      },
      "lineNbr": 103,
      "author": {
        "id": 1000391
      },
      "writtenOn": "2020-08-18T14:01:18Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "5f928bc3_f5fbc474",
      "range": {
        "startLine": 103,
        "startChar": 8,
        "endLine": 103,
        "endChar": 23
      },
      "revId": "d706bbf74786999786fda2be6df0a922a893a5f9",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "974114cb_61fb940f",
        "filename": "CMakeLists.txt",
        "patchSetId": 8
      },
      "lineNbr": 103,
      "author": {
        "id": 1000018
      },
      "writtenOn": "2020-08-18T20:32:08Z",
      "side": 1,
      "message": "Pls, no! See my comment above about this variable.",
      "parentUuid": "052f84c1_5261206d",
      "range": {
        "startLine": 103,
        "startChar": 8,
        "endLine": 103,
        "endChar": 23
      },
      "revId": "d706bbf74786999786fda2be6df0a922a893a5f9",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c0fd1e40_755a0870",
        "filename": "CMakeLists.txt",
        "patchSetId": 8
      },
      "lineNbr": 103,
      "author": {
        "id": 1000018
      },
      "writtenOn": "2020-08-26T06:20:16Z",
      "side": 1,
      "message": "Since testing shows correct operation go for this change if you like.",
      "parentUuid": "974114cb_61fb940f",
      "range": {
        "startLine": 103,
        "startChar": 8,
        "endLine": 103,
        "endChar": 23
      },
      "revId": "d706bbf74786999786fda2be6df0a922a893a5f9",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8573d842_28246f6e",
        "filename": "cmake/BuildMessage.cmake",
        "patchSetId": 8
      },
      "lineNbr": 68,
      "author": {
        "id": 1000206
      },
      "writtenOn": "2020-08-11T16:31:35Z",
      "side": 1,
      "message": "This is not a portable solution and should be doable with a simple:\n\n    configure_file(\n        \"${CMAKE_CURRENT_SOURCE_DIR}/build_message.c.in\"\n        \"${CMAKE_CURRENT_BINARY_DIR}/build_message.c\")",
      "revId": "d706bbf74786999786fda2be6df0a922a893a5f9",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ead861ed_d7a0f958",
        "filename": "cmake/BuildMessage.cmake",
        "patchSetId": 8
      },
      "lineNbr": 68,
      "author": {
        "id": 1000391
      },
      "writtenOn": "2020-08-18T14:01:18Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "8573d842_28246f6e",
      "revId": "d706bbf74786999786fda2be6df0a922a893a5f9",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "49d23818_5789eb09",
        "filename": "cmake/BuildMessage.cmake",
        "patchSetId": 8
      },
      "lineNbr": 68,
      "author": {
        "id": 1000018
      },
      "writtenOn": "2020-08-18T20:32:08Z",
      "side": 1,
      "message": "Handling the build message is quite complex. This file shall only be \"configured\" if other files have been changed, but in such case always.\nI can not tell if configur_file() keeps the correct behavior or not. Careful testing is needed.\n\nChris: can you explain you portability concern?",
      "parentUuid": "ead861ed_d7a0f958",
      "revId": "d706bbf74786999786fda2be6df0a922a893a5f9",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d0a505f2_d0d3310a",
        "filename": "cmake/BuildMessage.cmake",
        "patchSetId": 8
      },
      "lineNbr": 68,
      "author": {
        "id": 1000206
      },
      "writtenOn": "2020-08-19T10:49:58Z",
      "side": 1,
      "message": "The portability concern is that we are directly relying on the shell interpreter to do something that CMake has existing support for.\n\n`configure_file()` is executed on every configuration run, but CMake will only overwrite the file if its content differs from the previous version (to prevent the generated build system from re-building anything that depends on the file if there were no changes).",
      "parentUuid": "49d23818_5789eb09",
      "revId": "d706bbf74786999786fda2be6df0a922a893a5f9",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1df2cf50_067baa79",
        "filename": "cmake/BuildMessage.cmake",
        "patchSetId": 8
      },
      "lineNbr": 68,
      "author": {
        "id": 1000391
      },
      "writtenOn": "2020-08-20T13:51:05Z",
      "side": 1,
      "message": "I would say the configure_file method seems preferable here, given that it is properly supported by CMake and as Chris says likely to be more portable. I would also argue it\u0027s a bit neater. In terms of whether the implementation I have provided fulfils the requirements you set out Gyorgy, I\u0027m not totally sure - I would appreciate some reviews on this part in particular 😊",
      "parentUuid": "d0a505f2_d0d3310a",
      "revId": "d706bbf74786999786fda2be6df0a922a893a5f9",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "06cc4970_9b80a870",
        "filename": "cmake/BuildMessage.cmake",
        "patchSetId": 8
      },
      "lineNbr": 68,
      "author": {
        "id": 1000018
      },
      "writtenOn": "2020-08-26T06:20:16Z",
      "side": 1,
      "message": "\"`configure_file()` is executed on every configuration run, but CMake will only overwrite the file if its content differs from the previous version (to prevent the generated build system from re-building anything that depends on the file if there were no changes).\"\nThat is not what we need. The version info shall be refreshed for all builds when the build output is new. Refreshing the build message only for configuration runs is not enough.\nThe only portability risk here is if the shell understands redirection. At a quick glance I can not remember any shell which would not understand \u003e\u003e. Still if we ant to switch to configure_file(), it can be done, but shall follow the same execution flow as the current solution does. To achieve that, a dedicated script cmake script is needed, an it needs to be called with a custom command like ${CMAKE_COMMAND} -P \u003cnew-script.cmake\u003e.\nBut since the risk is low, it might not be worth it.",
      "parentUuid": "1df2cf50_067baa79",
      "revId": "d706bbf74786999786fda2be6df0a922a893a5f9",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "53030cf6_1a767b4e",
        "filename": "cmake/BuildMessage.cmake",
        "patchSetId": 8
      },
      "lineNbr": 68,
      "author": {
        "id": 1000206
      },
      "writtenOn": "2020-08-26T10:12:45Z",
      "side": 1,
      "message": "In what situation is updating the timestamp useful if there have been no changes to the project? The file will be reconfigured if any of the project source files are modified, which is ultimately what the timestamp is supposed to be tracking. What\u0027s the use in rebuilding the same project byte-for-byte just to update the timestamp? Aside from timestamps making it impossible to produce reproducible builds (https://reproducible-builds.org/), this appears to me to be a step towards unnecessary complexity.\n\nOne portability note is that in Windows\u0027 cmd.exe, `echo \"X\" \u003e\u003e test.txt` will literally echo `\"X\"`:\n\n    C:\\Users\\Chris\u003eecho \"Hello, World!\" \u003e\u003e test.txt\n    \n    C:\\Users\\Chris\u003eecho ~ Windows 10 \u003e\u003e test.txt\n    \n    C:\\Users\\Chris\u003etype test.txt\n    \"Hello, World!\"\n    ~ Windows 10\n\nIf a timestamp truly needs to be generated at _compile_ time, then yes, it should happen through `-P`, but I am very skeptical of the need to do this at all.",
      "parentUuid": "06cc4970_9b80a870",
      "revId": "d706bbf74786999786fda2be6df0a922a893a5f9",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a67dd81d_3f43efac",
        "filename": "cmake/BuildMessage.cmake",
        "patchSetId": 8
      },
      "lineNbr": 68,
      "author": {
        "id": 1000206
      },
      "writtenOn": "2020-08-26T10:25:12Z",
      "side": 1,
      "message": "Sorry, s/project source files/project list files/",
      "parentUuid": "53030cf6_1a767b4e",
      "revId": "d706bbf74786999786fda2be6df0a922a893a5f9",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b7c97048_282c35ff",
        "filename": "cmake/BuildMessage.cmake",
        "patchSetId": 8
      },
      "lineNbr": 68,
      "author": {
        "id": 1000391
      },
      "writtenOn": "2020-08-28T13:18:11Z",
      "side": 1,
      "message": "It seems the new approach is valid, it is just a matter of whether it should be implemented in one of two ways (current method/similar vs custom command with cmake -P). I guess this is a decision that needs to be taken, but I think either way using configure_file() seems preferable due to portability and usage of a standard CMake function that exists for precisely this reason.",
      "parentUuid": "a67dd81d_3f43efac",
      "revId": "d706bbf74786999786fda2be6df0a922a893a5f9",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "2754832f_fac613f2",
        "filename": "cmake/GetTFACMF.cmake",
        "patchSetId": 8
      },
      "lineNbr": 111,
      "author": {
        "id": 1000206
      },
      "writtenOn": "2020-08-11T16:31:35Z",
      "side": 1,
      "message": "I must admit that I\u0027m quite concerned by the verbosity that this dependency introduces. The benefit of this custom toolchain manager does not seem to be obvious, and it seems to obscure much of the fundamental CMake logic that most people will be familiar with. Is this truly necessary over simply using well-formed toolchain files passed through `CMAKE_TOOLCHAIN_FILE`: https://cmake.org/cmake/help/latest/variable/CMAKE_TOOLCHAIN_FILE.html",
      "range": {
        "startLine": 109,
        "startChar": 0,
        "endLine": 111,
        "endChar": 51
      },
      "revId": "d706bbf74786999786fda2be6df0a922a893a5f9",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e2aa6678_15f9bb2e",
        "filename": "cmake/GetTFACMF.cmake",
        "patchSetId": 8
      },
      "lineNbr": 111,
      "author": {
        "id": 1000018
      },
      "writtenOn": "2020-08-18T20:32:08Z",
      "side": 1,
      "message": "This has much wider scope than the toolchain file. TFACMF (TF-A CMake Framework) is a CMake script library. The intention is to share project independent functionality with other projects like TFTF to avoid code duplication and to spare work.\n\nPlease see my previous response on CMAKE_TOOLCHAIN_FILE file.",
      "parentUuid": "2754832f_fac613f2",
      "range": {
        "startLine": 109,
        "startChar": 0,
        "endLine": 111,
        "endChar": 51
      },
      "revId": "d706bbf74786999786fda2be6df0a922a893a5f9",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    }
  ]
}