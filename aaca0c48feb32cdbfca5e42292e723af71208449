{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "a637c18a_3781e3d1",
        "filename": "/COMMIT_MSG",
        "patchSetId": 19
      },
      "lineNbr": 15,
      "author": {
        "id": 1000099
      },
      "writtenOn": "2023-03-30T06:48:35Z",
      "side": 1,
      "message": "I would do something like \"one or more bits to specific values at reset.\"\nJust to clarify, the emphasis is most of the mitigations happen on boot after reset. Actual operation could be \"set OR clear OR a write of 2\u0027b01/2\u0027b00/2\u0027b11/2\u0027b10 etc. (as an e.g.)\" to some CPU register after reset. The framework should support one or more bits.",
      "range": {
        "startLine": 15,
        "startChar": 16,
        "endLine": 15,
        "endChar": 21
      },
      "revId": "aaca0c48feb32cdbfca5e42292e723af71208449",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ec62fb44_98361163",
        "filename": "/COMMIT_MSG",
        "patchSetId": 19
      },
      "lineNbr": 25,
      "author": {
        "id": 1000099
      },
      "writtenOn": "2023-03-30T06:48:35Z",
      "side": 1,
      "message": "nit: This looks a bit busy. If the erratum number is simplified and  give a generic CPU register name, probably could be concise.  If you rather prefer a real erratum number, feel free to ignore the above comment but rather remove/adjust the tabs and/or use spaces.\n\nworkaround_reset_start cortex_a77, ERRATUM(X), ERRATA_A77_X\n       sysreg_bit_set CORTEX_A77_CPUREG, CORTEX_A77_CPUREG_BIT_8\nworkaround_reset_end cortex_a77, ERRATUM(X)\ncheck_erratum_ls cortex_a77, ERRATUM(X), CPU_REV(1, 1)",
      "range": {
        "startLine": 20,
        "startChar": 0,
        "endLine": 25,
        "endChar": 61
      },
      "revId": "aaca0c48feb32cdbfca5e42292e723af71208449",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7ef13636_66deaa3e",
        "filename": "include/lib/cpus/aarch64/cpu_macros.S",
        "patchSetId": 19
      },
      "lineNbr": 418,
      "author": {
        "id": 1000099
      },
      "writtenOn": "2023-03-30T08:19:40Z",
      "side": 1,
      "message": "Might want to document this. \n\n1. There is an ISB probably at the end of the reset function, which makes sure all bits written by the MSR instruction reflects in the concerned register, before the instruction after the ISB. With the macro, ISB still exists but isn\u0027t clear where it is for a new erratum implementer.\n\n2. if ENABLE_ASSERTIONS is enabled, MRS happens without an ISB after MSR. For this testing of bits purpose, this might be ok as the register written to and read from are same and hence might cause a dependency. For our purpose even if this results aren\u0027t written to final register(or sits in some intermediate shadow regs), we are still good as long as we get the right value written, as we are not worried about seeing/testing the functional effect of the bit after the write. \n\nDespite this argument, should we still add the ISB within the ENABLE_ASSERTIONS before MRS?\n\n\n3. For \"2 or more bits cases\", do we have to do this multiple times?",
      "range": {
        "startLine": 413,
        "startChar": 0,
        "endLine": 418,
        "endChar": 15
      },
      "revId": "aaca0c48feb32cdbfca5e42292e723af71208449",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a4511300_7e6af3b7",
        "filename": "include/lib/cpus/cpu_ops.h",
        "patchSetId": 19
      },
      "lineNbr": 61,
      "author": {
        "id": 1000099
      },
      "writtenOn": "2023-03-30T06:48:35Z",
      "side": 1,
      "message": "CPU_CPU is it intentional?",
      "range": {
        "startLine": 61,
        "startChar": 8,
        "endLine": 61,
        "endChar": 15
      },
      "revId": "aaca0c48feb32cdbfca5e42292e723af71208449",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e6632b34_d4073565",
        "filename": "include/lib/cpus/errata.h",
        "patchSetId": 19
      },
      "lineNbr": 2,
      "author": {
        "id": 1000099
      },
      "writtenOn": "2023-03-30T06:48:35Z",
      "side": 1,
      "message": "nit: Since we changed the header for the date, can we do Arm for all instances where it was changed?",
      "range": {
        "startLine": 2,
        "startChar": 28,
        "endLine": 2,
        "endChar": 31
      },
      "revId": "aaca0c48feb32cdbfca5e42292e723af71208449",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    }
  ]
}