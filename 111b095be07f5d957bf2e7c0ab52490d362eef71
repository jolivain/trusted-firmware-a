{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "8b2fa0d9_62ec3c91",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1000272
      },
      "writtenOn": "2023-10-09T21:26:13Z",
      "side": 1,
      "message": "I disagree with the use of a macro to hold big blocks of data. I think a static array works just as well, and avoids any potential for duplication of data within the resulting binary.",
      "revId": "111b095be07f5d957bf2e7c0ab52490d362eef71",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "03bf1a75_10f8729c",
        "filename": "plat/arm/board/fvp/fvp_plat_attest_token.c",
        "patchSetId": 4
      },
      "lineNbr": 12,
      "author": {
        "id": 1000272
      },
      "writtenOn": "2023-10-09T21:26:13Z",
      "side": 1,
      "message": "This seems like a needless use of a macro. Is there a downside to using a static uint8_t[]?",
      "revId": "111b095be07f5d957bf2e7c0ab52490d362eef71",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d2d987cd_56aea3f1",
        "filename": "plat/arm/board/fvp/fvp_plat_attest_token.c",
        "patchSetId": 4
      },
      "lineNbr": 12,
      "author": {
        "id": 1000328
      },
      "writtenOn": "2023-10-10T07:28:03Z",
      "side": 1,
      "message": "We aim to avoid making this static and instead want to define it locally within the stack. Take a look at line number 114, where we are using memcpy to copy data from this local array to the provided \u0027buf\u0027. \nConverting this into a #define is a way to symbolically represent this data for potential modification at a later stage without delving into the actual function\u0027s implementation.\n\nPlease let me know if you still disagree.",
      "parentUuid": "03bf1a75_10f8729c",
      "revId": "111b095be07f5d957bf2e7c0ab52490d362eef71",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "660e7fc7_4626c423",
        "filename": "plat/arm/board/fvp/fvp_plat_attest_token.c",
        "patchSetId": 4
      },
      "lineNbr": 12,
      "author": {
        "id": 1000272
      },
      "writtenOn": "2023-10-10T16:03:36Z",
      "side": 1,
      "message": "The data has to live somewhere in the binary, regardless of how it\u0027s defined. adding it to the stack is a waste of stack space, as it is immediately copied out into the passed-in buffer",
      "parentUuid": "d2d987cd_56aea3f1",
      "revId": "111b095be07f5d957bf2e7c0ab52490d362eef71",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ea6a9379_9a63d7c0",
        "filename": "plat/arm/board/fvp/fvp_plat_attest_token.c",
        "patchSetId": 4
      },
      "lineNbr": 12,
      "author": {
        "id": 1000328
      },
      "writtenOn": "2023-10-11T07:45:32Z",
      "side": 1,
      "message": "\u003e The data has to live somewhere in the binary,\n\nI\u0027m not entirely certain I understood you correctly, but the core idea is that we want to avoid permanently storing this data in the binary. To clarify further, here are the reasons for not using this array as a static one:\n\nWe want to avoid storing this array in the binary, as it\u0027s a temporary or throwaway data. It is better is to prevent unnecessary growth in the data section and, consequently, the overall binary size.\n\nLocally storing this large array might increase temporary stack usage but still way within the PLATFORM_STACK_SIZE. IMO, this is a more favourable choice than increasing the overall binary size.\n\nAlso, I don\u0027t foresee any frequent changes (size-wise) in this dummy array.",
      "parentUuid": "660e7fc7_4626c423",
      "revId": "111b095be07f5d957bf2e7c0ab52490d362eef71",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2df76ba4_090b8212",
        "filename": "plat/arm/board/fvp/fvp_plat_attest_token.c",
        "patchSetId": 4
      },
      "lineNbr": 12,
      "author": {
        "id": 1000272
      },
      "writtenOn": "2023-10-19T19:53:41Z",
      "side": 1,
      "message": "\u003e We want to avoid storing this array in the binary, \n\nIf the data is non-zero, this is impossible without hand-written code to generate the data at runtime. and with data this small, I don\u0027t think that would be much of a savings, especially compared to the effort to create something bespoke like that.\n\n\u003e Locally storing this large array might increase temporary stack usage but still way within the PLATFORM_STACK_SIZE. \n\nThis actually copies from a data suffix section into the stack, which is actually worse than if it were its own symbol, but I don\u0027t think the small runtime hit here would be that important.\n\n\u003e IMO, this is a more favourable choice than increasing the overall binary size.\n\nThe binary size goes up regardless, so this is mostly about how readable and maintainable the code is.",
      "parentUuid": "ea6a9379_9a63d7c0",
      "revId": "111b095be07f5d957bf2e7c0ab52490d362eef71",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c7e1c06a_41bbb94a",
        "filename": "plat/arm/board/fvp/fvp_plat_attest_token.c",
        "patchSetId": 4
      },
      "lineNbr": 12,
      "author": {
        "id": 1000328
      },
      "writtenOn": "2023-10-20T09:08:12Z",
      "side": 1,
      "message": "There are two options-\n1. Static array in the global or file scope.\n2. Array on the stack, as a local variable\n\nCurrently the code is using option 2, the array is generated when the function that contains it is invoked. We must determine the array\u0027s maximum size during compilation. In the event of an exceedingly large array, a stack overflow error may occur, and this would be detected at runtime (I don\u0027t see we are encountering this case here as it is not that big array and as mentioned earlier it is always fixed so very rare chance of getting stack overflow). \nAlso, this is a dummy function and can\u0027t be used for not real use case, it is just to give the hardcoded data (instead of invoking any RSS call) back to caller so performance penalty is okay in this case instead of increasing the binary size. What do you say?",
      "parentUuid": "2df76ba4_090b8212",
      "revId": "111b095be07f5d957bf2e7c0ab52490d362eef71",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7ab502d9_c3198939",
        "filename": "plat/arm/board/fvp/fvp_plat_attest_token.c",
        "patchSetId": 4
      },
      "lineNbr": 12,
      "author": {
        "id": 1000043
      },
      "writtenOn": "2023-10-23T06:52:52Z",
      "side": 1,
      "message": "I don\u0027t really mind whether we use a macro or not but couple of things I wanted to mention.\n\nI agree with Jimmy: the way the patch is written right now, the data from lines 13 to 96 has to be stored in some data section. Most likely in the .rodata section. Thus it will take space in the binary, even though it might not have a symbol in the symbol table associated to it. The array cannot just be generated when the function that contains it is invoked, that\u0027s impossible, how would the compiler know how to make up the data? If you want to convince yourself, try to disassemble BL31 binary and you should be able to spot this data.\n\nIf we go for the other option, which is to store the data into a static array (but not a const one), then the data should end up in the .data section. Different ELF section than if we go for the first option but it\u0027s taking an equal amount of space.\n\nSecondly, I am not sure about BL31\u0027s ability to flag stack overflows... I might be wrong but I remember hitting strange bugs in the past, finally to find out some time after that there were due to a stack overflow. IOW I don\u0027t think BL31 provided any help / error message in flagging stack overflows. Things might have changed since then, though! But it would be worth double-checking this.",
      "parentUuid": "c7e1c06a_41bbb94a",
      "revId": "111b095be07f5d957bf2e7c0ab52490d362eef71",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1c0e572d_c634485e",
        "filename": "plat/arm/board/fvp/fvp_plat_attest_token.c",
        "patchSetId": 4
      },
      "lineNbr": 12,
      "author": {
        "id": 1000272
      },
      "writtenOn": "2023-10-24T14:50:46Z",
      "side": 1,
      "message": "Manish disassembled this the other day, and my analysis is that it\u0027s allocating a _lot_ of stack:\n```\n000000000400c4a4 \u003cplat_rmmd_get_cca_attest_token\u003e:\n 400c4a4:\td10b43ff \tsub\tsp, sp, #0x2d0\n```\n\nand that it copies twice:\n```\n 400c4bc:\tf0000021 \tadrp\tx1, 4013000 \u003c__TEXT_END_UNALIGNED__\u003e\n 400c4c0:\taa1403e2 \tmov\tx2, x20\n 400c4c4:\t913f2021 \tadd\tx1, x1, #0xfc8\n 400c4c8:\tf90013f5 \tstr\tx21, [sp, #32]\n 400c4cc:\taa0003f5 \tmov\tx21, x0\n 400c4d0:\t9100c3e0 \tadd\tx0, sp, #0x30\n 400c4d4:\t97fffc95 \tbl\t400b728 \u003cmemcpy\u003e\n 400c4d8:\tf9400260 \tldr\tx0, [x19]\n 400c4dc:\tf10a7c1f \tcmp\tx0, #0x29f\n 400c4e0:\t54000189 \tb.ls\t400c510 \u003cplat_rmmd_get_cca_attest_token+0x6c\u003e  // b.plast\n 400c4e4:\taa1403e2 \tmov\tx2, x20\n 400c4e8:\t9100c3e1 \tadd\tx1, sp, #0x30\n 400c4ec:\taa1503e0 \tmov\tx0, x21\n 400c4f0:\t97fffc8e \tbl\t400b728 \u003cmemcpy\u003e\n```\n\nNote the 2 calls to memcpy; the branch less than is to an error snippet below the return; the data is coming from the .rodata section, as Sandrine speculated.\n\nTake a reference to a static or static const could eliminate both the huge stack allocation and the first copy.",
      "parentUuid": "7ab502d9_c3198939",
      "revId": "111b095be07f5d957bf2e7c0ab52490d362eef71",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c46d0587_6da1c9e4",
        "filename": "plat/arm/board/fvp/fvp_plat_attest_token.c",
        "patchSetId": 4
      },
      "lineNbr": 12,
      "author": {
        "id": 1000043
      },
      "writtenOn": "2023-10-24T15:19:51Z",
      "side": 1,
      "message": "Thanks for the analysis, Jimmy.\n\nSo is the first `memcpy()` copying the data from the .rodata section to the array `sample_platform_token[]` onto the stack then? And the second `memcpy()` would copy the latter to the `buf` array provided as a function argument?\n\nIt\u0027s a shame the compiler was not able to see that `sample_platform_token[]` is only used as a temporary buffer and copy the data straight from .rodata to the caller-provided `buf`... Which optimization flags have you been using? I believe TF-A is compiled with `-Os` by default but I can\u0027t imagine generating 2 memcpy() calls makes for smaller code/data footprint... If anything, having a single `memcpy()` should result in smaller code!\n\nAny idea why the compiler is behaving like that? Just curious. I think you\u0027ve proved your point, Jimmy, and that we should go for the static const array solution in any case.",
      "parentUuid": "1c0e572d_c634485e",
      "revId": "111b095be07f5d957bf2e7c0ab52490d362eef71",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bed197d0_ba12c0bc",
        "filename": "plat/arm/board/fvp/fvp_realm_attest_key.c",
        "patchSetId": 4
      },
      "lineNbr": 12,
      "author": {
        "id": 1000272
      },
      "writtenOn": "2023-10-09T21:26:13Z",
      "side": 1,
      "message": "Same comment on needless macro use here.",
      "revId": "111b095be07f5d957bf2e7c0ab52490d362eef71",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    }
  ]
}