{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "186bf835_c82ef53c",
        "filename": "services/std_svc/spm/el3_spmc/spmc_setup.c",
        "patchSetId": 54
      },
      "lineNbr": 31,
      "author": {
        "id": 1000655
      },
      "writtenOn": "2023-02-03T17:10:40Z",
      "side": 1,
      "message": "Hi, coming back to this topic, we try to use the FF-A boot protocol on Hikey960.\nWhat we find: the SEL1 cannot see this memory on boot.\nWith the Lauterbach/JTAG, we see ffa_boot_info_mem content, e.g. boot info and device tree at the M: mapping, but not in the Z: mapping.\nHowever, we can see mapping I created for the device tree in this patch:\nhttps://review.trustedfirmware.org/c/TF-A/trusted-firmware-a/+/16284\n\nMaybe some mapping function need to be called such that SEL1 can see also this memory. Or call some cache flush? It looks like an alias issue.",
      "revId": "2e21921502b1317031cf2a2f69c5d47ac88a505d",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "32c22f33_ff226c65",
        "filename": "services/std_svc/spm/el3_spmc/spmc_setup.c",
        "patchSetId": 54
      },
      "lineNbr": 31,
      "author": {
        "id": 1000290
      },
      "writtenOn": "2023-02-08T10:03:35Z",
      "side": 1,
      "message": "IIUC S-EL1 should be able to map the address it recieves from the SPMC into its own adress space and then access the content. Are you currently creating this mapping in SEL1 or is this the part that is having issues?",
      "parentUuid": "186bf835_c82ef53c",
      "revId": "2e21921502b1317031cf2a2f69c5d47ac88a505d",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0d6ad2d3_d9d5a73d",
        "filename": "services/std_svc/spm/el3_spmc/spmc_setup.c",
        "patchSetId": 54
      },
      "lineNbr": 31,
      "author": {
        "id": 1000655
      },
      "writtenOn": "2023-02-08T11:03:59Z",
      "side": 1,
      "message": "In the past, we can access \"x0\" content directly without setting up any mapping. We just copy the buffer to a memory area we control and then throw away x0 content.\nOnly then we setup MMU tables and activate our MMU settings.\n\nI try to use the memory without creating a mapping.\nIs this not possible?\nWhat needs to be done in EL3 for this to work?",
      "parentUuid": "32c22f33_ff226c65",
      "revId": "2e21921502b1317031cf2a2f69c5d47ac88a505d",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6d5dd995_556bba9e",
        "filename": "services/std_svc/spm/el3_spmc/spmc_setup.c",
        "patchSetId": 54
      },
      "lineNbr": 31,
      "author": {
        "id": 1000290
      },
      "writtenOn": "2023-02-08T16:01:48Z",
      "side": 1,
      "message": "Thanks for the information. S-EL1 should have access to the full address space and therefore able to access the memory. \n\nThe SPMC should be writing to the memory with the caches enabled as it expects the memory to be mapped with the attributes listed in section 5.4.4. Therefore, if the MMU is not enabled at this stage in S-EL1, then agree it could be an cache issue and may require flushing before the data becomes visible. \n\nWould you be able to perform a cache flush on the provided memory address from S-EL1 and see if that allows the data to be accessed?",
      "parentUuid": "0d6ad2d3_d9d5a73d",
      "revId": "2e21921502b1317031cf2a2f69c5d47ac88a505d",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4a597d16_e0cd6988",
        "filename": "services/std_svc/spm/el3_spmc/spmc_setup.c",
        "patchSetId": 54
      },
      "lineNbr": 31,
      "author": {
        "id": 1000655
      },
      "writtenOn": "2023-02-21T09:59:19Z",
      "side": 1,
      "message": "The cache flush works.\nHowever, we did the cache flush in SPMC, just after writing this data.\n\nToday, we do our memcpy in SEL1 before switching on MMU.\nSo it is easy to do the cache flush in SPMC, since we already have MMU and run in C code.\nPossibly we could rewrite our boot code to just store the pointer, switch on MMU, and then try to retrieve this data, map in the physical page of bootargs into the MMU, flush cache and then continue with the parsing code.",
      "parentUuid": "6d5dd995_556bba9e",
      "revId": "2e21921502b1317031cf2a2f69c5d47ac88a505d",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3c1be0f6_cb987919",
        "filename": "services/std_svc/spm/el3_spmc/spmc_setup.c",
        "patchSetId": 54
      },
      "lineNbr": 126,
      "author": {
        "id": 1000655
      },
      "writtenOn": "2023-02-03T17:10:40Z",
      "side": 1,
      "message": "I wonder about the rational for the memcpy.",
      "revId": "2e21921502b1317031cf2a2f69c5d47ac88a505d",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "38045f9a_e964b30e",
        "filename": "services/std_svc/spm/el3_spmc/spmc_setup.c",
        "patchSetId": 54
      },
      "lineNbr": 126,
      "author": {
        "id": 1000290
      },
      "writtenOn": "2023-02-08T10:03:35Z",
      "side": 1,
      "message": "See comment below.",
      "parentUuid": "3c1be0f6_cb987919",
      "revId": "2e21921502b1317031cf2a2f69c5d47ac88a505d",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e3ca9b37_65bfbfd1",
        "filename": "services/std_svc/spm/el3_spmc/spmc_setup.c",
        "patchSetId": 54
      },
      "lineNbr": 126,
      "author": {
        "id": 1000655
      },
      "writtenOn": "2023-02-08T11:03:59Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "38045f9a_e964b30e",
      "revId": "2e21921502b1317031cf2a2f69c5d47ac88a505d",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0c6738c0_cafba694",
        "filename": "services/std_svc/spm/el3_spmc/spmc_setup.c",
        "patchSetId": 54
      },
      "lineNbr": 129,
      "author": {
        "id": 1000655
      },
      "writtenOn": "2023-02-03T17:10:40Z",
      "side": 1,
      "message": "Why did you not simply store the address from ep_info-\u003eargs.arg0 here?",
      "revId": "2e21921502b1317031cf2a2f69c5d47ac88a505d",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "87017959_f27f63b8",
        "filename": "services/std_svc/spm/el3_spmc/spmc_setup.c",
        "patchSetId": 54
      },
      "lineNbr": 129,
      "author": {
        "id": 1000290
      },
      "writtenOn": "2023-02-08T10:03:35Z",
      "side": 1,
      "message": "The design of the boot protocol was to be a self contained structure, including the protocol header, descriptor array and its payloads. In this implementation we currently have a single entry in the descriptor and its accosiated SP manifest blob. Therefore we need to copy the manifest from its original location into the page of memory that is to be shared with the SP via the boot protocol.",
      "parentUuid": "0c6738c0_cafba694",
      "revId": "2e21921502b1317031cf2a2f69c5d47ac88a505d",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7e642e96_75c29741",
        "filename": "services/std_svc/spm/el3_spmc/spmc_setup.c",
        "patchSetId": 54
      },
      "lineNbr": 129,
      "author": {
        "id": 1000655
      },
      "writtenOn": "2023-02-08T11:03:59Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "87017959_f27f63b8",
      "revId": "2e21921502b1317031cf2a2f69c5d47ac88a505d",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    }
  ]
}