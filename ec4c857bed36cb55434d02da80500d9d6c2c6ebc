{
  "comments": [
    {
      "key": {
        "uuid": "71f21e92_59f60505",
        "filename": "bl31/aarch64/runtime_exceptions.S",
        "patchSetId": 2
      },
      "lineNbr": 95,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2020-11-06T01:17:06Z",
      "side": 1,
      "message": "nit picking here, but there may not be much we can do: If this particular store causes an SError and is taken before CTX_IS_IN_EL3 is set, we will think that the SError came from lower exception level. Is that right ?",
      "range": {
        "startLine": 95,
        "startChar": 1,
        "endLine": 95,
        "endChar": 54
      },
      "revId": "ec4c857bed36cb55434d02da80500d9d6c2c6ebc",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "57cb20bd_0c729c10",
        "filename": "bl31/aarch64/runtime_exceptions.S",
        "patchSetId": 2
      },
      "lineNbr": 95,
      "author": {
        "id": 1000098
      },
      "writtenOn": "2020-11-06T21:36:55Z",
      "side": 1,
      "message": "Hi Raghu,\nI have to admit that this patch is not an elegant solution to the problem at hand. As you mentioned, there is not much I could do. I made the na√Øve assumption that instructions 95-99 execute without causing any further exceptions. In case these instructions cause SError, yes, we (wrongly) attribute the SError to be because of Lower ELs. Moreover, I believe an SError triggered by memory accesses in EL3 is a bigger problem. One particular reason why I made this assumption is that stack at SP_EL3 is probably much safer compared to runtime stack(SP_EL0). Not sure if my assumption makes sense.\n\nLet me know your thoughts.",
      "parentUuid": "71f21e92_59f60505",
      "range": {
        "startLine": 95,
        "startChar": 1,
        "endLine": 95,
        "endChar": 54
      },
      "revId": "ec4c857bed36cb55434d02da80500d9d6c2c6ebc",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8a191c30_2bdabb7e",
        "filename": "bl31/aarch64/runtime_exceptions.S",
        "patchSetId": 2
      },
      "lineNbr": 95,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2020-11-09T17:19:52Z",
      "side": 1,
      "message": "I dont know that the memory pointed to by SP_EL3 is safer than SP_EL0. Typically they live around the same region and i dont know the characteristics of SRAM or DRAM well enough to know if it is safer.\n\nI do agree there is not much we can do. I was thinking out loud to make sure i understand correctly.\n\nA comment to the effect \"This is not a bullet proof solution because we assume 95-99 can execute without causing further exception might help\". If not comments, it might be worth explaining in the commit message. Feel free to ignore this suggestion.",
      "parentUuid": "57cb20bd_0c729c10",
      "range": {
        "startLine": 95,
        "startChar": 1,
        "endLine": 95,
        "endChar": 54
      },
      "revId": "ec4c857bed36cb55434d02da80500d9d6c2c6ebc",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "641e7f01_3ca5f4d3",
        "filename": "bl31/aarch64/runtime_exceptions.S",
        "patchSetId": 2
      },
      "lineNbr": 95,
      "author": {
        "id": 1000098
      },
      "writtenOn": "2020-11-10T01:25:46Z",
      "side": 1,
      "message": "Ack. I will put the comment here as well as in the commit message.",
      "parentUuid": "8a191c30_2bdabb7e",
      "range": {
        "startLine": 95,
        "startChar": 1,
        "endLine": 95,
        "endChar": 54
      },
      "revId": "ec4c857bed36cb55434d02da80500d9d6c2c6ebc",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a6f3c771_c94f05da",
        "filename": "bl31/aarch64/runtime_exceptions.S",
        "patchSetId": 2
      },
      "lineNbr": 148,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2020-11-06T01:17:06Z",
      "side": 1,
      "message": "do we not need to save x19 here? if you get the SError interrupt between str x19(line 132) in handle_async_ea, the original x19 will be clobbered. same with check and unmask ea.. is that not a problem ? maybe i\u0027m missing something..",
      "range": {
        "startLine": 148,
        "startChar": 3,
        "endLine": 148,
        "endChar": 30
      },
      "revId": "ec4c857bed36cb55434d02da80500d9d6c2c6ebc",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b9a0fb3e_6d272f1b",
        "filename": "bl31/aarch64/runtime_exceptions.S",
        "patchSetId": 2
      },
      "lineNbr": 148,
      "author": {
        "id": 1000098
      },
      "writtenOn": "2020-11-06T21:36:55Z",
      "side": 1,
      "message": "Based on my assumption as stated above, I assumed x19 to be safely saved to the cpu_context structure at SP_EL3. If instruction 133 triggered an SError, wouldnt trying to save x19 here lead to endless aborts? I am sorry if I misunderstood your comments.",
      "parentUuid": "a6f3c771_c94f05da",
      "range": {
        "startLine": 148,
        "startChar": 3,
        "endLine": 148,
        "endChar": 30
      },
      "revId": "ec4c857bed36cb55434d02da80500d9d6c2c6ebc",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b8f6d3ad_4bcb558b",
        "filename": "bl31/aarch64/runtime_exceptions.S",
        "patchSetId": 2
      },
      "lineNbr": 148,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2020-11-09T17:19:52Z",
      "side": 1,
      "message": "NP. Let me try again. in both check_and_unmask_ea and handle_async_ea, it is possible to get an SError right after the ISB instruction since we just synchronized pending aborts with the DSB above. So between line 92 and 95, or line 130 and 133, if we see an Serror, we will enter check_if_serror_from_el3(since we land on serror_sp_elx vector) and x19 would not have been saved. This is more likely to happen between line 92 and 95, than between 130 and 133 because handle_async_ea is already entered on an SError from lower EL\u0027s.\n\nSo check_if_serror_from_EL3 needs to save x19.\n\nIf the SError occurs immediately after the str that save x19(line 95,133), we are safe and we need not save x19 save(but no harm in doing it again anyway).\n\nIf the SError occurs after x19 is clobbered(line 96, 134), then check_if_serror_from_EL3 saving x19 will trash the x19 value. I don\u0027t know that this can be avoided.\n\nIt seems like it depends on what we think is the most likely of the above three scenarios and i thought the SError immediately after the ISB is most likely, in which case saving x19 in check_if_serror_from_EL3 would preserve the value.\n\nLet me know what you think.",
      "parentUuid": "b9a0fb3e_6d272f1b",
      "range": {
        "startLine": 148,
        "startChar": 3,
        "endLine": 148,
        "endChar": 30
      },
      "revId": "ec4c857bed36cb55434d02da80500d9d6c2c6ebc",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9c40280c_96b95c3c",
        "filename": "bl31/aarch64/runtime_exceptions.S",
        "patchSetId": 2
      },
      "lineNbr": 148,
      "author": {
        "id": 1000098
      },
      "writtenOn": "2020-11-10T01:25:46Z",
      "side": 1,
      "message": "Thanks a lot for the clear explanation. I will make the necessary fix.",
      "parentUuid": "b8f6d3ad_4bcb558b",
      "range": {
        "startLine": 148,
        "startChar": 3,
        "endLine": 148,
        "endChar": 30
      },
      "revId": "ec4c857bed36cb55434d02da80500d9d6c2c6ebc",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    }
  ]
}