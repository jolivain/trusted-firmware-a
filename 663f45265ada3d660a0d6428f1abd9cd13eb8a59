{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "16e40c03_cdffd0fd",
        "filename": "include/arch/aarch64/el3_common_macros.S",
        "patchSetId": 1
      },
      "lineNbr": 245,
      "author": {
        "id": 1000883
      },
      "writtenOn": "2023-03-01T16:00:21Z",
      "side": 1,
      "message": "does this have to happen at reset? Couldn\u0027t it be delayed until some time in context management?",
      "revId": "663f45265ada3d660a0d6428f1abd9cd13eb8a59",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3e728250_3594c4e0",
        "filename": "include/arch/aarch64/el3_common_macros.S",
        "patchSetId": 1
      },
      "lineNbr": 245,
      "author": {
        "id": 1000390
      },
      "writtenOn": "2023-03-01T17:37:41Z",
      "side": 1,
      "message": "This change is done where the cptr_el3 is initialized for the root world. The generic context management code in the later stages modifies and saves cptr_el3 value in the cpu_context and later programs its to cptr_el3 register upon exit from el3.",
      "parentUuid": "16e40c03_cdffd0fd",
      "revId": "663f45265ada3d660a0d6428f1abd9cd13eb8a59",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3e9591dd_9df4d170",
        "filename": "include/arch/aarch64/el3_common_macros.S",
        "patchSetId": 1
      },
      "lineNbr": 245,
      "author": {
        "id": 1000883
      },
      "writtenOn": "2023-03-02T18:10:08Z",
      "side": 1,
      "message": "Sure, but there is no root context yet. On the first el3_exit this register will be overwritten by whatever the outgoing context says and the value above will never be written back. If this bit is necessary for ctx_save/restore, then the short-term solution would be that it should be set somewhere closer to them and el3_exit can overwrite it later. This will also help with refactoring the code for the long-term solution - the root context.",
      "parentUuid": "3e728250_3594c4e0",
      "revId": "663f45265ada3d660a0d6428f1abd9cd13eb8a59",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f43ec403_711b4efd",
        "filename": "include/arch/aarch64/el3_common_macros.S",
        "patchSetId": 1
      },
      "lineNbr": 245,
      "author": {
        "id": 1000390
      },
      "writtenOn": "2023-03-03T15:14:07Z",
      "side": 1,
      "message": "This value to cptr_el3 is required before the first el3_exit happens as part of restoring el2 sysregs context.\n\u003e the value above will never be written back.\nThis value will be retained as enabling SVE_FOR_NS and CTX_INCLUDE_EL2_REGS, will set this bit as part of sve_enable extension call. Setting this bit closer to el2_ctx_save/restore is not clean and will force to add an isb. I agree that this can be later refactored when adding support for root cpu_ctx.",
      "parentUuid": "3e9591dd_9df4d170",
      "revId": "663f45265ada3d660a0d6428f1abd9cd13eb8a59",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c75806cc_28942bdb",
        "filename": "include/arch/aarch64/el3_common_macros.S",
        "patchSetId": 1
      },
      "lineNbr": 245,
      "author": {
        "id": 1000883
      },
      "writtenOn": "2023-03-03T17:48:53Z",
      "side": 1,
      "message": "\u003e enabling SVE_FOR_NS and CTX_INCLUDE_EL2_REGS, will set this bit as part of sve_enable extension call\n\nApologies, I hadn\u0027t seen this. Regardless, something similar is done in lib/el3_runtime/aarch64/context.S:1179. Also, wouldn\u0027t this blow up in secure world with ENABLE_SVE_FOR_SWD not set? Then sve would explicitly be disabled in secure world, and by extension EL3, since it won\u0027t be changed on the return path, then it won\u0027t have access.",
      "parentUuid": "f43ec403_711b4efd",
      "revId": "663f45265ada3d660a0d6428f1abd9cd13eb8a59",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "177b90f7_fcc61778",
        "filename": "include/arch/aarch64/el3_common_macros.S",
        "patchSetId": 1
      },
      "lineNbr": 245,
      "author": {
        "id": 1000390
      },
      "writtenOn": "2023-03-06T15:20:47Z",
      "side": 1,
      "message": "\u003e secure world with ENABLE_SVE_FOR_SWD not set\nI see your concern, the current design is that, if SVE is enabled for NS world then secure world must enable SVE, even if wants to only use floating point. So any SEL1 TOS (SPD\u003d\u003clegacy dispatcher\u003e) or SEL2 SPM (SPD\u003dspmd) must set ENABLE_SVE_FOR_SWD\u003d1 if it wants to use SVE in NS world and use FP or SVE in secure world.\n\nWithout S-EL2 or R-EL2, the NS world can enable SVE and disable it for Secure world, in that case setting is bit in cptr_el3 will be skipped as it is used only when saving/restoring el2 context register.",
      "parentUuid": "c75806cc_28942bdb",
      "revId": "663f45265ada3d660a0d6428f1abd9cd13eb8a59",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    }
  ]
}