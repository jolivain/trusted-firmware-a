{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "1545b096_5b305c12",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 8
      },
      "lineNbr": 0,
      "author": {
        "id": 1000103
      },
      "writtenOn": "2022-07-11T07:34:06Z",
      "side": 1,
      "message": "Tested OK on STM32MP157C-DK2 board",
      "revId": "fedea432b7ea41249e5c9bb18b03ae1f851600a9",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c9bd0b93_5183be5a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 8
      },
      "lineNbr": 0,
      "author": {
        "id": 1000162
      },
      "writtenOn": "2022-08-08T15:11:26Z",
      "side": 1,
      "message": "It is not clear why the platform handlers need updates and what the use case is. It should be call the gic APIs directly from the platform.",
      "revId": "fedea432b7ea41249e5c9bb18b03ae1f851600a9",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "cdb948d9_33e56f80",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 8
      },
      "lineNbr": 0,
      "author": {
        "id": 1000707
      },
      "writtenOn": "2022-08-12T09:54:42Z",
      "side": 1,
      "message": "As far as ProvenCore is concerned, we use SGIs as a way for Linux and the TEE to both signal to the other one that a message is available in a shared memory used as a communication channel between the two. Each NS-to-S and S-to-NS SGI is raised by the TF-A when a dedicated SMC is received. Generating an SGI from NS to S directly from NS-EL1 is not possible on platforms with a GICv2, hence the choice of a generic implementation with dedicated SMCs.\n\nBecause the handlers for these SMCs are platform independent (implemented in services/spd/pncd), we need generic plat_ic_raise_ns_sgi and plat_ic_raise_s_el1_sgi functions, in the same way as plat_ic_raise_el3_sgi.",
      "parentUuid": "c9bd0b93_5183be5a",
      "revId": "fedea432b7ea41249e5c9bb18b03ae1f851600a9",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c2e6af02_20e70304",
        "filename": "drivers/arm/gic/v2/gicv2_main.c",
        "patchSetId": 8
      },
      "lineNbr": 2,
      "author": {
        "id": 1000162
      },
      "writtenOn": "2022-08-08T15:11:26Z",
      "side": 1,
      "message": "I recommend adding your worn copyright header instead",
      "range": {
        "startLine": 2,
        "startChar": 25,
        "endLine": 2,
        "endChar": 26
      },
      "revId": "fedea432b7ea41249e5c9bb18b03ae1f851600a9",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "06031b7b_cec5c036",
        "filename": "drivers/arm/gic/v2/gicv2_main.c",
        "patchSetId": 8
      },
      "lineNbr": 2,
      "author": {
        "id": 1000707
      },
      "writtenOn": "2022-08-12T09:54:42Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "c2e6af02_20e70304",
      "range": {
        "startLine": 2,
        "startChar": 25,
        "endLine": 2,
        "endChar": 26
      },
      "revId": "fedea432b7ea41249e5c9bb18b03ae1f851600a9",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a17d443b_bafae3c0",
        "filename": "drivers/arm/gic/v2/gicv2_main.c",
        "patchSetId": 8
      },
      "lineNbr": 2,
      "author": {
        "id": 1000707
      },
      "writtenOn": "2022-08-12T10:18:15Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "06031b7b_cec5c036",
      "range": {
        "startLine": 2,
        "startChar": 25,
        "endLine": 2,
        "endChar": 26
      },
      "revId": "fedea432b7ea41249e5c9bb18b03ae1f851600a9",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "657b80c9_e53ab9b4",
        "filename": "drivers/arm/gic/v3/gicv3_main.c",
        "patchSetId": 8
      },
      "lineNbr": 1147,
      "author": {
        "id": 1000098
      },
      "writtenOn": "2022-08-08T17:58:46Z",
      "side": 1,
      "message": "I feel we dont need gicv3_irq_group_t group argument. Can you instead leverage gicv3_get_interrupt_type() ? Let me know.\n\nswitch (gicv3_get_interrupt_type(sgi_num, plat_my_core_pos()) {\ncase INTR_TYPE_EL3:\n\ncase INTR_TYPE_NS:\n\ncase INTR_TYPE_S_EL1:\n\ndefault:\n\n}",
      "range": {
        "startLine": 1134,
        "startChar": 0,
        "endLine": 1147,
        "endChar": 2
      },
      "revId": "fedea432b7ea41249e5c9bb18b03ae1f851600a9",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "52738cd0_8dd8e0ce",
        "filename": "drivers/arm/gic/v3/gicv3_main.c",
        "patchSetId": 8
      },
      "lineNbr": 1147,
      "author": {
        "id": 1000707
      },
      "writtenOn": "2022-08-12T09:54:42Z",
      "side": 1,
      "message": "I am not sure. It should indeed be possible, but I think the correct way to implement it would be to switch on gicv3_get_interrupt_type(sgi_num, plat_core_pos_by_mpidr(target)). This means that we will access the GICR_IGROUPR and GICR_IGRPMODR registers of the GIC redistributor of another CPU. Isn\u0027t it somewhat dangerous? Shouldn\u0027t we be aware of possible hardware access control mechanisms on some platforms which may prevent us from accessing the redistributor of another CPU? It seems to me that the programming model of the GICv3 (see for instance \"8.1.10 Use of control registers for SGI forwarding\" in ARM IHI 0069C) is that the source CPU decides which kind of SGI is supposed to be raised (through the choice of the ICC_[A]SGI{0,1}R register) and the destination CPU independently affects a group to each SGI. The target\u0027s GIC redistributor then gets to decide whether to signal the interrupt based on both configurations. This is also coherent with the previous implementation of gicv3_raise_secure_g0_sgi, which was not checking that the specified SGI was indeed configured as group 0 in the target\u0027s redistributor.\n\nWhat do you think? Should I still go on with discarding the group parameter and using gicv3_get_interrupt_type instead?",
      "parentUuid": "657b80c9_e53ab9b4",
      "range": {
        "startLine": 1134,
        "startChar": 0,
        "endLine": 1147,
        "endChar": 2
      },
      "revId": "fedea432b7ea41249e5c9bb18b03ae1f851600a9",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5c8ed64c_f4414bc1",
        "filename": "drivers/arm/gic/v3/gicv3_main.c",
        "patchSetId": 8
      },
      "lineNbr": 1147,
      "author": {
        "id": 1000098
      },
      "writtenOn": "2022-08-12T21:21:03Z",
      "side": 1,
      "message": "It looks like gicv3_get_interrupt_type(sgi_num, plat_core_pos_by_mpidr(target)) is already used in the parent function (for example plat_ic_raise_el3_sgi() [1]). I am not sure either if this is dangerous. Since its a read access, may be its not much of a risk. \n\nCan you simply pass the interrupt type (eg: INTR_TYPE_EL3) as the argument instead of  gicv3_irq_group_t GICV3_G0? Let me know your thoughts on this.\n\n[1] https://review.trustedfirmware.org/c/TF-A/trusted-firmware-a/+/11339/8/plat/common/plat_gicv3.c#244",
      "parentUuid": "52738cd0_8dd8e0ce",
      "range": {
        "startLine": 1134,
        "startChar": 0,
        "endLine": 1147,
        "endChar": 2
      },
      "revId": "fedea432b7ea41249e5c9bb18b03ae1f851600a9",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "00cfb8ef_72119e77",
        "filename": "drivers/arm/gic/v3/gicv3_main.c",
        "patchSetId": 8
      },
      "lineNbr": 1147,
      "author": {
        "id": 1000707
      },
      "writtenOn": "2022-08-22T08:10:36Z",
      "side": 1,
      "message": "The plat_ic_raise_*_sgi functions indeed call plat_ic_get_interrupt_type, but the call is made in an assert. It seemed to me that doing this verification in an assert is somewhat coherent with the programming model of the GIC: it is expected---but not required---that the SGI is configured on the destination CPU in a way that matches the group that the calling CPU was expecting. As it is called in an assert, I assume plat_ic_get_interrupt_type is actually not called when raising a SGI on most of the production platforms. Actually, it seems to me that there is an issue with this assert when all the following conditions hold:\n- the target CPU is different from the CPU calling plat_ic_raise_*_sgi\n- the configured group for this SGI on the target CPU is different from the expected group\n- the configured group for this SGI on the current CPU is indeed the expected group\nIndeed, plat_ic_get_interrupt_type does not take the target CPU as a parameter and always reads the GIC registers for the current CPU to determine the configured group. In the case I was mentioning, the assert will succeed, although the configuration on the target CPU is not as expected. Conversely, the assert could also fail while the configuration on the target CPU is correct.\n\nAs far as gicv3_irq_group_t is concerned, I can indeed replace it by a INTR_TYPE_* parameter. I initially introduced this new enum type as it seemed to me that it was more coherent with the GIC driver implementation in the TF-A: as far as I understand it, INTR_TYPE_* are abstract interrupt types which are used in the code base when calling generic interrupt functions (plat_ic_*). These abstract interrupt types are then translated by each specific ic driver implementation to a concrete group. For instance, in the GICv2 implementation, the GICV2_G0_FOR_EL3 compilation option is used in the generic function plat_ic_get_interrupt_type to map a concrete group (either GIV2_INTR_GROUP0 or GIV2_INTR_GROUP1) to the correct abstract interrupt type (INTR_TYPE_NS and INTR_TYPE_EL3 or INTR_TYPE_S_EL1 depending on GICV2_G0_FOR_EL3).\n\nIf I change the gicv3_raise_sgi signature to take a INTR_TYPE_* parameter, we need to choose between these 2 options:\n- either we also change the giv2_raise_sgi signature to take an INTR_TYPE_* parameter and we will have to test GICV2_G0_FOR_EL3 in drivers/arm/gic/v2/giv2_main.c, which was until now agnostic of such a feature (this file only deals with concrete interrupt groups)\n- or we leave gicv2_raise_sgi as it is. In this case, we will end up with gicv2_raise_sgi taking concrete interrupt types (in the form of a boolean saying whether the raised SGI should be S or NS) and gicv3_raise_sgi taking abstract INTR_TYPE_* interrupt types. It seems to be that this would be a bit confusing, but I am fine with doing this change if you wish so.\n\nCould you confirm me that you still think removing the newly introduced gicv3_irq_group_t type is the best way to go? And, in this case, which of the 2 proposed options you prefer?\n\nThank you",
      "parentUuid": "5c8ed64c_f4414bc1",
      "range": {
        "startLine": 1134,
        "startChar": 0,
        "endLine": 1147,
        "endChar": 2
      },
      "revId": "fedea432b7ea41249e5c9bb18b03ae1f851600a9",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d5c7eed4_de8a323b",
        "filename": "drivers/arm/gic/v3/gicv3_main.c",
        "patchSetId": 8
      },
      "lineNbr": 1147,
      "author": {
        "id": 1000098
      },
      "writtenOn": "2022-08-27T22:30:47Z",
      "side": 1,
      "message": "Thank you for the detailed response! Your observations regarding a possible mismatch between how an SGI is configured/perceived by current vs target CPU is very interesting.\n\nI looked into how TF-A gic driver configures the interrupt type(INTR_TYPE_*) for a specific interrupt ID. It looks like a particular interrupt (lets say ARM_IRQ_SEC_SGI_7 which is SGI 15 for Xilinx zynqmp ) is statically defined to be of a particular type through appropriate macros in the platform header file[1]. This marco (PLAT_ARM_G1S_IRQ_PROPS) further expands to a interrupt descriptor data structure that later gets fed to the GIC driver[2], [3]. This makes me believe that, programatically, it is legal for a current CPU to read the interrupt type, for a target CPU, by accessing its own redistributor registers. \n\nMoreover, I believe, it is the responsibility of the firmware to leverage the correct SGI to raise appropriate type of SGI in co-ordination with how the platform has specified the interrupt type. For example, ARM_IRQ_SEC_SGI_7 has been specified as G1S by Xilinx zynqmp platform. Hence, the SPD module can use this SGI only with plat_ic_raise_s_el1_sgi(). I believe the assert you mentioned earlier would be useful to ensure this.\n\nBased on my above observations, I think the 2nd option you listed above would be preferred.\ngicv2_raise_sgi() can be as it is. gicv3_raise_sgi() can take the additional argument INTR_TYPE_*. I believe this is justified since GICv3 architecture introduced additional interrupt type( G1 Secure) which did not exist in GICv2 architecture.\n\n\nPlease let me know if you disagree.\n\n[1] https://git.trustedfirmware.org/TF-A/trusted-firmware-a.git/tree/plat/xilinx/zynqmp/include/platform_def.h#n133\n[2] https://git.trustedfirmware.org/TF-A/trusted-firmware-a.git/tree/drivers/arm/gic/v3/gicv3_main.c#n224\n[3] https://git.trustedfirmware.org/TF-A/trusted-firmware-a.git/tree/drivers/arm/gic/v3/gicv3_helpers.c#n307",
      "parentUuid": "00cfb8ef_72119e77",
      "range": {
        "startLine": 1134,
        "startChar": 0,
        "endLine": 1147,
        "endChar": 2
      },
      "revId": "fedea432b7ea41249e5c9bb18b03ae1f851600a9",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ea39fc05_2b76f62c",
        "filename": "drivers/arm/gic/v3/gicv3_main.c",
        "patchSetId": 8
      },
      "lineNbr": 1147,
      "author": {
        "id": 1000707
      },
      "writtenOn": "2022-08-29T07:21:04Z",
      "side": 1,
      "message": "Thank you for your answer.\n\nI could not find among the places you are linking to in your last post, where a CPU was accessing another CPU\u0027s redistributor interface. It seems to me that gicv3_rdistif_init and gicv3_secure_ppi_sgi_config_props only access (write to) the current CPU redistributor. Would you be kind enough to point me to the exact line where this access takes place?\n\nMy understanding is that the TF-A expects that all CPUs share the same group configuration for SGIs/PPIs. So the current CPU should be able to infer the configuration of the SGI/PPI on the target CPU based on the configuration of its own redistributor interface.\n\nNote that the static GIC configuration that you are mentioning (through PLAT_ARM_G1S_IRQ_PROPS) is, as far as I understand, only an initial configuration. In the case of the ProvenCore SPD, the SGI used to signal to the TEE that a message has been pushed by Linux to the shared buffer is configured by the TEE itself. ProvenCore being single-core, it only updates the configuration for its own redistributor. We could however imagine that Linux, which is running on multiple cores, may want to trigger the SGI from another CPU (through a SMC). In this case, the redistributor configuration of the SGI for the source CPU (where Linux triggered the SMC) and the destination CPU (where ProvenCore is running) would be different and we cannot rely on the source CPU redistributor configuration to infer the SGI group, as it is done in the rest of the TF-A codebase.\n\nCan I ask for one last confirmation that the following changes are what you expect:\n- in drivers/arm/gic/v3/gicv3_main.c, gicv3_raise_sgi, remove the group parameter and pick the right SGIxR register to write to based on the destination CPU redistributor configuration\n- in plat/common/plat_gicv3.c, rewrite plat_ic_raise_el3_sgi, plat_ic_raise_ns_sgi and plat_ic_raise_s_el1_sgi so that there are all identical (except for asserts) and simply forward their parameters to gicv3_raise_sgi\n\nNote that this is indeed not how I would have implemented it, but I will obviously comply to your views on this matter.\n\nThank you",
      "parentUuid": "d5c7eed4_de8a323b",
      "range": {
        "startLine": 1134,
        "startChar": 0,
        "endLine": 1147,
        "endChar": 2
      },
      "revId": "fedea432b7ea41249e5c9bb18b03ae1f851600a9",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    }
  ]
}