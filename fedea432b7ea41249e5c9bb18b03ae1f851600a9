{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "1545b096_5b305c12",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 8
      },
      "lineNbr": 0,
      "author": {
        "id": 1000103
      },
      "writtenOn": "2022-07-11T07:34:06Z",
      "side": 1,
      "message": "Tested OK on STM32MP157C-DK2 board",
      "revId": "fedea432b7ea41249e5c9bb18b03ae1f851600a9",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c9bd0b93_5183be5a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 8
      },
      "lineNbr": 0,
      "author": {
        "id": 1000162
      },
      "writtenOn": "2022-08-08T15:11:26Z",
      "side": 1,
      "message": "It is not clear why the platform handlers need updates and what the use case is. It should be call the gic APIs directly from the platform.",
      "revId": "fedea432b7ea41249e5c9bb18b03ae1f851600a9",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "cdb948d9_33e56f80",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 8
      },
      "lineNbr": 0,
      "author": {
        "id": 1000707
      },
      "writtenOn": "2022-08-12T09:54:42Z",
      "side": 1,
      "message": "As far as ProvenCore is concerned, we use SGIs as a way for Linux and the TEE to both signal to the other one that a message is available in a shared memory used as a communication channel between the two. Each NS-to-S and S-to-NS SGI is raised by the TF-A when a dedicated SMC is received. Generating an SGI from NS to S directly from NS-EL1 is not possible on platforms with a GICv2, hence the choice of a generic implementation with dedicated SMCs.\n\nBecause the handlers for these SMCs are platform independent (implemented in services/spd/pncd), we need generic plat_ic_raise_ns_sgi and plat_ic_raise_s_el1_sgi functions, in the same way as plat_ic_raise_el3_sgi.",
      "parentUuid": "c9bd0b93_5183be5a",
      "revId": "fedea432b7ea41249e5c9bb18b03ae1f851600a9",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c2e6af02_20e70304",
        "filename": "drivers/arm/gic/v2/gicv2_main.c",
        "patchSetId": 8
      },
      "lineNbr": 2,
      "author": {
        "id": 1000162
      },
      "writtenOn": "2022-08-08T15:11:26Z",
      "side": 1,
      "message": "I recommend adding your worn copyright header instead",
      "range": {
        "startLine": 2,
        "startChar": 25,
        "endLine": 2,
        "endChar": 26
      },
      "revId": "fedea432b7ea41249e5c9bb18b03ae1f851600a9",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "06031b7b_cec5c036",
        "filename": "drivers/arm/gic/v2/gicv2_main.c",
        "patchSetId": 8
      },
      "lineNbr": 2,
      "author": {
        "id": 1000707
      },
      "writtenOn": "2022-08-12T09:54:42Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "c2e6af02_20e70304",
      "range": {
        "startLine": 2,
        "startChar": 25,
        "endLine": 2,
        "endChar": 26
      },
      "revId": "fedea432b7ea41249e5c9bb18b03ae1f851600a9",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a17d443b_bafae3c0",
        "filename": "drivers/arm/gic/v2/gicv2_main.c",
        "patchSetId": 8
      },
      "lineNbr": 2,
      "author": {
        "id": 1000707
      },
      "writtenOn": "2022-08-12T10:18:15Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "06031b7b_cec5c036",
      "range": {
        "startLine": 2,
        "startChar": 25,
        "endLine": 2,
        "endChar": 26
      },
      "revId": "fedea432b7ea41249e5c9bb18b03ae1f851600a9",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "657b80c9_e53ab9b4",
        "filename": "drivers/arm/gic/v3/gicv3_main.c",
        "patchSetId": 8
      },
      "lineNbr": 1147,
      "author": {
        "id": 1000098
      },
      "writtenOn": "2022-08-08T17:58:46Z",
      "side": 1,
      "message": "I feel we dont need gicv3_irq_group_t group argument. Can you instead leverage gicv3_get_interrupt_type() ? Let me know.\n\nswitch (gicv3_get_interrupt_type(sgi_num, plat_my_core_pos()) {\ncase INTR_TYPE_EL3:\n\ncase INTR_TYPE_NS:\n\ncase INTR_TYPE_S_EL1:\n\ndefault:\n\n}",
      "range": {
        "startLine": 1134,
        "startChar": 0,
        "endLine": 1147,
        "endChar": 2
      },
      "revId": "fedea432b7ea41249e5c9bb18b03ae1f851600a9",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "52738cd0_8dd8e0ce",
        "filename": "drivers/arm/gic/v3/gicv3_main.c",
        "patchSetId": 8
      },
      "lineNbr": 1147,
      "author": {
        "id": 1000707
      },
      "writtenOn": "2022-08-12T09:54:42Z",
      "side": 1,
      "message": "I am not sure. It should indeed be possible, but I think the correct way to implement it would be to switch on gicv3_get_interrupt_type(sgi_num, plat_core_pos_by_mpidr(target)). This means that we will access the GICR_IGROUPR and GICR_IGRPMODR registers of the GIC redistributor of another CPU. Isn\u0027t it somewhat dangerous? Shouldn\u0027t we be aware of possible hardware access control mechanisms on some platforms which may prevent us from accessing the redistributor of another CPU? It seems to me that the programming model of the GICv3 (see for instance \"8.1.10 Use of control registers for SGI forwarding\" in ARM IHI 0069C) is that the source CPU decides which kind of SGI is supposed to be raised (through the choice of the ICC_[A]SGI{0,1}R register) and the destination CPU independently affects a group to each SGI. The target\u0027s GIC redistributor then gets to decide whether to signal the interrupt based on both configurations. This is also coherent with the previous implementation of gicv3_raise_secure_g0_sgi, which was not checking that the specified SGI was indeed configured as group 0 in the target\u0027s redistributor.\n\nWhat do you think? Should I still go on with discarding the group parameter and using gicv3_get_interrupt_type instead?",
      "parentUuid": "657b80c9_e53ab9b4",
      "range": {
        "startLine": 1134,
        "startChar": 0,
        "endLine": 1147,
        "endChar": 2
      },
      "revId": "fedea432b7ea41249e5c9bb18b03ae1f851600a9",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5c8ed64c_f4414bc1",
        "filename": "drivers/arm/gic/v3/gicv3_main.c",
        "patchSetId": 8
      },
      "lineNbr": 1147,
      "author": {
        "id": 1000098
      },
      "writtenOn": "2022-08-12T21:21:03Z",
      "side": 1,
      "message": "It looks like gicv3_get_interrupt_type(sgi_num, plat_core_pos_by_mpidr(target)) is already used in the parent function (for example plat_ic_raise_el3_sgi() [1]). I am not sure either if this is dangerous. Since its a read access, may be its not much of a risk. \n\nCan you simply pass the interrupt type (eg: INTR_TYPE_EL3) as the argument instead of  gicv3_irq_group_t GICV3_G0? Let me know your thoughts on this.\n\n[1] https://review.trustedfirmware.org/c/TF-A/trusted-firmware-a/+/11339/8/plat/common/plat_gicv3.c#244",
      "parentUuid": "52738cd0_8dd8e0ce",
      "range": {
        "startLine": 1134,
        "startChar": 0,
        "endLine": 1147,
        "endChar": 2
      },
      "revId": "fedea432b7ea41249e5c9bb18b03ae1f851600a9",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "00cfb8ef_72119e77",
        "filename": "drivers/arm/gic/v3/gicv3_main.c",
        "patchSetId": 8
      },
      "lineNbr": 1147,
      "author": {
        "id": 1000707
      },
      "writtenOn": "2022-08-22T08:10:36Z",
      "side": 1,
      "message": "The plat_ic_raise_*_sgi functions indeed call plat_ic_get_interrupt_type, but the call is made in an assert. It seemed to me that doing this verification in an assert is somewhat coherent with the programming model of the GIC: it is expected---but not required---that the SGI is configured on the destination CPU in a way that matches the group that the calling CPU was expecting. As it is called in an assert, I assume plat_ic_get_interrupt_type is actually not called when raising a SGI on most of the production platforms. Actually, it seems to me that there is an issue with this assert when all the following conditions hold:\n- the target CPU is different from the CPU calling plat_ic_raise_*_sgi\n- the configured group for this SGI on the target CPU is different from the expected group\n- the configured group for this SGI on the current CPU is indeed the expected group\nIndeed, plat_ic_get_interrupt_type does not take the target CPU as a parameter and always reads the GIC registers for the current CPU to determine the configured group. In the case I was mentioning, the assert will succeed, although the configuration on the target CPU is not as expected. Conversely, the assert could also fail while the configuration on the target CPU is correct.\n\nAs far as gicv3_irq_group_t is concerned, I can indeed replace it by a INTR_TYPE_* parameter. I initially introduced this new enum type as it seemed to me that it was more coherent with the GIC driver implementation in the TF-A: as far as I understand it, INTR_TYPE_* are abstract interrupt types which are used in the code base when calling generic interrupt functions (plat_ic_*). These abstract interrupt types are then translated by each specific ic driver implementation to a concrete group. For instance, in the GICv2 implementation, the GICV2_G0_FOR_EL3 compilation option is used in the generic function plat_ic_get_interrupt_type to map a concrete group (either GIV2_INTR_GROUP0 or GIV2_INTR_GROUP1) to the correct abstract interrupt type (INTR_TYPE_NS and INTR_TYPE_EL3 or INTR_TYPE_S_EL1 depending on GICV2_G0_FOR_EL3).\n\nIf I change the gicv3_raise_sgi signature to take a INTR_TYPE_* parameter, we need to choose between these 2 options:\n- either we also change the giv2_raise_sgi signature to take an INTR_TYPE_* parameter and we will have to test GICV2_G0_FOR_EL3 in drivers/arm/gic/v2/giv2_main.c, which was until now agnostic of such a feature (this file only deals with concrete interrupt groups)\n- or we leave gicv2_raise_sgi as it is. In this case, we will end up with gicv2_raise_sgi taking concrete interrupt types (in the form of a boolean saying whether the raised SGI should be S or NS) and gicv3_raise_sgi taking abstract INTR_TYPE_* interrupt types. It seems to be that this would be a bit confusing, but I am fine with doing this change if you wish so.\n\nCould you confirm me that you still think removing the newly introduced gicv3_irq_group_t type is the best way to go? And, in this case, which of the 2 proposed options you prefer?\n\nThank you",
      "parentUuid": "5c8ed64c_f4414bc1",
      "range": {
        "startLine": 1134,
        "startChar": 0,
        "endLine": 1147,
        "endChar": 2
      },
      "revId": "fedea432b7ea41249e5c9bb18b03ae1f851600a9",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    }
  ]
}