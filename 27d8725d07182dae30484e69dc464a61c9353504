{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "bcab79b0_152c2e60",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000181
      },
      "writtenOn": "2021-07-13T17:30:50Z",
      "side": 1,
      "message": "The msr for hcr_el2 is only guaranteed to take affect on a CSE (context synchronization event). For a core executing out of order, this patch is needed to make sure that the write to hcr_el2 happens before ttbr1_el2.",
      "revId": "27d8725d07182dae30484e69dc464a61c9353504",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "55d33382_03009d3d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2021-07-13T18:33:49Z",
      "side": 1,
      "message": "so this happens in EL3. An ERET to EL2 will be a context synchronization event no? and it should take effect. SO still nto clear why we need the ISB here.",
      "parentUuid": "bcab79b0_152c2e60",
      "revId": "27d8725d07182dae30484e69dc464a61c9353504",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1c99ca26_274e1c23",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000181
      },
      "writtenOn": "2021-07-13T19:12:59Z",
      "side": 1,
      "message": "Yes, ERET to EL2 is a CSE, but in out of order execution, the CSE does not guarantee that\nmsr\thcr_el2, x17\nhappens before \nmsr\tttbr1_el2, x12",
      "parentUuid": "55d33382_03009d3d",
      "revId": "27d8725d07182dae30484e69dc464a61c9353504",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "67af383e_71f2c308",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2021-07-13T19:29:21Z",
      "side": 1,
      "message": "true. but why does the hcr_el2 need to happen before ttbr1_el2 in EL3? I know we have to do this in EL2, i just dont know that it matters in EL3. Those registers should have no effect or use in EL3 whatsoever. When we go back to EL2, the CSE should ensure that it both operations complete and any execution in EL2 happens after the CSE, at which point both registers should have the correct value no?",
      "parentUuid": "1c99ca26_274e1c23",
      "revId": "27d8725d07182dae30484e69dc464a61c9353504",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b2f57f37_d6cdf206",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2021-07-13T19:39:23Z",
      "side": 1,
      "message": "Going by that logic, why dont we execute ISB\u0027s after writing SCTLR_EL1 for example? why does the same issue not apply there? Or when PAUTH registers are swapped?",
      "parentUuid": "67af383e_71f2c308",
      "revId": "27d8725d07182dae30484e69dc464a61c9353504",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d9fe04bb_4720661e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000181
      },
      "writtenOn": "2021-07-13T21:50:38Z",
      "side": 1,
      "message": "\u003e but why does the hcr_el2 need to happen before ttbr1_el2 in EL3?\n\nIn ARM Architecture Reference Manual it says this about TTBR1_EL2: \n\n\"When HCR_EL2.E2H is 1, holds the base address of the translation table for the initial lookup for stage 1 of the translation of an address from the higher VA range in the EL2\u00260 translation regime, and other information for this translation regime\"\n\nIf msr ttbr_el2 syncs in out of order before hcr_el2.e2h SET bit syncs in, the wrong ASID (bits [63:48] of TTBR1_EL2) is used in ttbr_el2 giving translation error.\n\nI think this explains this explains well the working of ASID https://developer.arm.com/documentation/101811/0101/Address-spaces-in-AArch64 \n\n\u003e Or when PAUTH registers are swapped?\nI found a similar problem in hafnium where stale keys were being used, This occurs in both hardware and model, giving pointer authentication error. I inserted an isb at the end of pauth_restore_hypervisor_key and issue was solved, Olivier is trying to upstream that here: https://review.trustedfirmware.org/c/hafnium/hafnium/+/10578\n\n\u003e why dont we execute ISB\u0027s after writing SCTLR_EL1 for example?\nI havent yet encountered an issue over here, is there any reason you think there should be an isb over here?",
      "parentUuid": "b2f57f37_d6cdf206",
      "revId": "27d8725d07182dae30484e69dc464a61c9353504",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "07622fac_9482c9e3",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2021-07-14T01:47:05Z",
      "side": 1,
      "message": "Thanks Usama. In review 10578, the ISB makes perfect sense to me. The code is running in EL2 and we want code in EL2 following the writes to the pauth registers, to use the newly updated registers. In this case, we are talking about modifying/saving/restoring EL2 registers in EL3. Those order of save/restores of those registers don\u0027t matter when execution in EL3 unless there is an Errata(of which there have been a few - see ERRATA_SPECULATIVE_AT in the file modified in this commit). At EL3, those registers should not affect code execution in EL3 and hence adding an ISB should not be necessary and when we return to EL2 we use an ERET which is a CSE at which point the ordering should not matter. The statement from the ARM ARM again makes sense when we are executing in EL2 and we absolutely should use the ISB there. I\u0027m just debating if it is necessary in EL3. All these barriers are performance penalties and we should add them only if absolutely necessary and i\u0027m not convinced it is necessary still.\nSCTLR_EL1 was an example. We can replace HCR_EL2 with any other system register that requires ISB at the appropriate exception level but not in EL3 during the save/restore routings and should ask why we don\u0027t use ISB.\nIt is possible i\u0027m wrong, i\u0027m just asking for compelling evidence that it is necessary and i dont see it yet.",
      "parentUuid": "d9fe04bb_4720661e",
      "revId": "27d8725d07182dae30484e69dc464a61c9353504",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ce0504b9_195e95ba",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000181
      },
      "writtenOn": "2021-07-14T13:44:32Z",
      "side": 1,
      "message": "\u003e At EL3, those registers should not affect code execution in EL3 and hence adding an ISB should not be necessary and when we return to EL2 we use an ERET which is a CSE at which point the ordering should not matter. \n\nI think this is where there is some confusion in the last part of the statement. I agree with you that at EL3, those registers should not affect code execution IN EL3 and it doesn\u0027t. It is DURING CSE (ERET) that it matters if there is no ISB, if you consider that this patch is not there, than both hcr_el2 and ttbr_el1 sync at eret. The order of these syncing in is not guaranteed, if the ttbr1_el2 syncs in before  hcr_le2 syncs in, it sees that HCR_EL2.E2H bit is 0, and from ARM arch reference manual we see that TTBR1_EL2 only \"When HCR_EL2.E2H is 1, holds the base address of the translation table\", therefore after ERET, TTBR1_EL2 is holding the wrong asid, as it was decided based on older value of HCR_EL2.E2H bit (0 instead of 1). Having wrong asid id results in translation fault AFTER eret when we are in EL2.\n\nBoth this patch and isb i had to insert at the end of pauth_restore_hypervisor_key in https://review.trustedfirmware.org/c/hafnium/hafnium/+/10578 is due to translation fault/pointer authentication errors i have been getting in model/hardware, and not based on theoretical assumptions. \n\nIt is not in errata as it is mentioned in ARM ARM both about how ttbr1_el2 functions when HCR_EL2.E2H has different bit values and that CSE only syncs registers in and does not guarantee the order of sync.\n\nI do understand that there is a performance penalty incurred especially in a function like context restore which we should avoid.",
      "parentUuid": "07622fac_9482c9e3",
      "revId": "27d8725d07182dae30484e69dc464a61c9353504",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    }
  ]
}