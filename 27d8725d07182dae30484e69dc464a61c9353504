{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "bcab79b0_152c2e60",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000181
      },
      "writtenOn": "2021-07-13T17:30:50Z",
      "side": 1,
      "message": "The msr for hcr_el2 is only guaranteed to take affect on a CSE (context synchronization event). For a core executing out of order, this patch is needed to make sure that the write to hcr_el2 happens before ttbr1_el2.",
      "revId": "27d8725d07182dae30484e69dc464a61c9353504",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "55d33382_03009d3d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2021-07-13T18:33:49Z",
      "side": 1,
      "message": "so this happens in EL3. An ERET to EL2 will be a context synchronization event no? and it should take effect. SO still nto clear why we need the ISB here.",
      "parentUuid": "bcab79b0_152c2e60",
      "revId": "27d8725d07182dae30484e69dc464a61c9353504",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1c99ca26_274e1c23",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000181
      },
      "writtenOn": "2021-07-13T19:12:59Z",
      "side": 1,
      "message": "Yes, ERET to EL2 is a CSE, but in out of order execution, the CSE does not guarantee that\nmsr\thcr_el2, x17\nhappens before \nmsr\tttbr1_el2, x12",
      "parentUuid": "55d33382_03009d3d",
      "revId": "27d8725d07182dae30484e69dc464a61c9353504",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "67af383e_71f2c308",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2021-07-13T19:29:21Z",
      "side": 1,
      "message": "true. but why does the hcr_el2 need to happen before ttbr1_el2 in EL3? I know we have to do this in EL2, i just dont know that it matters in EL3. Those registers should have no effect or use in EL3 whatsoever. When we go back to EL2, the CSE should ensure that it both operations complete and any execution in EL2 happens after the CSE, at which point both registers should have the correct value no?",
      "parentUuid": "1c99ca26_274e1c23",
      "revId": "27d8725d07182dae30484e69dc464a61c9353504",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b2f57f37_d6cdf206",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2021-07-13T19:39:23Z",
      "side": 1,
      "message": "Going by that logic, why dont we execute ISB\u0027s after writing SCTLR_EL1 for example? why does the same issue not apply there? Or when PAUTH registers are swapped?",
      "parentUuid": "67af383e_71f2c308",
      "revId": "27d8725d07182dae30484e69dc464a61c9353504",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d9fe04bb_4720661e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000181
      },
      "writtenOn": "2021-07-13T21:50:38Z",
      "side": 1,
      "message": "\u003e but why does the hcr_el2 need to happen before ttbr1_el2 in EL3?\n\nIn ARM Architecture Reference Manual it says this about TTBR1_EL2: \n\n\"When HCR_EL2.E2H is 1, holds the base address of the translation table for the initial lookup for stage 1 of the translation of an address from the higher VA range in the EL2\u00260 translation regime, and other information for this translation regime\"\n\nIf msr ttbr_el2 syncs in out of order before hcr_el2.e2h SET bit syncs in, the wrong ASID (bits [63:48] of TTBR1_EL2) is used in ttbr_el2 giving translation error.\n\nI think this explains this explains well the working of ASID https://developer.arm.com/documentation/101811/0101/Address-spaces-in-AArch64 \n\n\u003e Or when PAUTH registers are swapped?\nI found a similar problem in hafnium where stale keys were being used, This occurs in both hardware and model, giving pointer authentication error. I inserted an isb at the end of pauth_restore_hypervisor_key and issue was solved, Olivier is trying to upstream that here: https://review.trustedfirmware.org/c/hafnium/hafnium/+/10578\n\n\u003e why dont we execute ISB\u0027s after writing SCTLR_EL1 for example?\nI havent yet encountered an issue over here, is there any reason you think there should be an isb over here?",
      "parentUuid": "b2f57f37_d6cdf206",
      "revId": "27d8725d07182dae30484e69dc464a61c9353504",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "07622fac_9482c9e3",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2021-07-14T01:47:05Z",
      "side": 1,
      "message": "Thanks Usama. In review 10578, the ISB makes perfect sense to me. The code is running in EL2 and we want code in EL2 following the writes to the pauth registers, to use the newly updated registers. In this case, we are talking about modifying/saving/restoring EL2 registers in EL3. Those order of save/restores of those registers don\u0027t matter when execution in EL3 unless there is an Errata(of which there have been a few - see ERRATA_SPECULATIVE_AT in the file modified in this commit). At EL3, those registers should not affect code execution in EL3 and hence adding an ISB should not be necessary and when we return to EL2 we use an ERET which is a CSE at which point the ordering should not matter. The statement from the ARM ARM again makes sense when we are executing in EL2 and we absolutely should use the ISB there. I\u0027m just debating if it is necessary in EL3. All these barriers are performance penalties and we should add them only if absolutely necessary and i\u0027m not convinced it is necessary still.\nSCTLR_EL1 was an example. We can replace HCR_EL2 with any other system register that requires ISB at the appropriate exception level but not in EL3 during the save/restore routings and should ask why we don\u0027t use ISB.\nIt is possible i\u0027m wrong, i\u0027m just asking for compelling evidence that it is necessary and i dont see it yet.",
      "parentUuid": "d9fe04bb_4720661e",
      "revId": "27d8725d07182dae30484e69dc464a61c9353504",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ce0504b9_195e95ba",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000181
      },
      "writtenOn": "2021-07-14T13:44:32Z",
      "side": 1,
      "message": "\u003e At EL3, those registers should not affect code execution in EL3 and hence adding an ISB should not be necessary and when we return to EL2 we use an ERET which is a CSE at which point the ordering should not matter. \n\nI think this is where there is some confusion in the last part of the statement. I agree with you that at EL3, those registers should not affect code execution IN EL3 and it doesn\u0027t. It is DURING CSE (ERET) that it matters if there is no ISB, if you consider that this patch is not there, than both hcr_el2 and ttbr_el1 sync at eret. The order of these syncing in is not guaranteed, if the ttbr1_el2 syncs in before  hcr_le2 syncs in, it sees that HCR_EL2.E2H bit is 0, and from ARM arch reference manual we see that TTBR1_EL2 only \"When HCR_EL2.E2H is 1, holds the base address of the translation table\", therefore after ERET, TTBR1_EL2 is holding the wrong asid, as it was decided based on older value of HCR_EL2.E2H bit (0 instead of 1). Having wrong asid id results in translation fault AFTER eret when we are in EL2.\n\nBoth this patch and isb i had to insert at the end of pauth_restore_hypervisor_key in https://review.trustedfirmware.org/c/hafnium/hafnium/+/10578 is due to translation fault/pointer authentication errors i have been getting in model/hardware, and not based on theoretical assumptions. \n\nIt is not in errata as it is mentioned in ARM ARM both about how ttbr1_el2 functions when HCR_EL2.E2H has different bit values and that CSE only syncs registers in and does not guarantee the order of sync.\n\nI do understand that there is a performance penalty incurred especially in a function like context restore which we should avoid.",
      "parentUuid": "07622fac_9482c9e3",
      "revId": "27d8725d07182dae30484e69dc464a61c9353504",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fa6fe434_ad39b78f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2021-07-14T20:05:51Z",
      "side": 1,
      "message": "Thanks Usama, understand that you see this is in the model. It is possible that the model has a bug too, albeit unlikely. E2H support has been there on real HW for many years and this has never really been a problem on linux for example, so i\u0027m wondering why this is showing up now on the model. We shouldn\u0027t fix based on what the model shows, but instead on what the architecture expects. And i completely understand this may just be that implementations today dont allow these reorderings so we have been getting away with it.\nThe ARM ARM snippets you quote seem to apply to what needs to done in EL2, not in EL3, the way i read it. If similar statements were to apply for all system register writes, the save restore routines in EL3 could be filled with ISB\u0027s to avoid reordering.\n\nYou said: \"If msr ttbr_el2 syncs in out of order before hcr_el2.e2h SET bit syncs in, the wrong ASID (bits [63:48] of TTBR1_EL2) is used in ttbr_el2 giving translation error.\" - Where is this in the ARM ARM? This is observed behavior on an implementation, not an architecturally allowed behavior as far as i can tell. And when i asked about SCTLR_EL1, that was an example. I dont know of a problem, but why does the same logic not apply for ttbr1_el1 for example? E2H effectively converts EL2 to EL1, so on a system where there is no EL2, shouldnt we need to do the same for ttbr1_el1? Another example would be the number of ASID bits being used in ttbrx_el1 registers, that depend on TCR_EL1 or other system registers. top 8 bits of ASID are RES0 based on TCR_EL1 settings, yet our context restore routing has no ISB to ensure it has taken effect.\n\nYou may still be right, i would just like to see where in the ARM ARM it is said we need the ISB in EL3. Already mentioned, the PAUTH fix makes sense since that is localized to EL2 and ISB is required to affect execution of instructions following it in EL2. You can see in text about register accesses for ttbr1_el1 in the ARM ARM that talks about ordering w.r.t to using different mnemonic with E2H but there is no other statement like that for other ttbr\u0027s. I dont see anything related to this requirement in D13.1.1 either.\n\n\nAlso not sure i understand what you mean by DURING CSE. CSE as defined in the ARM ARM only talks about effects before and after the CSE.",
      "parentUuid": "ce0504b9_195e95ba",
      "revId": "27d8725d07182dae30484e69dc464a61c9353504",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1330e4b9_12f7d0ce",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2021-07-14T20:32:04Z",
      "side": 1,
      "message": "The only thing i see in D13.1.1 Synchronization requirements for AArch64 System registers, that could apply is in table D13-1. the msr to write HCR_EL2 is a direct write, and the direct write to ttbr1_el2 could cause an indirect read to HCR_EL2 for the E2H bit setting and according to the table, it requires synchronization. However, i dont understand why the same rule would not apply between TCR_EL1 and say TTBR1_EL1 for ASID bits for example...",
      "revId": "27d8725d07182dae30484e69dc464a61c9353504",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "476a1026_ee63085f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2021-07-14T20:51:06Z",
      "side": 1,
      "message": "Anyway, more reading of the ARM ARM. For TTBR1_EL2, the ARM ARM is somewhat confusing. The MSR psuedo-code to write ttbr1_el2 in EL3 is simply a write, without any regard to what HCR_EL2.E2H is and the ARM ARM also states \"When HCR_EL2.E2H is 0, the contents of this register are ignored by the PE, except for a direct read or write of the register.\", which gives support to my theory that it does not matter if we dont have the ISB synchronization.\nHowever, the same section(D13.2.139) also says \"TTBR1_EL2 is accessible only when the value of HCR_EL2.E2H is 1, meaning the current translation regime is the EL2\u00260 regime.\".\nIt could very well be that the model uses this rule as precedence when we write to EL3. It  would be great if you can confirm this internally and add the exact reason we need to do this in the commit message.",
      "parentUuid": "1330e4b9_12f7d0ce",
      "revId": "27d8725d07182dae30484e69dc464a61c9353504",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4d7b26be_6dbcf577",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000228
      },
      "writtenOn": "2021-07-26T09:21:50Z",
      "side": 1,
      "message": "\u003e It is DURING CSE (ERET) that it matters if there is no ISB, if you consider that this patch is not there, than both hcr_el2 and ttbr_el1 sync at eret. The order of these syncing in is not guaranteed, if the ttbr1_el2 syncs in before  hcr_le2 syncs in, it sees that HCR_EL2.E2H bit is 0\n\nI think this summarizes quite well the problem though there is no mention (per my reading above) that SW has to provide this guarantee esp. at EL3. So it\u0027s important to understand if the (HW) context synchronization implementation must take care of committing HCR_EL2.E2H before the TTBR1_EL2 write per the architecture. If not, the Arm ARM shall explicitly mention this. At this stage (sorry to repeat what was said above) we cannot tell if this is a model quirk or a problem that will effectively trigger in HW.\n\nIn general we should refrain adding an ISB without a strong justification especially in this context switch sequence which may be traversed dozens/thousands of times for a simple transaction to a SP. Btw, this does no longer only affect SPM cases but also Arm CCA entities in the long term.",
      "parentUuid": "476a1026_ee63085f",
      "revId": "27d8725d07182dae30484e69dc464a61c9353504",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    }
  ]
}