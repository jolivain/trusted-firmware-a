{
  "comments": [
    {
      "key": {
        "uuid": "c64c25dc_e9eb8853",
        "filename": "plat/mediatek/mt8183/plat_mt_gic.c",
        "patchSetId": 3
      },
      "lineNbr": 22,
      "author": {
        "id": 1000105
      },
      "writtenOn": "2019-10-23T12:10:41Z",
      "side": 1,
      "message": "Please explain why [PLATFORM_CORE_COUNT], but only index 0 is used in mt_gic_rdistif_save() \u0026 mt_gic_rdistif_restore()",
      "revId": "ad405d49c0be54c27ada155eb104f2bb00afea81",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fc2431ad_1317a379",
        "filename": "plat/mediatek/mt8183/plat_mt_gic.c",
        "patchSetId": 3
      },
      "lineNbr": 22,
      "author": {
        "id": 1000133
      },
      "writtenOn": "2019-10-24T07:10:07Z",
      "side": 1,
      "message": "also, don\u0027t we need to set it back to 0 sometime?\n\nit seems to me that once if multiple cores save and restore in different timings this would definitely cause race condition.\n\nfor example\n\n core 1 save (idle)\n core 2 save (idle)\n core 1 restore (got data from core 2)",
      "parentUuid": "c64c25dc_e9eb8853",
      "revId": "ad405d49c0be54c27ada155eb104f2bb00afea81",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "530eba2d_23fc6a18",
        "filename": "plat/mediatek/mt8183/plat_mt_gic.c",
        "patchSetId": 3
      },
      "lineNbr": 22,
      "author": {
        "id": 1000123
      },
      "writtenOn": "2019-10-24T07:34:24Z",
      "side": 1,
      "message": "proc_num \u003d plat_my_core_pos();\n\tgicr_base \u003d gicv3_driver_data-\u003erdistif_base_addrs[proc_num];\n\n\trdist_has_saved[proc_num] \u003d 1;\n\nNot only index 0 is used.\nEach CPU executes here, gets its core number, and then saves it according to the index.\n\ngicr_base \u003d gicv3_driver_data-\u003erdistif_base_addrs[proc_num];\ngicr_base \u003d gicv3_driver_data-\u003erdistif_base_addrs[proc_num];\n\nBasically, GIC base differs among cores.\nThey save and restore data in their own registers.",
      "parentUuid": "fc2431ad_1317a379",
      "revId": "ad405d49c0be54c27ada155eb104f2bb00afea81",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "dafcc11c_093abef0",
        "filename": "plat/mediatek/mt8183/plat_mt_gic.c",
        "patchSetId": 3
      },
      "lineNbr": 22,
      "author": {
        "id": 1000133
      },
      "writtenOn": "2019-10-24T07:45:59Z",
      "side": 1,
      "message": "Hi Kenny, I think Alexei is asking \n\n gic_data.saved_group[0] \u003d mmio_read_32(gicr_base + GICR_IGROUPR0);\n\nWhy is here only 0, given saved_group has more?\n\nAlso, even if gicr_base is different, where you saved (gic_data) is a single variable. Won\u0027t that be a problem?",
      "parentUuid": "530eba2d_23fc6a18",
      "revId": "ad405d49c0be54c27ada155eb104f2bb00afea81",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "faa3e63c_06f3cce5",
        "filename": "plat/mediatek/mt8183/plat_mt_gic.c",
        "patchSetId": 3
      },
      "lineNbr": 22,
      "author": {
        "id": 1000133
      },
      "writtenOn": "2019-10-24T09:31:33Z",
      "side": 1,
      "message": "synced with kenny offline. the rdist data for all cores should be the same, so that\u0027s why they are sharing same gic_chip_data.\n\nmeanwhile, the [0] may still be removed.",
      "parentUuid": "dafcc11c_093abef0",
      "revId": "ad405d49c0be54c27ada155eb104f2bb00afea81",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": false
    }
  ]
}