{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "3ad215ad_b463539d",
        "filename": "lib/psci/psci_common.c",
        "patchSetId": 1
      },
      "lineNbr": 189,
      "author": {
        "id": 1000098
      },
      "writtenOn": "2021-09-13T17:09:36Z",
      "side": 1,
      "message": "Wouldnt it be possible for a cpu to be in AFF_STATE_PENDING_ON? May be we should check:\nif(psci_get_aff_info_state_by_idx(cpu_idx) !\u003d AFF_STATE_OFF) {",
      "revId": "f6de1b535065c4dae47ee288dfbbb9f31a7d865a",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5dc1c3ef_609bc0b7",
        "filename": "lib/psci/psci_common.c",
        "patchSetId": 1
      },
      "lineNbr": 189,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2021-09-13T17:52:49Z",
      "side": 1,
      "message": "isnt this racy? can this provide a reliable count since cores could be going on and off in parallel at any time? not sure i understand the use case for this Api..",
      "range": {
        "startLine": 189,
        "startChar": 2,
        "endLine": 189,
        "endChar": 62
      },
      "revId": "f6de1b535065c4dae47ee288dfbbb9f31a7d865a",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5a46edaf_a0d6f9bd",
        "filename": "lib/psci/psci_common.c",
        "patchSetId": 1
      },
      "lineNbr": 189,
      "author": {
        "id": 1000476
      },
      "writtenOn": "2021-09-15T12:19:49Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "3ad215ad_b463539d",
      "revId": "f6de1b535065c4dae47ee288dfbbb9f31a7d865a",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fdd5fd34_8b273fed",
        "filename": "lib/psci/psci_common.c",
        "patchSetId": 1
      },
      "lineNbr": 189,
      "author": {
        "id": 1000476
      },
      "writtenOn": "2021-09-15T12:19:49Z",
      "side": 1,
      "message": "I am not sure whether race condition possible or not. But pending power up/down will be taken care by below condition:\nif (psci_get_aff_info_state_by_idx(cpu_idx) !\u003d AFF_STATE_OFF) {\nHere is scenario:\n1. Firmware will send idling request to all cores before firmware tries to power down CPU\n2. Since this is SMP case, TF-A does idling only when firmware sends requests for all active cores.",
      "parentUuid": "5dc1c3ef_609bc0b7",
      "range": {
        "startLine": 189,
        "startChar": 2,
        "endLine": 189,
        "endChar": 62
      },
      "revId": "f6de1b535065c4dae47ee288dfbbb9f31a7d865a",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "48c0d38f_4db4bad9",
        "filename": "lib/psci/psci_common.c",
        "patchSetId": 1
      },
      "lineNbr": 189,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2021-09-15T15:13:42Z",
      "side": 1,
      "message": "Not sure i understand. The state can change at any instance. so even if you check for !\u003d AFF_STATE_OFF, immediately after that it can change.. my question is the number of active cores only gives you the number of active cores as you observed at a given moment. What is the use case for this in TF-A?",
      "parentUuid": "fdd5fd34_8b273fed",
      "range": {
        "startLine": 189,
        "startChar": 2,
        "endLine": 189,
        "endChar": 62
      },
      "revId": "f6de1b535065c4dae47ee288dfbbb9f31a7d865a",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    }
  ]
}