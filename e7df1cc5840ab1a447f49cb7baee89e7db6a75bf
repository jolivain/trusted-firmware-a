{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "c74a7ce2_dcfb0497",
        "filename": "include/arch/aarch64/el3_common_macros.S",
        "patchSetId": 21
      },
      "lineNbr": 194,
      "author": {
        "id": 1000328
      },
      "writtenOn": "2021-06-22T14:11:31Z",
      "side": 1,
      "message": "Looks like this define is set to \u00270\u0027, hence effective value \u00270\u0027 moved to x0.\nIs that mean x0 register is already prepared for SVE accessibility?\n\nI must be missing something here. Not sure, why historically done in this way? \nI think, we should set x0 as below to clear the required bits:\n#define CPTR_EL3_RESET_VAL (TCPAC_BIT | TTA_BIT | TFP_BIT | TAM_BIT | CPTR_EZ_BIT) -\u003e will all bits set to 1.\nmov_imm x0, (CPTR_EL3_RESET_VAL \u0026 ~(TCPAC_BIT | TTA_BIT | TFP_BIT))\n\nAlso, I think you can directly clear EZ bit instead of checking the SVE functionality:\n\"mov_imm x0, (CPTR_EL3_RESET_VAL \u0026 ~(TCPAC_BIT | TTA_BIT | TFP_BIT | CPTR_EZ_BIT))\"\n\nAs per ARM Arm EZ bit is reserved in the absence of SVE functionality so \u0027EZ\u0027 bit writes get ignored in that case.\n\nDoes this make sense?",
      "range": {
        "startLine": 194,
        "startChar": 14,
        "endLine": 194,
        "endChar": 32
      },
      "revId": "e7df1cc5840ab1a447f49cb7baee89e7db6a75bf",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9d893e11_9f3b736e",
        "filename": "include/arch/aarch64/el3_common_macros.S",
        "patchSetId": 21
      },
      "lineNbr": 194,
      "author": {
        "id": 1000279
      },
      "writtenOn": "2021-06-22T15:42:12Z",
      "side": 1,
      "message": "So you are suggesting that the reset value should be \"don\u0027t allow anything\" basically and then we clear the bits in arch_init? That makes sense from the security perspective, yes.\n\n\u003e As per ARM Arm EZ bit is reserved in the absence of SVE functionality so \u0027EZ\u0027 bit writes get ignored in that case.\nI didn\u0027t know that is the case. Thank you for clarifying!",
      "parentUuid": "c74a7ce2_dcfb0497",
      "range": {
        "startLine": 194,
        "startChar": 14,
        "endLine": 194,
        "endChar": 32
      },
      "revId": "e7df1cc5840ab1a447f49cb7baee89e7db6a75bf",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2a5e4e5a_2582426d",
        "filename": "include/arch/aarch64/el3_common_macros.S",
        "patchSetId": 21
      },
      "lineNbr": 194,
      "author": {
        "id": 1000279
      },
      "writtenOn": "2021-06-22T15:50:33Z",
      "side": 1,
      "message": "So actually x0 is prepared for SVE accessibility in a way. It\u0027s writing all zeros to cptr_el3 which what we want in the end. So from perspective on unknown value - it\u0027s solved by the original code. I agree that CPTR_EL3_RESET_VAL should be all-restrictive rather than all-allowing, but then we end up with\n#define CPTR_EL3_RESET_VAL\t(TCPAC_BIT | TAM_BIT | TTA_BIT | TFP_BIT | CPTR_EZ_BIT)\nand then\n\tmov_imm x0, (CPTR_EL3_RESET_VAL \u0026 ~(TCPAC_BIT | TTA_BIT | TFP_BIT | CPTR_EZ_BIT | TAM_BIT))\nwhich seems creating unnecessary complication.\nWhat do you think?",
      "parentUuid": "9d893e11_9f3b736e",
      "range": {
        "startLine": 194,
        "startChar": 14,
        "endLine": 194,
        "endChar": 32
      },
      "revId": "e7df1cc5840ab1a447f49cb7baee89e7db6a75bf",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a1748172_cf862d0a",
        "filename": "include/arch/aarch64/el3_common_macros.S",
        "patchSetId": 21
      },
      "lineNbr": 194,
      "author": {
        "id": 1000328
      },
      "writtenOn": "2021-06-22T16:42:02Z",
      "side": 1,
      "message": "Yes, I agree CPTR_EL3 is already in a known state in original code (specifically, in the context of this patch CPTR_EL3.EZ \u003d 0).\n\nEffectively CPTR_EL3 value is 0 on boot-up and allows access of respective features [covered by CPTLR_EL3 bits] from lower ELs. I am not sure why it was done in this way, but it looks wrong to me.\n\nIMO, we should enable trap bits on boot-up and let the build flag cover the implementation to allow the feature access from lower ELs. \n\nWhat do you think?",
      "parentUuid": "2a5e4e5a_2582426d",
      "range": {
        "startLine": 194,
        "startChar": 14,
        "endLine": 194,
        "endChar": 32
      },
      "revId": "e7df1cc5840ab1a447f49cb7baee89e7db6a75bf",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    }
  ]
}