{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "6c78ac9f_10eefe5e",
        "filename": "lib/psci/psci_main.c",
        "patchSetId": 1
      },
      "lineNbr": 387,
      "author": {
        "id": 1000098
      },
      "writtenOn": "2021-10-14T16:10:32Z",
      "side": 1,
      "message": "As you mentioned in commit message, only a few PSCI calls are allowed from secure world such as PSCI_FEATURES. However, with this change, it looks like you are allowing unrestricted access to all PSCI calls when invoked from secure world.",
      "revId": "b759ef088a5d7fc483d59d6a926c629ffb2cd268",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "58e7e8de_8692f6d1",
        "filename": "lib/psci/psci_main.c",
        "patchSetId": 1
      },
      "lineNbr": 387,
      "author": {
        "id": 1000707
      },
      "writtenOn": "2021-10-15T12:46:23Z",
      "side": 1,
      "message": "Yes, it seems to me that there is some ambiguity in the PSCI and SMCCC specifications due to the introduction of SMCCC v1.1.\n\nThe PSCI specification ([1]) explicitly states that PSCI functions should only be available to normal world (introduction to section 5):\n\n\"PSCI functions can only be called from the Normal world\"\n\nwhich matches the currently implemented behavior.\n\nHowever, SMCCC v1.1 specification ([2]) introduces SMCCC_ARCH_WORKAROUND_1 and SMCCC_ARCH_WORKAROUND_2 to counter CVE-2017-5715 and CVE-2018-3639. According to appendix B of [2], the presence of these SMCs should be discovered using PSCI_VERSION and PSCI_FEATURES. It seems logical that secure software can invoke SMCCC_ARCH_WORKAROUND_1 and SMCCC_ARCH_WORKAROUND_2 and this is actually what our SP does (disabling and re-enabling MMU at S-EL1 to counter CVE-2017-5715 cannot be easily done). Moreover, SMCCC specification does not say anything about these SMCs being reserved for normal world.\n\nWhat is your opinion about this? Should we statically configure our SP to know about the implementation status of SMCCC_ARCH_WORKAROUND_1 and SMCCC_ARCH_WORKAROUND_2? Or should we lift the limitation in the BL31 to allow secure world to call PSCI_VERSION ans PSCI_FEATURES?\n\nThank you.\n\n[1] https://developer.arm.com/documentation/den0022/latest/\n[2] https://developer.arm.com/documentation/den0028/latest/",
      "parentUuid": "6c78ac9f_10eefe5e",
      "revId": "b759ef088a5d7fc483d59d6a926c629ffb2cd268",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8f20e805_6d773e58",
        "filename": "lib/psci/psci_main.c",
        "patchSetId": 1
      },
      "lineNbr": 387,
      "author": {
        "id": 1000098
      },
      "writtenOn": "2021-10-15T17:54:37Z",
      "side": 1,
      "message": "Hi Florian\nYes, I think you are right that there is some ambiguity in the spec.\nSMCCC_ARCH_WORKAROUND_1 needs SMCCC_ARCH_FEATURES to know if it\u0027s supported; SMCCC_ARCH_FEATURES needs PSCI_FEATURES to know if its implemented; PSCI_FEATURES needs PSCI_VERSION to know if it\u0027s supported.\n\nOn a relevant note, SMCCC spec also says that, apart from discovering via PSCI_fEATURES, the software can rely on two other mechanisms to discover SMCCC_VERSION\n1) built-in knowledge of firmware implementation. We know TF-A implements SMCCC v1.1 extensions. \n2) Use fdt. TF-A passes various firmware configuration dtbs to BL32(TrustedOS).\n\nCan\u0027t ProvenCore OS use these two mechanisms?\n\nI am just thinking out loud. Also, SMCCC_ARCH_WORKAROUND_1 and SMCCC_ARCH_WORKAROUND_2 are applied by default during boot by TF-A BL31[Note-1]. Why does secure software need to invoke these workarounds again? If I am not mistaken, applying these workarounds through SMC call may be futile[Note-2].\n\n[Note-1] https://git.trustedfirmware.org/TF-A/trusted-firmware-a.git/tree/lib/cpus/cpu-ops.mk#n24\n[Note-2] https://git.trustedfirmware.org/TF-A/trusted-firmware-a.git/tree/services/arm_arch_svc/arm_arch_svc_setup.c#n129\n\nPlease let me know your thoughts.",
      "parentUuid": "58e7e8de_8692f6d1",
      "revId": "b759ef088a5d7fc483d59d6a926c629ffb2cd268",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "360d12cd_8cd908f8",
        "filename": "lib/psci/psci_main.c",
        "patchSetId": 1
      },
      "lineNbr": 387,
      "author": {
        "id": 1000707
      },
      "writtenOn": "2021-10-18T10:43:29Z",
      "side": 1,
      "message": "Hi Madhukar,\n\nThank you for your answer.\n\nIndeed, among the two other mechanisms mentioned to discover SMCCC_VERSION, we could easily implement 1) in ProvenCore OS (which I referred to as \"statically configure\" in my previous message). Solution 2) is harder for us as ProvenCore currently does not expect dynamic configuration passed by TF-A.\n\nAbout SMCCC_ARCH_WORKAROUND_1 specifically, my understanding is that countering CVE-2017-5715 is done by invalidating the BTB on entry from lower EL. This means that BTB needs to be invalidated in 2 cases relevant for us here:\n  1) when we enter EL3 from lower EL. This is done by replacing the TF-A exception vector (e.g. [1])\n  2) when we enter EL1 from EL0. This can happen both in secure and normal world. In both cases, EL1 software can invalidate the BTB itself (e.g. by disabling / reenabling MMU). However SMCCC v1.1 introduced the SMCCC_ARCH_WORKAROUND_1 to allow EL1 software to delegate BTB invalidation to EL3 in case it is hard to implement at EL1 (for instance if the exception vector cannot be mapped 1:1 to allow disabling / reenabling MMU)\n\nAlthough implementing MMU disable / reenable in ProvenCore is theoretically possible, doing so would require substantial rework in the ProvenCore OS. We would rather use the SMCCC_ARCH_WORKAROUND_1 which, according to the SMCCC specification seemed to be available also to secure world.\n\nI may be confused about how the CVE-2017-5715 workaround is implemented in the TF-A, so please correct me if I understood it wrong.\n\n[1] https://git.trustedfirmware.org/TF-A/trusted-firmware-a.git/tree/lib/cpus/aarch64/cortex_a72.S#n152",
      "parentUuid": "8f20e805_6d773e58",
      "revId": "b759ef088a5d7fc483d59d6a926c629ffb2cd268",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cd7053fc_5ba0b29d",
        "filename": "lib/psci/psci_main.c",
        "patchSetId": 1
      },
      "lineNbr": 387,
      "author": {
        "id": 1000098
      },
      "writtenOn": "2021-10-18T22:39:02Z",
      "side": 1,
      "message": "Hi Florian\nI will ask few other folks in Arm to take a look at this issue.",
      "parentUuid": "360d12cd_8cd908f8",
      "revId": "b759ef088a5d7fc483d59d6a926c629ffb2cd268",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "95d75ebb_f1732275",
        "filename": "lib/psci/psci_main.c",
        "patchSetId": 1
      },
      "lineNbr": 387,
      "author": {
        "id": 1000707
      },
      "writtenOn": "2021-10-19T09:52:53Z",
      "side": 1,
      "message": "Hello everyone,\n\nThank you for your feedback. I wanted to add that an alternative solution we did not discuss yet is that ProvenCore OS could use PSCI_VERSION (or any other arbitrary SMC) instead of SMCCC_ARCH_WORKAROUND_1 in order to invalidate BTB from S-EL1. This would be slightly less efficient than using the SMCCC_ARCH_WORKAROUND_1 shortcut, but would still invalidate the BTB on EL3 entry, even if the call eventually fails due to it coming from secure world.\n\nIt seems to me that this solution would be a bit less elegant than SMCCC_ARCH_WORKAROUND_1 as it relies on an implementation detail (BTB invalidation every time we enter EL3) rather than on a documented SMC feature.\n\nTo put it in a nutshell, I see 3 way we can go:\n1) allow PSCI_VERSION and PSCI_FEATURES from secure world so that BL32 can dynamically discover SMCCC_ARCH_WORKAROUND_1\n2) built-in knowledge in ProvenCore OS about the firmware implementation of SMCCC_ARCH_WORKAROUND_1\n3) Use PSCI_VERSION or any other SMC known to be implemented and harmless from BL32 to invalidate BTB\n\nI am waiting for your opinion on which one we should choose and I will then update the PR accordingly.\n\nThank you",
      "parentUuid": "cd7053fc_5ba0b29d",
      "revId": "b759ef088a5d7fc483d59d6a926c629ffb2cd268",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f747b0f6_13b9eaf5",
        "filename": "lib/psci/psci_main.c",
        "patchSetId": 1
      },
      "lineNbr": 387,
      "author": {
        "id": 1000228
      },
      "writtenOn": "2021-10-19T10:03:27Z",
      "side": 1,
      "message": "Calling PSCI functions from the secure side (or SEL1) shall be discouraged to my opinion. As said it contradicts the PSCI standard itself. IIUC the code snippet in SMCCC Appendix B relates to execution from the normal world. There is no other way for the normal world to know about firmware capabilities. Whereas TOS and (TF-A) firmware are close companions so a TOS \u0027statically knows\u0027 which firmware version it runs on to. Eventually the SPD can communicate the built in SMCCC version when entering the TOS through boot parms. Notice SMCCC_VERSION and SMCCC_ARCH_FEATURES are mandatory from SMCCCv1.1 (which is the point of probing for Spectre/Meltdown mitigation services). Provided TF-A advertises support for SMCCCv1.2, I guess it\u0027s just safe to call them straight without invoking any PSCI service.",
      "parentUuid": "95d75ebb_f1732275",
      "revId": "b759ef088a5d7fc483d59d6a926c629ffb2cd268",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5b167225_081d9b55",
        "filename": "lib/psci/psci_main.c",
        "patchSetId": 1
      },
      "lineNbr": 387,
      "author": {
        "id": 1000707
      },
      "writtenOn": "2021-10-19T11:54:38Z",
      "side": 1,
      "message": "I get your point and, from our point of view, statically configuring ProvenCore to match the implemented features in the firmware is perfectly fine.\n\nI\u0027d like to give a little bit of context to share our point of view about how tightly coupled the TOS and firmware should be: ProvenCore OS is a preemptive micro-kernel with formally proven security properties in terms of isolation of its applications. Although it provides some general purpose OS features (IPCs, dynamic allocation, etc.), its simplicity and hardened security make it best fitted for being used as a TOS. However, it is also able to run standalone (in normal world) as a general purpose OS. Also, we maintain a custom implementation of a minimal firmware which is interchangeable with TF-A from the point of view of ProvenCore. Furthermore, ProvenCore has been ported on other architectures, such as RISC-V where some of the TF-A functionalities are implemented by the M-mode software (OpenSBI for instance). So, from our point of view (which may differ from TF-A\u0027s), there is a limit to how tightly coupled firmware and TOS should be. This is why I have been reluctant to using boot params passed from TF-A and prefer to use a ProvenCore static configuration, which would still be needed to specify whether we should expect boot params from firmware or not.",
      "parentUuid": "f747b0f6_13b9eaf5",
      "revId": "b759ef088a5d7fc483d59d6a926c629ffb2cd268",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    }
  ]
}