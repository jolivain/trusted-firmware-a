{
  "comments": [
    {
      "key": {
        "uuid": "6b1b75f6_c68632a1",
        "filename": "lib/cpus/aarch64/cortex_a76.S",
        "patchSetId": 1
      },
      "lineNbr": 372,
      "author": {
        "id": 1000105
      },
      "writtenOn": "2019-05-03T13:43:52Z",
      "side": 1,
      "message": "why this implementation is different to other errata processings?",
      "revId": "f471ce7b752d9f029d40f5cfde285468615e6c14",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8075a879_2eb0c19f",
        "filename": "lib/cpus/aarch64/cortex_a76.S",
        "patchSetId": 1
      },
      "lineNbr": 372,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2019-05-07T12:55:05Z",
      "side": 1,
      "message": "Good question.\nAll the other erratas have a runtime check which slips applying the errata workaround if the check reports as `ERRATA_NOT_APPLIES` even if enabled during build\n\nDue to the nature of workaround of this errata, if the errata is enabled during build, it always applies irrespective if the CPU variant has the errata fixed or not. Hence the difference for this workaround.",
      "parentUuid": "6b1b75f6_c68632a1",
      "revId": "f471ce7b752d9f029d40f5cfde285468615e6c14",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "dd298d70_78001c65",
        "filename": "lib/cpus/aarch64/cortex_a76.S",
        "patchSetId": 1
      },
      "lineNbr": 372,
      "author": {
        "id": 1000105
      },
      "writtenOn": "2019-05-07T13:03:07Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "8075a879_2eb0c19f",
      "revId": "f471ce7b752d9f029d40f5cfde285468615e6c14",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": false
    }
  ]
}