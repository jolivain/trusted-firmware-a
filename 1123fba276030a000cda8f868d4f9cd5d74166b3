{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "fdabe1b5_a3beca11",
        "filename": "drivers/delay_timer/plat_delay_timer.c",
        "patchSetId": 1
      },
      "lineNbr": 11,
      "author": {
        "id": 1000328
      },
      "writtenOn": "2024-08-08T08:45:10Z",
      "side": 1,
      "message": "nit: remove white-space",
      "range": {
        "startLine": 11,
        "startChar": 62,
        "endLine": 11,
        "endChar": 63
      },
      "revId": "1123fba276030a000cda8f868d4f9cd5d74166b3",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "eaa09b34_e4bae824",
        "filename": "drivers/delay_timer/plat_delay_timer.c",
        "patchSetId": 1
      },
      "lineNbr": 11,
      "author": {
        "id": 1001360
      },
      "writtenOn": "2024-08-08T17:35:16Z",
      "side": 1,
      "message": "Acknowledged",
      "parentUuid": "fdabe1b5_a3beca11",
      "range": {
        "startLine": 11,
        "startChar": 62,
        "endLine": 11,
        "endChar": 63
      },
      "revId": "1123fba276030a000cda8f868d4f9cd5d74166b3",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "894bd74d_eca4f5f7",
        "filename": "drivers/delay_timer/plat_delay_timer.c",
        "patchSetId": 1
      },
      "lineNbr": 12,
      "author": {
        "id": 1000328
      },
      "writtenOn": "2024-08-08T08:45:10Z",
      "side": 1,
      "message": "ditto",
      "range": {
        "startLine": 12,
        "startChar": 62,
        "endLine": 12,
        "endChar": 63
      },
      "revId": "1123fba276030a000cda8f868d4f9cd5d74166b3",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8f6e390a_93a212b7",
        "filename": "drivers/delay_timer/plat_delay_timer.c",
        "patchSetId": 1
      },
      "lineNbr": 12,
      "author": {
        "id": 1001360
      },
      "writtenOn": "2024-08-08T17:35:16Z",
      "side": 1,
      "message": "Acknowledged",
      "parentUuid": "894bd74d_eca4f5f7",
      "range": {
        "startLine": 12,
        "startChar": 62,
        "endLine": 12,
        "endChar": 63
      },
      "revId": "1123fba276030a000cda8f868d4f9cd5d74166b3",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1e5c3778_4d2db6e0",
        "filename": "drivers/delay_timer/plat_delay_timer.c",
        "patchSetId": 1
      },
      "lineNbr": 31,
      "author": {
        "id": 1000328
      },
      "writtenOn": "2024-08-08T08:45:10Z",
      "side": 1,
      "message": "nit: remove extra line",
      "revId": "1123fba276030a000cda8f868d4f9cd5d74166b3",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9da21629_6a674bd3",
        "filename": "drivers/delay_timer/plat_delay_timer.c",
        "patchSetId": 1
      },
      "lineNbr": 31,
      "author": {
        "id": 1001360
      },
      "writtenOn": "2024-08-08T17:35:16Z",
      "side": 1,
      "message": "Acknowledged",
      "parentUuid": "1e5c3778_4d2db6e0",
      "revId": "1123fba276030a000cda8f868d4f9cd5d74166b3",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1711c28c_ddf2e22d",
        "filename": "plat/rpi/rpi3/plat_delay_timer.c",
        "patchSetId": 1
      },
      "lineNbr": 6,
      "author": {
        "id": 1000328
      },
      "writtenOn": "2024-08-08T08:45:10Z",
      "side": 1,
      "message": "I\u0027m reconsidering the need for platform-specific functions for the timer. Could we instead write a timer driver for the rpi3 and connect it to the existing [delay timer] implementation?\nLook at how the FVP platform integrates the SP804 timer and generic timer with the common delay timer.\n\n\n[delay timer]: https://review.trustedfirmware.org/plugins/gitiles/TF-A/trusted-firmware-a/+/refs/heads/integration/drivers/delay_timer/delay_timer.c",
      "revId": "1123fba276030a000cda8f868d4f9cd5d74166b3",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d18d3563_caab9710",
        "filename": "plat/rpi/rpi3/plat_delay_timer.c",
        "patchSetId": 1
      },
      "lineNbr": 6,
      "author": {
        "id": 1001360
      },
      "writtenOn": "2024-08-08T17:35:16Z",
      "side": 1,
      "message": "We can do it this way, but then we need to include if else statements in common code for the timer, the FVP uses the timer in platform setup code, whereas this timer will be used in common drivers such as \"tpm2_fifo.c\" but it still contains if else statements. It is a design choice.",
      "parentUuid": "1711c28c_ddf2e22d",
      "revId": "1123fba276030a000cda8f868d4f9cd5d74166b3",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "99fb5740_41ef2c45",
        "filename": "plat/rpi/rpi3/plat_delay_timer.c",
        "patchSetId": 1
      },
      "lineNbr": 6,
      "author": {
        "id": 1000328
      },
      "writtenOn": "2024-08-08T21:06:07Z",
      "side": 1,
      "message": "In the current implementation, there is a flaw: ``timeout_init_us`` and ``timeout_elapsed`` are incorrectly defined in the ``delay_timer`` interface header. These functions should be part of the ``generic_delay_timer`` (architectural timer) header instead, as they access the system register (Counter-timer Physical Count register) of the CPU. It would be better to move these functions to the ``generic_delay_timer.h`` file, and platforms should use this header instead of ``delay_timer.h`` when these functions are needed.\n\nI suggest that we hook ``timeout_init_us`` and ``timeout_elapsed`` into timer_ops_t and register this platform-specific timer driver ops for the Raspberry Pi 3 through the ``timer_init`` function, rather than using platform-specific APIs.\n\nAdditionally, I\u0027m unclear why a separate timer driver was created for the Raspberry Pi 3. Upon reviewing the code, I noticed that the generic delay timer is already compiled in BL2 for Raspberry Pi 3, and you may need it for BL1 as well for dTPM. see [1] and [2].\n\n[1]: https://review.trustedfirmware.org/plugins/gitiles/TF-A/trusted-firmware-a/+/refs/heads/master/plat/rpi/rpi3/platform.mk#37\n[2]: https://review.trustedfirmware.org/plugins/gitiles/TF-A/trusted-firmware-a/+/refs/heads/master/plat/rpi/common/rpi3_common.c#203",
      "parentUuid": "d18d3563_caab9710",
      "revId": "1123fba276030a000cda8f868d4f9cd5d74166b3",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fdb6667f_527eabe1",
        "filename": "plat/rpi/rpi3/plat_delay_timer.c",
        "patchSetId": 1
      },
      "lineNbr": 6,
      "author": {
        "id": 1001360
      },
      "writtenOn": "2024-08-12T17:08:06Z",
      "side": 1,
      "message": "Thanks for your comments Manish,\n\nDuring the development of the drivers, I was trying to use the provided delay_timer.h functions such as timeout_init_us and timeout_elapsed. \n\nThe problem I encountered is that these functions read the register CNTFRQ, and in the case of RPI3 this register is empty in TF-A. The register should be set to the CPU clock frequency. Nowhere did I see online that this can be done for RPI3, and I also tried to write an estimated clock frequency of 19.2Mhz to the register, but this did not work. In the arm fvp platform, arm_configure_sys_timer() handles the initialization of the CNTFRQ register. For RPI3 there is no ARM_SYS_TIMCTL_BASE address...\n\nBecause of this, delay_timer is not working for RPI3. This is why I implemented a specific plat delay timer for the RPI3.",
      "parentUuid": "99fb5740_41ef2c45",
      "revId": "1123fba276030a000cda8f868d4f9cd5d74166b3",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "40ab5ef4_2e9e3736",
        "filename": "plat/rpi/rpi3/plat_delay_timer.c",
        "patchSetId": 1
      },
      "lineNbr": 6,
      "author": {
        "id": 1000328
      },
      "writtenOn": "2024-08-14T07:41:40Z",
      "side": 1,
      "message": "```\n\ndiff --git a/drivers/delay_timer/delay_timer.c b/drivers/delay_timer/delay_timer.c\nindex a3fd7bfeb..4f1351111 100644\n--- a/drivers/delay_timer/delay_timer.c\n+++ b/drivers/delay_timer/delay_timer.c\n@@ -80,3 +80,23 @@ void timer_init(const timer_ops_t *ops_ptr)\n \n        timer_ops \u003d ops_ptr;\n }\n+\n+/***********************************************************\n+ * Initialize the timer in us\n+ ***********************************************************/\n+uint64_t timer_init_us(uint32_t usec)\n+{\n+       assert(timer_ops !\u003d NULL);\n+       assert(timer_ops-\u003etimer_init_us !\u003d NULL); \n+\n+       return (timer_ops-\u003etimer_init_us(usec));\n+}\n+\n+/***********************************************************\n+ * check the given timeout elapsed or not.\n+ ***********************************************************/\n+bool timeout_elapsed(uint64_t cnt)\n+{\n+       assert(timer_ops !\u003d NULL);\n+       assert(timer_ops-\u003etimeout_elapsed !\u003d NULL);\n+\n+       return (timer_ops-\u003etimeout_elapsed(usec));\n+}\n\ndiff --git a/drivers/delay_timer/generic_delay_timer.c b/drivers/delay_timer/generic_delay_timer.c\nindex ca522e05a..1ea9fba9a 100644\n--- a/drivers/delay_timer/generic_delay_timer.c\n+++ b/drivers/delay_timer/generic_delay_timer.c\n@@ -18,6 +18,25 @@\n \n static timer_ops_t ops;\n \n+static uint64_t timeout_cnt_us2cnt(uint32_t us)\n+{\n+        return ((uint64_t)us * (uint64_t)read_cntfrq_el0()) / 1000000ULL;\n+}\n+\n+uint64_t timeout_init_us(uint32_t us)\n+{\n+        uint64_t cnt \u003d timeout_cnt_us2cnt(us);\n+\n+        cnt +\u003d read_cntpct_el0();\n+\n+        return cnt;\n+}\n+\n+bool timeout_elapsed(uint64_t expire_cnt)\n+{\n+        return read_cntpct_el0() \u003e expire_cnt;\n+}\n+\n static uint32_t get_timer_value(void)\n {\n        /*\n@@ -34,6 +53,8 @@ void generic_delay_timer_init_args(uint32_t mult, uint32_t div)\n        ops.get_timer_value     \u003d get_timer_value;\n        ops.clk_mult            \u003d mult;\n        ops.clk_div             \u003d div;\n+       ops.timeout_init_us     \u003d timeout_init_us;\n+       ops.timeout_elapsed     \u003d timeout_elapsed;\n \n        timer_init(\u0026ops);\ndiff --git a/include/drivers/delay_timer.h b/include/drivers/delay_timer.h\nindex 20a554357..1eba491a7 100644\n--- a/include/drivers/delay_timer.h\n+++ b/include/drivers/delay_timer.h\n@@ -25,27 +25,12 @@ typedef struct timer_ops {\n        uint32_t (*get_timer_value)(void);\n        uint32_t clk_mult;\n        uint32_t clk_div;\n+       uint64_t (*timeout_init_us)(uint32_t);\n+       bool (*timeout_elapsed)(uint64_t);\n } timer_ops_t;\n-static inline uint64_t timeout_cnt_us2cnt(uint32_t us)\n-{\n-       return ((uint64_t)us * (uint64_t)read_cntfrq_el0()) / 1000000ULL;\n-}\n-\n-static inline uint64_t timeout_init_us(uint32_t us)\n-{\n-       uint64_t cnt \u003d timeout_cnt_us2cnt(us);\n-\n-       cnt +\u003d read_cntpct_el0();\n-\n-       return cnt;\n-}\n-\n-static inline bool timeout_elapsed(uint64_t expire_cnt)\n-{\n-       return read_cntpct_el0() \u003e expire_cnt;\n-}\n-\n+uint64_t timeout_init_us(uint32_t us);\n+bool timeout_elapsed(uint64_t cnt);\n void mdelay(uint32_t msec);\n void udelay(uint32_t usec);\n void timer_init(const timer_ops_t *ops_ptr);\n \n ```\n\nNote: it is not tested code 😊.\n\nI envision a setup where ``timeout_init_us`` and ``timeout_elapsed`` are integrated within the timer operations, eliminating the need for separate platform definitions. To align with this framework, you\u0027ll need to enhance the existing driver implementation. Your timer driver should include these timer operations, and you\u0027ll also need to ensure that these operations are properly registered via ``timer_init``. \n\nAdditionally, as previously mentioned, the Raspberry Pi 3 platform uses the generic delay timer during BL2 compilation. Therefore, opting not to use the generic timer and creating a separate timer driver means that the generic delay timer being non-functional on this platform. \n@Andre, do you have any idea whether generic delay timer functional for Raspberry Pi 3?",
      "parentUuid": "fdb6667f_527eabe1",
      "revId": "1123fba276030a000cda8f868d4f9cd5d74166b3",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "efff5aff_0dcc7914",
        "filename": "plat/rpi/rpi3/plat_delay_timer.c",
        "patchSetId": 1
      },
      "lineNbr": 6,
      "author": {
        "id": 1001360
      },
      "writtenOn": "2024-08-20T14:14:21Z",
      "side": 1,
      "message": "Understood, I am working on this implementation. Once question I had is why are the definitions being moved over from delay_timer.h to generic_delay_timer.c?",
      "parentUuid": "40ab5ef4_2e9e3736",
      "revId": "1123fba276030a000cda8f868d4f9cd5d74166b3",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4a9d63d9_74e30373",
        "filename": "plat/rpi/rpi3/plat_delay_timer.c",
        "patchSetId": 1
      },
      "lineNbr": 24,
      "author": {
        "id": 1000328
      },
      "writtenOn": "2024-08-14T07:41:40Z",
      "side": 1,
      "message": "What is the frequency of this timer? It seems to be assuming that the timer ticks every microsecond. Is that correct?",
      "range": {
        "startLine": 24,
        "startChar": 21,
        "endLine": 24,
        "endChar": 38
      },
      "revId": "1123fba276030a000cda8f868d4f9cd5d74166b3",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9d8ac1cc_2ce5057c",
        "filename": "plat/rpi/rpi3/plat_delay_timer.c",
        "patchSetId": 1
      },
      "lineNbr": 24,
      "author": {
        "id": 1001360
      },
      "writtenOn": "2024-08-20T14:14:21Z",
      "side": 1,
      "message": "yes It is assuming microseconds, the rpi SYSTEM_TIMER_CLO is read in and gives us the time in us.",
      "parentUuid": "4a9d63d9_74e30373",
      "range": {
        "startLine": 24,
        "startChar": 21,
        "endLine": 24,
        "endChar": 38
      },
      "revId": "1123fba276030a000cda8f868d4f9cd5d74166b3",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    }
  ]
}