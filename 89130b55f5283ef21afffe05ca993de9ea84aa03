{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "022f9321_fd4dd8af",
        "filename": "include/plat/arm/common/arm_def.h",
        "patchSetId": 5
      },
      "lineNbr": 471,
      "author": {
        "id": 1000043
      },
      "writtenOn": "2021-06-22T11:09:39Z",
      "side": 1,
      "message": "Could you please explain the reason why BL32 must be a PIE in this case? Can\u0027t we link BL32 binary such that it runs from the reset vector address?",
      "range": {
        "startLine": 469,
        "startChar": 0,
        "endLine": 471,
        "endChar": 6
      },
      "revId": "89130b55f5283ef21afffe05ca993de9ea84aa03",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7d1866ba_9e324cd6",
        "filename": "include/plat/arm/common/arm_def.h",
        "patchSetId": 5
      },
      "lineNbr": 471,
      "author": {
        "id": 1000102
      },
      "writtenOn": "2021-06-22T11:18:44Z",
      "side": 1,
      "message": "This is same logic as in aarch64 RESET_TO_BL31 where BL31 is only binary.\nAlso being compiled as PIE it can run from any address, isn\u0027t it ?",
      "parentUuid": "022f9321_fd4dd8af",
      "range": {
        "startLine": 469,
        "startChar": 0,
        "endLine": 471,
        "endChar": 6
      },
      "revId": "89130b55f5283ef21afffe05ca993de9ea84aa03",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8e5f1a06_f70564bc",
        "filename": "include/plat/arm/common/arm_def.h",
        "patchSetId": 5
      },
      "lineNbr": 471,
      "author": {
        "id": 1000043
      },
      "writtenOn": "2021-06-22T11:23:35Z",
      "side": 1,
      "message": "OK, we\u0027re following the same logic as for BL31. Then same question for BL31 really ðŸ˜Š : Why is this a requirement to compile BL31 as a PIE if it\u0027s the first piece of firmware to run? I would have assumed we could just link it at address 0. Why does it need the ability to run from any address? I must be missing something...",
      "parentUuid": "7d1866ba_9e324cd6",
      "range": {
        "startLine": 469,
        "startChar": 0,
        "endLine": 471,
        "endChar": 6
      },
      "revId": "89130b55f5283ef21afffe05ca993de9ea84aa03",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "61dcfd37_1494cee9",
        "filename": "include/plat/arm/common/arm_def.h",
        "patchSetId": 5
      },
      "lineNbr": 471,
      "author": {
        "id": 1000102
      },
      "writtenOn": "2021-06-22T12:03:02Z",
      "side": 1,
      "message": "Having PIE is always better than linking with static addresses, because you can run from any address. This was a requirement long ago to make TF-A compiled as PIE, if possible. Compiling BL31 PIE was easier than BL1 and BL2, So BL31 was mandated to be compiled PIE if platform wants.(most of the platforms are now doing it).\nComing to Arm platforms, there may be scenario where BL31 not necessarily will be first piece of FW, Corstone700 for example has Secure enclave FW which then loads BL31 at some different address.\nIMO, the only reason i think is, having capability to run from any address(including 0x0) is always better than tied up to a single address.",
      "parentUuid": "8e5f1a06_f70564bc",
      "range": {
        "startLine": 469,
        "startChar": 0,
        "endLine": 471,
        "endChar": 6
      },
      "revId": "89130b55f5283ef21afffe05ca993de9ea84aa03",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    }
  ]
}