{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "a56143a1_ab660df1",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 11
      },
      "lineNbr": 0,
      "author": {
        "id": 1000467
      },
      "writtenOn": "2023-12-18T13:48:18Z",
      "side": 1,
      "message": "Just a couple of questions to help my understanding",
      "revId": "97efe9581d77a05bcee5a937e8f9ff79eb1695cf",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1a20ba4a_1be4b2e4",
        "filename": "make_helpers/toolchain.mk",
        "patchSetId": 11
      },
      "lineNbr": 260,
      "author": {
        "id": 1000467
      },
      "writtenOn": "2023-12-18T13:48:18Z",
      "side": 1,
      "message": "Why is there a comma here?",
      "range": {
        "startLine": 260,
        "startChar": 29,
        "endLine": 260,
        "endChar": 30
      },
      "revId": "97efe9581d77a05bcee5a937e8f9ff79eb1695cf",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d99f18f7_d041816e",
        "filename": "make_helpers/toolchain.mk",
        "patchSetId": 11
      },
      "lineNbr": 260,
      "author": {
        "id": 1000206
      },
      "writtenOn": "2023-12-18T15:03:41Z",
      "side": 1,
      "message": "`call` is itself a function which \"calls\" a variable, so the parameters to the `call` function in this case are `which` (the variable) and `$$($(toolchain)-$(tool-class))` (which is assigned to $0, and which is expanded by the variable). Just a quirk of how user-defined functions work in Make:\n\nhttps://www.gnu.org/software/make/manual/html_node/Call-Function.html",
      "parentUuid": "1a20ba4a_1be4b2e4",
      "range": {
        "startLine": 260,
        "startChar": 29,
        "endLine": 260,
        "endChar": 30
      },
      "revId": "97efe9581d77a05bcee5a937e8f9ff79eb1695cf",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9790c788_83bfb03c",
        "filename": "make_helpers/toolchain.mk",
        "patchSetId": 11
      },
      "lineNbr": 266,
      "author": {
        "id": 1000467
      },
      "writtenOn": "2023-12-18T13:48:18Z",
      "side": 1,
      "message": "Why is cc separated out of the for loop?",
      "revId": "97efe9581d77a05bcee5a937e8f9ff79eb1695cf",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9ad44e07_ee2e047b",
        "filename": "make_helpers/toolchain.mk",
        "patchSetId": 11
      },
      "lineNbr": 266,
      "author": {
        "id": 1000206
      },
      "writtenOn": "2023-12-18T15:03:41Z",
      "side": 1,
      "message": "We decide the C compiler slightly differently from the rest of the toolchain. For the C compiler we:\n\n1. Use `$$($(toolchain)-cc)` if it has a value, otherwise\n2. Use `$$($(toolchain)-cc-default)`\n\nFor each tool in the rest of the toolchain we:\n\n1. Use `$$($(toolchain)-$(tool))` if it has a value, otherwise\n2. Use `guess-$(tool)-$(tool-class)` to try to determine it from the C compiler, otherwise\n3. Use `$$($(toolchain)-$(tool-class)-default)`\n\nSo, for example, if the C compiler is GCC then for the `ld` tool class we call `guess-gnu-gcc-ld`, which might execute, e.g.:\n\n    aarch64-none-elf-gcc --print-prog-name ld.bfd 2\u003e/dev/null\n    \n... and (we hope) that will tell us exactly where the linker associated with the compiler is, rather than having to make a best-guess effort.",
      "parentUuid": "9790c788_83bfb03c",
      "revId": "97efe9581d77a05bcee5a937e8f9ff79eb1695cf",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    }
  ]
}