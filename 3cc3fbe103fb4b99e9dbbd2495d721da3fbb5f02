{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "b41ffeb7_399dd3c7",
        "filename": "lib/el3_runtime/aarch64/context_mgmt.c",
        "patchSetId": 3
      },
      "lineNbr": 488,
      "author": {
        "id": 1000883
      },
      "writtenOn": "2023-02-10T11:31:48Z",
      "side": 1,
      "message": "why is the check being outsourced to the caller? Perhaps I missed that bit of discussion, but it feels a little inconsistent with the hook doing it internally.\n\nMy thinking is that it\u0027s a thing to forget when using the enable/disable and code outside of CTX management will need to do it (like spe_disable).",
      "revId": "3cc3fbe103fb4b99e9dbbd2495d721da3fbb5f02",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "44f8f71b_458a6124",
        "filename": "lib/el3_runtime/aarch64/context_mgmt.c",
        "patchSetId": 3
      },
      "lineNbr": 488,
      "author": {
        "id": 1000118
      },
      "writtenOn": "2023-02-10T12:03:57Z",
      "side": 1,
      "message": "Yeah, I am not convinced of that either, but if I got Soby correctly, he wanted it that way. On the plus side we save the not-so-nice stubbing in the header file: https://review.trustedfirmware.org/c/TF-A/trusted-firmware-a/+/18992/2/include/lib/extensions/trbe.h\nSo this is one question I hoped to get some comments on. The other one is whether we want to have extra checks in the functions. I dropped them here, for this version, since they are now somewhat redundant, but we could put them back, just to be consistent and more future-proof.\nSoby, can you say what you think of this?",
      "parentUuid": "b41ffeb7_399dd3c7",
      "revId": "3cc3fbe103fb4b99e9dbbd2495d721da3fbb5f02",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f30a5e8d_84ca6ba2",
        "filename": "lib/el3_runtime/aarch64/context_mgmt.c",
        "patchSetId": 3
      },
      "lineNbr": 488,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2023-02-10T12:37:35Z",
      "side": 1,
      "message": "Couple of reasons I thought the check on the caller side makes more sense.\n\n1. As mentioned by Andre, it avoids the multiple declarations in the header.\n2. Today TRBE is only being used by NS, but in future it may be enabled by Realm. So the implicit check for build flag `ENABLE_TRBE_FOR_NS` in trb_enable()  might make it inconvenient. [trbe_enable() would need enhancement to take additional parameters like a world specific context and enum to indicate the world].\n\nPoint 1 was the main motivation and point 2 is a bit of blue sky thinking at the moment. Since there is no down side for making the check at caller side, thought it preferable.",
      "parentUuid": "44f8f71b_458a6124",
      "revId": "3cc3fbe103fb4b99e9dbbd2495d721da3fbb5f02",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7736fac6_8e8ddb41",
        "filename": "lib/el3_runtime/aarch64/context_mgmt.c",
        "patchSetId": 3
      },
      "lineNbr": 488,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2023-02-10T12:58:40Z",
      "side": 1,
      "message": "Hmm, It is better to have consistent pattern for enable/disable and save/restore.\n\nI realized that the save and restore helpers are doing the check inside the implementation. Which means that either save/restore would need to move the check to the caller as well or enable/disable would need to have the checks inside them.\n\nIn the case save/restore, if we want to support different dispatchers to independently control this via separate build config options, then the check has to be done at caller side. Today I believe we dont have such a case. But a hypothetical case would be, say RMMD_ENABLE_FGT :\n\nrmmd_init() {\n\nif (is_fgt_supported() \u0026\u0026 RMMD_ENABLE_FGT)\n   enable_fgt(REALM);\n\n}\n\nrmmd_smc_handler() {\n\nif (is_fgt_supported() \u0026\u0026 RMMD_ENABLE_FGT)\n   el2_save_fgt_context();\n\n---\n}\n\nWe should align enable/disable and save/restore whichever direction we take",
      "parentUuid": "f30a5e8d_84ca6ba2",
      "revId": "3cc3fbe103fb4b99e9dbbd2495d721da3fbb5f02",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7bdd0333_be7b1f0a",
        "filename": "lib/el3_runtime/aarch64/context_mgmt.c",
        "patchSetId": 3
      },
      "lineNbr": 488,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2023-02-10T13:08:25Z",
      "side": 1,
      "message": "It seems only el2_sysregs_context_save_mpam() and \tel2_sysregs_context_save_fgt() have checks inside the caller whereas rest of EL2 context operations have checks in caller side. So might be better to move the checks to caller side for these as well.",
      "parentUuid": "7736fac6_8e8ddb41",
      "revId": "3cc3fbe103fb4b99e9dbbd2495d721da3fbb5f02",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f495201f_62f4798a",
        "filename": "lib/el3_runtime/aarch64/context_mgmt.c",
        "patchSetId": 3
      },
      "lineNbr": 488,
      "author": {
        "id": 1000883
      },
      "writtenOn": "2023-02-10T13:31:59Z",
      "side": 1,
      "message": "Wouldn\u0027t having separate enables for each context make sense? For example, a refactor I wanted to do to untangle the root context out of the various context setting routines is spinning out the el2 enables when el2 is empty (again using SPE as an example). In that case there would be lots of ways to enter the extension and checking there makes more sense to me.",
      "parentUuid": "7bdd0333_be7b1f0a",
      "revId": "3cc3fbe103fb4b99e9dbbd2495d721da3fbb5f02",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1f495477_06381d87",
        "filename": "lib/el3_runtime/aarch64/context_mgmt.c",
        "patchSetId": 3
      },
      "lineNbr": 488,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2023-02-10T14:03:17Z",
      "side": 1,
      "message": "Yes, that is also a possible soln. el2_empty is a legacy config which probably needs to be removed. In most cases, the code to enable a feature for NS/S/Realm is the same. The root world might need a different variant.\n\nAnother thing which I haven\u0027t thought through is, we have different flavours of SPDs although there is only SPMD for S-El2 in TF-A. If we had a enable_mte_secure() which internally assumes Hafnium SPMD, that may trip up other SPDs.\n\nSome of this is speculation and I dont have a strong argument in favour of either direction. Perhaps, we just do what makes most sense today and then refactor as we need when situation arises. We just need to be consistent through out, that is the important thing.",
      "parentUuid": "f495201f_62f4798a",
      "revId": "3cc3fbe103fb4b99e9dbbd2495d721da3fbb5f02",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7469c7ca_d83322ab",
        "filename": "lib/el3_runtime/aarch64/context_mgmt.c",
        "patchSetId": 3
      },
      "lineNbr": 488,
      "author": {
        "id": 1000118
      },
      "writtenOn": "2023-02-10T14:10:25Z",
      "side": 1,
      "message": "So U-Boot uses something to hide config decision for different parts or builds of the code base nicely:\n    if (CONFIG_IS_ENABLED(DM_MMC))\nwill consider CONFIG_SPL_DM_MMC if this compilation run is for the SPL (compare to IMAGE_BL1), and CONFIG_DM_MMC if it is for U-Boot proper (cf. IMAGE_BL31). This is all wrapped by some simple macro definitions.\nWe could maybe have something along that idea, if we can identify a limited number of different groups, like SEC, NS, RMM.\nIs there a way to automatically identify the context we need that enablement decision for? So can we work out automatically (by checking some macros?) if this is for RME/SEC/NS? Can this be derived from the file we are in, or is there already some macro defined (like IMAGE_BL1/IMAGE_BL31)?\nThen we can hide all those tedious combinations in one file, and users just ask for is_fgt_supported().",
      "parentUuid": "7736fac6_8e8ddb41",
      "revId": "3cc3fbe103fb4b99e9dbbd2495d721da3fbb5f02",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "52458501_ac3d09ce",
        "filename": "lib/el3_runtime/aarch64/context_mgmt.c",
        "patchSetId": 3
      },
      "lineNbr": 488,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2023-02-10T14:28:16Z",
      "side": 1,
      "message": "hmm, no, We dont have those macros today.\n\nIdeally we dont want to give this configurability to TF-A unless the platforms face a dire memory situation. Taking the FGT example, if FGT is legal to be enabled for 3 worlds, the is_fgt_supported() depending on NS flag is OK. We can use is_fgt_supported() to enable FGT for Secure and Realm.\n\nIf some platform is running low on memory and want to save some EL3 SRAM, then we might need a separate Realm and Secure option so as to enable only for NS and keep it disabled for Secure and Realm (as long as RMM and SPM is also informed/configured to ignore FGT).\n\nSo it not clear whether we will need these RMMD/SPMD specific build flags per feature. \n\nFor now, lets keep it simple and use the is_fgt_supported() in all cases. So having the check inside the function is fine.",
      "parentUuid": "7469c7ca_d83322ab",
      "revId": "3cc3fbe103fb4b99e9dbbd2495d721da3fbb5f02",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "bd7d365a_8605e323",
        "filename": "lib/el3_runtime/aarch64/context_mgmt.c",
        "patchSetId": 3
      },
      "lineNbr": 488,
      "author": {
        "id": 1000118
      },
      "writtenOn": "2023-02-15T15:43:42Z",
      "side": 1,
      "message": "Not sure where this discussion is really going, it looks like this is more something for the future, when we will get actual support beyond NS.\nFor now I will keep the check outside of the function, which is what we do for other features (including MPAM now).",
      "parentUuid": "52458501_ac3d09ce",
      "revId": "3cc3fbe103fb4b99e9dbbd2495d721da3fbb5f02",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "dda06d96_f353cf09",
        "filename": "lib/extensions/trbe/trbe.c",
        "patchSetId": 3
      },
      "lineNbr": 53,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2023-02-10T10:40:54Z",
      "side": 1,
      "message": "Just a comment not related to this patch. TRBE buffers should be drained when entering Realm world as well. Will take a action to see if this scheme will scale for Realm world.",
      "range": {
        "startLine": 53,
        "startChar": 19,
        "endLine": 53,
        "endChar": 43
      },
      "revId": "3cc3fbe103fb4b99e9dbbd2495d721da3fbb5f02",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    }
  ]
}