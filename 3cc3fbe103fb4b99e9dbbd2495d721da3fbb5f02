{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "b41ffeb7_399dd3c7",
        "filename": "lib/el3_runtime/aarch64/context_mgmt.c",
        "patchSetId": 3
      },
      "lineNbr": 488,
      "author": {
        "id": 1000883
      },
      "writtenOn": "2023-02-10T11:31:48Z",
      "side": 1,
      "message": "why is the check being outsourced to the caller? Perhaps I missed that bit of discussion, but it feels a little inconsistent with the hook doing it internally.\n\nMy thinking is that it\u0027s a thing to forget when using the enable/disable and code outside of CTX management will need to do it (like spe_disable).",
      "revId": "3cc3fbe103fb4b99e9dbbd2495d721da3fbb5f02",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "44f8f71b_458a6124",
        "filename": "lib/el3_runtime/aarch64/context_mgmt.c",
        "patchSetId": 3
      },
      "lineNbr": 488,
      "author": {
        "id": 1000118
      },
      "writtenOn": "2023-02-10T12:03:57Z",
      "side": 1,
      "message": "Yeah, I am not convinced of that either, but if I got Soby correctly, he wanted it that way. On the plus side we save the not-so-nice stubbing in the header file: https://review.trustedfirmware.org/c/TF-A/trusted-firmware-a/+/18992/2/include/lib/extensions/trbe.h\nSo this is one question I hoped to get some comments on. The other one is whether we want to have extra checks in the functions. I dropped them here, for this version, since they are now somewhat redundant, but we could put them back, just to be consistent and more future-proof.\nSoby, can you say what you think of this?",
      "parentUuid": "b41ffeb7_399dd3c7",
      "revId": "3cc3fbe103fb4b99e9dbbd2495d721da3fbb5f02",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f30a5e8d_84ca6ba2",
        "filename": "lib/el3_runtime/aarch64/context_mgmt.c",
        "patchSetId": 3
      },
      "lineNbr": 488,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2023-02-10T12:37:35Z",
      "side": 1,
      "message": "Couple of reasons I thought the check on the caller side makes more sense.\n\n1. As mentioned by Andre, it avoids the multiple declarations in the header.\n2. Today TRBE is only being used by NS, but in future it may be enabled by Realm. So the implicit check for build flag `ENABLE_TRBE_FOR_NS` in trb_enable()  might make it inconvenient. [trbe_enable() would need enhancement to take additional parameters like a world specific context and enum to indicate the world].\n\nPoint 1 was the main motivation and point 2 is a bit of blue sky thinking at the moment. Since there is no down side for making the check at caller side, thought it preferable.",
      "parentUuid": "44f8f71b_458a6124",
      "revId": "3cc3fbe103fb4b99e9dbbd2495d721da3fbb5f02",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7736fac6_8e8ddb41",
        "filename": "lib/el3_runtime/aarch64/context_mgmt.c",
        "patchSetId": 3
      },
      "lineNbr": 488,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2023-02-10T12:58:40Z",
      "side": 1,
      "message": "Hmm, It is better to have consistent pattern for enable/disable and save/restore.\n\nI realized that the save and restore helpers are doing the check inside the implementation. Which means that either save/restore would need to move the check to the caller as well or enable/disable would need to have the checks inside them.\n\nIn the case save/restore, if we want to support different dispatchers to independently control this via separate build config options, then the check has to be done at caller side. Today I believe we dont have such a case. But a hypothetical case would be, say RMMD_ENABLE_FGT :\n\nrmmd_init() {\n\nif (is_fgt_supported() \u0026\u0026 RMMD_ENABLE_FGT)\n   enable_fgt(REALM);\n\n}\n\nrmmd_smc_handler() {\n\nif (is_fgt_supported() \u0026\u0026 RMMD_ENABLE_FGT)\n   el2_save_fgt_context();\n\n---\n}\n\nWe should align enable/disable and save/restore whichever direction we take",
      "parentUuid": "f30a5e8d_84ca6ba2",
      "revId": "3cc3fbe103fb4b99e9dbbd2495d721da3fbb5f02",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7bdd0333_be7b1f0a",
        "filename": "lib/el3_runtime/aarch64/context_mgmt.c",
        "patchSetId": 3
      },
      "lineNbr": 488,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2023-02-10T13:08:25Z",
      "side": 1,
      "message": "It seems only el2_sysregs_context_save_mpam() and \tel2_sysregs_context_save_fgt() have checks inside the caller whereas rest of EL2 context operations have checks in caller side. So might be better to move the checks to caller side for these as well.",
      "parentUuid": "7736fac6_8e8ddb41",
      "revId": "3cc3fbe103fb4b99e9dbbd2495d721da3fbb5f02",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f495201f_62f4798a",
        "filename": "lib/el3_runtime/aarch64/context_mgmt.c",
        "patchSetId": 3
      },
      "lineNbr": 488,
      "author": {
        "id": 1000883
      },
      "writtenOn": "2023-02-10T13:31:59Z",
      "side": 1,
      "message": "Wouldn\u0027t having separate enables for each context make sense? For example, a refactor I wanted to do to untangle the root context out of the various context setting routines is spinning out the el2 enables when el2 is empty (again using SPE as an example). In that case there would be lots of ways to enter the extension and checking there makes more sense to me.",
      "parentUuid": "7bdd0333_be7b1f0a",
      "revId": "3cc3fbe103fb4b99e9dbbd2495d721da3fbb5f02",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1f495477_06381d87",
        "filename": "lib/el3_runtime/aarch64/context_mgmt.c",
        "patchSetId": 3
      },
      "lineNbr": 488,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2023-02-10T14:03:17Z",
      "side": 1,
      "message": "Yes, that is also a possible soln. el2_empty is a legacy config which probably needs to be removed. In most cases, the code to enable a feature for NS/S/Realm is the same. The root world might need a different variant.\n\nAnother thing which I haven\u0027t thought through is, we have different flavours of SPDs although there is only SPMD for S-El2 in TF-A. If we had a enable_mte_secure() which internally assumes Hafnium SPMD, that may trip up other SPDs.\n\nSome of this is speculation and I dont have a strong argument in favour of either direction. Perhaps, we just do what makes most sense today and then refactor as we need when situation arises. We just need to be consistent through out, that is the important thing.",
      "parentUuid": "f495201f_62f4798a",
      "revId": "3cc3fbe103fb4b99e9dbbd2495d721da3fbb5f02",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "dda06d96_f353cf09",
        "filename": "lib/extensions/trbe/trbe.c",
        "patchSetId": 3
      },
      "lineNbr": 53,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2023-02-10T10:40:54Z",
      "side": 1,
      "message": "Just a comment not related to this patch. TRBE buffers should be drained when entering Realm world as well. Will take a action to see if this scheme will scale for Realm world.",
      "range": {
        "startLine": 53,
        "startChar": 19,
        "endLine": 53,
        "endChar": 43
      },
      "revId": "3cc3fbe103fb4b99e9dbbd2495d721da3fbb5f02",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    }
  ]
}