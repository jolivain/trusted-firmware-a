{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "5ac2b779_6a26fb46",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1000043
      },
      "writtenOn": "2022-10-27T14:14:22Z",
      "side": 1,
      "message": "It took me a while to understand the issue that this patch is trying to solve but I think I managed to get my head around it now. Please let me check my understanding with you.\n\nThe authentication framework in TF-A currently assumes that:\n- the ROTPK stored in a root certificate\n- the ROTPK (or a hash of it) stored in hardware protected storage\nmatch.\n\nThis is true on all platforms I know about, but *not* on STM32MP1 platforms. On STMP32MP1, the OTP memory does not hold (ROTPK#) but rather (curve-id || ROTPK#) [1].\n\nBecause they do not match, the last step of a root certificate signature verification, which is checking the validity of the subject public key from the root certificate against the hardware-provided hash, fails.\n\nThis is why you need a function (plat_get_hashed_key()) to convert:\n- the ROTPK from the root certificate \n- into: cid || ROTPK from the root certificate.\n\nIt\u0027s the only way to solve the issue. You cannot take the problem the other way around and convert the OTP hash, from #(cid || ROTPK) to #(ROTPK) because this is not how hashes work, you cannot \"unhash\" the data...\n\nThe commit message, and also to some degree the porting guide updates, emphasize on DER format vs plain key incompatibilities but I believe this is not the main issue here. You do encode the hash value retrieved from OTP into DER format (in plat_get_rotpk_hash()), and flatten/strip out the DER header on the other side (in crypto_verify_hash()). The main issue here rather is what\u0027s (arguably briefly) referred to as \"a platform specific encapsulated public key\" (cid || ROTPK in your case).\n\nIs my understanding correct?\n\nAssuming it is, I\u0027ve got a few comments:\n\n1. I am not convinved this is the best approach to solve the issue. I can see how this new plat_get_hashed_pk() solves the issue, and I can see such a conversion will be needed at some point in the flow ; I am just not sure this is the best place to do it.\n\nPerhaps a more elegant way would be to introduce a new platform hook to check the correctness of the public key extracted from a root certificate. The default implementation would remain\na. compute hash of certificate key\nb. get ROTPK hash from platform\nc. Compare a. and b.\nbut platforms like STM32MP1 could deviate from that.\n\nI need more time to think about it... I might end up reaching the same conclusion as you!\n\n2. The name plat_get_hashed_pk() confuses me. With such a name, I was expecting it would return the hash of a key (hashed_key) but IIUC it rathers return a full key: the key whose hash matches the OTP one.\n\nI don\u0027t have any good alternatives to suggest at the moment, I\u0027ll try to find something.\n\n3. plat_get_hashed_pk() is a new weak function, while we are trying to get rid of weak functions as much as possible in TF-A project because it can be hard in some cases to reason about them and be sure which implementation actually gets pulled into the firmware. We\u0027ve even had bugs because of weak functions in the past.\n\nSimilarly here, if we go with the plat_get_hashed_pk() approach, I would like us to implement it for every platform. This would mean that the default (weak) implementation you\u0027ve provided in this patch could be moved under plat/common/ (as a \"strong\" function) and all platforms for which this is a suitable implementation would pull it from their makefile. It does mean we\u0027ll need to update all platforms makefiles. But I believe it\u0027s better to make that decision consciously rather than silently introducing a new platform hook, without other platform maintainers necessarily realizing it.\n\n[1] || here is the concatenation operator.",
      "revId": "c7a49b3556cb6d5c09daa744d71256cde8341837",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c0432d4e_881e1aed",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1000144
      },
      "writtenOn": "2022-10-28T10:03:34Z",
      "side": 1,
      "message": "You\u0027re fully right in your analysis. The key point is that we manage different ECC curves and we want to introduce (to increase the robustness) the curve ID uses to generate the HASH.\nIt means that, the way we retrieve the key from certificate or verify the signature from the key is standard, but the HASH in our OTP doesn\u0027t fully correspond to the HASH of the key only, need to concatenate the curve ID as you mentioned.\n\n1. a. Extract the key:\nThe problem here is that the key extract in the first round is to verify the signature, without any modification.\nb. Compare the key using the crypto_mod_verify_hash which is a generic function that verify the public key against a hash part.\nIt remains difficult in this standard approach to manage this platform specific configuration.\n\n2. Agree with you, the naming is not really adapted as the function doesn\u0027t give a hashed_pk but the public key + addons with a new size. Name has to be updated.\n\n3. I\u0027m aligned with you about weak functions that are no so easy to maintain and are potentially causing bugs. On the first step, we\u0027ve write in the same way the plat_get_enc_key_info is made (except the pragma and the generic function is defined in the auth_mod.c file).\n\nLet me know if you\u0027ve got some implementation idea that can avoid this if you prefer no merging in that way.",
      "parentUuid": "5ac2b779_6a26fb46",
      "revId": "c7a49b3556cb6d5c09daa744d71256cde8341837",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "17299925_6fe9d73a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1000043
      },
      "writtenOn": "2022-10-28T14:37:49Z",
      "side": 1,
      "message": "\u003e 1. a. Extract the key:\n\u003e The problem here is that the key extract in the first round is to verify the signature, without any modification.\n\nYes, so we\u0027ve got to keep this part untouched.\n* That\u0027s the img_parser_get_auth_param() call to get the subject public key from the certificate\n* and the subsequent crypto_mod_verify_signature() call to check the certificate signature against the subject public key.\n\n\u003e b. Compare the key using the crypto_mod_verify_hash which is a generic function that verify the public key against a hash part.\n\u003e It remains difficult in this standard approach to manage this platform specific configuration.\n\nYes, I agree that\u0027s the part to change to fit your use case.\n* That\u0027s the plat_get_rotpk_info() call to retrieve the ROTPK hash (or platform-specific hash in your case)\n* and the subsequent crypto_mod_verify_hash() call, which is just a generic hash verification function, as you said.\n\nWhat I was initially suggesting was to replace the last call to crypto_mod_verify_hash() by some platform specific function, say plat_check_rotpk(), which would receive in input\n* the result from plat_get_rotpk_info()\n* and the subject public key extracted from the root certificate.\n\nAnd the default implementation of plat_check_rotpk() would just call crypto_mod_verify_hash(), while ST platforms would essentially concatenate the curve it to the input rotpk then only call crypto_mod_verify_hash().\n\nSomething like that... Unfortunately, I\u0027ve not had time to think more about it and I will be on leave next week...\n\nAs it stands, I am a little bit uncomfortable merging the patch as it is. At the very least I\u0027d like plat_get_hashed_pk() to be renamed but you\u0027ve already agreed to that ðŸ˜Š. And ditto for not making that a weak function.\n\nBut then it\u0027s a different question whether we stick to the current plat_get_hashed_pk() approach or move to the plat_check_rotpk() approach or do something different.\n\nI\u0027m gonna add a couple of folks in review, who usually have an interested in trusted boot and security related features. Also, other Arm folks might chime in.",
      "parentUuid": "c0432d4e_881e1aed",
      "revId": "c7a49b3556cb6d5c09daa744d71256cde8341837",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    }
  ]
}