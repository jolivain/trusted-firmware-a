{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "80b2acd0_b0fe4108",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000464
      },
      "writtenOn": "2021-08-13T07:04:28Z",
      "side": 1,
      "message": "Please review.",
      "revId": "ebb97f97e22476bff3e40ef4ab56518ffc48e0f4",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "06d5007b_ddfa1c67",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000162
      },
      "writtenOn": "2021-08-23T14:39:46Z",
      "side": 1,
      "message": "I see differences between bakery_lock and spinlock implementation in the way they use caches. The intent should be to get both of them inline instead of updating the spm_mm code. That would mean updating spinlock.S instead.\n\n@Ming did you also try USE_SPINLOCK_CAS? ",
      "revId": "ebb97f97e22476bff3e40ef4ab56518ffc48e0f4",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4231afc0_401f2186",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000464
      },
      "writtenOn": "2021-08-24T04:20:57Z",
      "side": 1,
      "message": "I try USE_SPINLOCK_CAS, it hang also and then I try bakery_lock. bakery_lock works in my platform. What means about this result? Should I send a patch to review for replace spinlock with bakery_lock?\n\nThanks!\n\nMy changes:\n--- a/Atf/services/std_svc/spm_mm/spm_mm_main.c\n+++ b/Atf/services/std_svc/spm_mm/spm_mm_main.c\n@@ -14,7 +14,7 @@\n #include \u003ccommon/runtime_svc.h\u003e\n #include \u003clib/el3_runtime/context_mgmt.h\u003e\n #include \u003clib/smccc.h\u003e\n-#include \u003clib/spinlock.h\u003e\n+#include \u003clib/bakery_lock.h\u003e\n #include \u003clib/utils.h\u003e\n #include \u003clib/xlat_tables/xlat_tables_v2.h\u003e\n #include \u003cplat/common/platform.h\u003e\n@@ -34,9 +34,9 @@ static sp_context_t sp_ctx;\n  ******************************************************************************/\n void sp_state_set(sp_context_t *sp_ptr, sp_state_t state)\n {\n-       spin_lock(\u0026(sp_ptr-\u003estate_lock));\n+       bakery_lock_get(\u0026(sp_ptr-\u003estate_lock));\n        sp_ptr-\u003estate \u003d state;\n-       spin_unlock(\u0026(sp_ptr-\u003estate_lock));\n+       bakery_lock_release(\u0026(sp_ptr-\u003estate_lock));\n }\n \n /*******************************************************************************\n@@ -48,7 +48,7 @@ void sp_state_wait_switch(sp_context_t *sp_ptr, sp_state_t from, sp_state_t to)\n        int success \u003d 0;\n \n        while (success \u003d\u003d 0) {\n-               spin_lock(\u0026(sp_ptr-\u003estate_lock));\n+               bakery_lock_get(\u0026(sp_ptr-\u003estate_lock));\n \n                if (sp_ptr-\u003estate \u003d\u003d from) {\n                        sp_ptr-\u003estate \u003d to;\n@@ -56,7 +56,7 @@ void sp_state_wait_switch(sp_context_t *sp_ptr, sp_state_t from, sp_state_t to)\n                        success \u003d 1;\n                }\n \n-               spin_unlock(\u0026(sp_ptr-\u003estate_lock));\n+               bakery_lock_release(\u0026(sp_ptr-\u003estate_lock));\n        }\n }\n \ndiff --git a/Atf/services/std_svc/spm_mm/spm_mm_private.h b/Atf/services/std_svc/spm_mm/spm_mm_private.h\nindex 45b4789a..78a41bd8 100644\n--- a/Atf/services/std_svc/spm_mm/spm_mm_private.h\n+++ b/Atf/services/std_svc/spm_mm/spm_mm_private.h\n@@ -48,7 +48,7 @@ typedef struct sp_context {\n        xlat_ctx_t *xlat_ctx_handle;\n \n        sp_state_t state;\n-       spinlock_t state_lock;\n+       bakery_lock_t state_lock;\n } sp_context_t;",
      "parentUuid": "06d5007b_ddfa1c67",
      "revId": "ebb97f97e22476bff3e40ef4ab56518ffc48e0f4",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0634d1cf_a3f4bcf4",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000162
      },
      "writtenOn": "2021-08-24T07:32:09Z",
      "side": 1,
      "message": "IIUC, bakery lock works because it takes care of data coherency. I believe, if we add the same logic to spinlock.S it will work too.\n\nWe should ask the spm_mm owner how they want to proceed. @Joanna do you know who that would be?",
      "parentUuid": "4231afc0_401f2186",
      "revId": "ebb97f97e22476bff3e40ef4ab56518ffc48e0f4",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bb559e0c_01ac094e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2021-08-24T19:10:12Z",
      "side": 1,
      "message": "if bakery locks succeeds, it means you are having coherency issues (which i suspected from your attempt to invalidate/clean caches). This likely means your spin lock variable is not living in memory marked coherent, or if marked coherent, in memory such as SRAM, that does not support exclusive monitors, for example. This is not an issue with the existing code, since it expects that the memory in which spinlocks exists is in normal, cacheable, inner shareable memory and your hardware must support that for the memory at which this spin lock lives..\nI dont think there is anything to be fixed in code, until we determine the cause for your coherency issues.",
      "parentUuid": "0634d1cf_a3f4bcf4",
      "revId": "ebb97f97e22476bff3e40ef4ab56518ffc48e0f4",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0fa21949_353ce528",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2021-08-24T19:11:07Z",
      "side": 1,
      "message": "\" in memory such as SRAM, that does not support exclusive monitors, for example. \" should really be \"in memory such as SRAM, that MAY not support exclusive monitors\".",
      "parentUuid": "bb559e0c_01ac094e",
      "revId": "ebb97f97e22476bff3e40ef4ab56518ffc48e0f4",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "31574d39_17794195",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000162
      },
      "writtenOn": "2021-08-24T19:45:45Z",
      "side": 1,
      "message": "I would like to understand the platform configuration before saying that the code has no flaws. It might be a case where updates from one CPU cluster need additional cache operations to be visible to another CPU cluster. But this is  speculation. @Ming, can you state your platform configuration and the test scenario? Also how is your cache set up? Do you have L3 caches that requires extra cache ops?",
      "parentUuid": "0fa21949_353ce528",
      "revId": "ebb97f97e22476bff3e40ef4ab56518ffc48e0f4",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2f2d26e0_72083572",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2021-08-24T20:38:30Z",
      "side": 1,
      "message": "Not sure what any of that has to do with spinlocks. Spinlocks are implemented using load-acquire/store-releases or CAS and they are arm architectural concepts and guarantees. If an implementation does not conform to them, then it cannot be an ARM SoC...If they do, then the coherency issue is likely because we are configuring things incorrectly or using the HW incorrectly.\nSure it is useful to understand the platform better, but i dont know how L3 caches would matter here...",
      "parentUuid": "31574d39_17794195",
      "revId": "ebb97f97e22476bff3e40ef4ab56518ffc48e0f4",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "71bfd6d9_807779e9",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000464
      },
      "writtenOn": "2021-08-25T02:08:21Z",
      "side": 1,
      "message": "Some configuration which i think is relative about this issue:\nWe use haps no real HW, is compatible with ARMv8.6, BL31 run at DRAM（PLAT_ARM_DRAM1_BASE） with attribute：\n#define SOC_CSS_MAP_DRAM_REMOTE_CHIP(n)\t\t\t\t\\\n\t\t\tMAP_REGION_FLAT(\t\t\t\\\n\t\t\t\tCSS_SGI_REMOTE_CHIP_MEM_OFFSET(n) +\\\n\t\t\t\tPLAT_ARM_DRAM1_BASE,\t\t\\\n\t\t\t\tPLAT_ARM_DRAM1_SIZE,\t\t\\\n\t\t\t\tMT_MEMORY | MT_RW | MT_NS\t\\\n\t\t\t)\n\nI am not sure which cache configuration is relative. The L3 caches is connect to CMN. AFAIK, no extra cache opt is requires.\n\nTest scenario:\nRegister a SPI(115) for error inject(ACPI:EINJ) with PLAT_RAS_PRI priority and other SPI for RAS.\n1 Use EINJ to tigger 115 interrupt and enter TF-A and then enter MM to inject a PCIe error, and delay about 1.5 second for injecting error.\n2 While the first core still in MM, the second core enter TF-A because PCIe error, and need enter MM for handling RAS.\n3 the second core wait in sp_state_wait_switch() for ever and the first core can\u0027t acquire the spin_lock for changing state.",
      "parentUuid": "2f2d26e0_72083572",
      "revId": "ebb97f97e22476bff3e40ef4ab56518ffc48e0f4",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d02c0d8a_c518df3f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2021-08-29T16:09:01Z",
      "side": 1,
      "message": "Yep, that definitely sounds like a coherency issue. If the second core acquires the spin lock and releases it in a loop (that\u0027s what sp_state_wait_switch() does) and the first core cannot acquire the spin lock it usually means coherency issue, or that the spin lock loop is so tight that the memory location for the spin lock gets bounced around that no forward progress is being made...\nTo eliminate the latter, can you put a few milliseconds of sleep in sp_state_wait_switch before the lock is acquired or lock is released? If there is a hang after that, this would definitely seem like a coherency issue (specially given that bakery locks are working).\nWe would need some debugger that can view cache state...or perhaps \"haps\", which i\u0027m not familiar with, has an option to turn off cache modeling...",
      "parentUuid": "71bfd6d9_807779e9",
      "revId": "ebb97f97e22476bff3e40ef4ab56518ffc48e0f4",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d0945cb1_d0ac2574",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000464
      },
      "writtenOn": "2021-09-02T04:03:13Z",
      "side": 1,
      "message": "I add some print in sp_state_wait_switch before the lock is acquired. There is a hang also.",
      "parentUuid": "d02c0d8a_c518df3f",
      "revId": "ebb97f97e22476bff3e40ef4ab56518ffc48e0f4",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "29672db1_7a5761fe",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000162
      },
      "writtenOn": "2021-09-02T14:44:52Z",
      "side": 1,
      "message": "@Ming, now it makes sense. We have had our share of problems with haps in the past. Since this issue is not seen with a \"real\" HW, it is hard to justify the change. But, the discussion to use bakery_locks instead of spinlock should be had with the owner. Although, you will need a strong justification.\n\nCan you discuss this issue with the haps vendor? Also review section B2.9 from the Arm ARM with them to see if the behavior described there matches their implementation.",
      "parentUuid": "d0945cb1_d0ac2574",
      "revId": "ebb97f97e22476bff3e40ef4ab56518ffc48e0f4",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2600e845_b25edeae",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000464
      },
      "writtenOn": "2021-09-05T07:49:07Z",
      "side": 1,
      "message": "Ok, i will try to discuss with them.\n\nThanks.",
      "parentUuid": "29672db1_7a5761fe",
      "revId": "ebb97f97e22476bff3e40ef4ab56518ffc48e0f4",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9c9ab388_ff39704d",
        "filename": "services/std_svc/spm_mm/spm_mm_main.c",
        "patchSetId": 1
      },
      "lineNbr": 53,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2021-08-20T01:06:01Z",
      "side": 1,
      "message": "sorry, where is the deadlock? the deadlock cannot happen because the loop acquires and releases the lock always....\ncore 1 changes state and executes mm, when it wants to release it, it will be able to acquire the lock when the second core releases it since it is not indefinitely holding the lock..",
      "range": {
        "startLine": 51,
        "startChar": 2,
        "endLine": 53,
        "endChar": 19
      },
      "revId": "ebb97f97e22476bff3e40ef4ab56518ffc48e0f4",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8b00e57d_b4e6d2d8",
        "filename": "services/std_svc/spm_mm/spm_mm_main.c",
        "patchSetId": 1
      },
      "lineNbr": 53,
      "author": {
        "id": 1000464
      },
      "writtenOn": "2021-08-21T07:50:19Z",
      "side": 1,
      "message": "In my test, core 1 can\u0027t acquire the lock. After modify with this patch, it works.\nMay be some wrong with the lib/locks/exclusive/aarch64/spinlock.S ?\nHas anyone done an experiment like me? The first core enter MM and the second core wait to enter MM.",
      "parentUuid": "9c9ab388_ff39704d",
      "range": {
        "startLine": 51,
        "startChar": 2,
        "endLine": 53,
        "endChar": 19
      },
      "revId": "ebb97f97e22476bff3e40ef4ab56518ffc48e0f4",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "51d94a79_70f48435",
        "filename": "services/std_svc/spm_mm/spm_mm_main.c",
        "patchSetId": 1
      },
      "lineNbr": 53,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2021-08-21T15:06:36Z",
      "side": 1,
      "message": "this has been used in the wild for a while so i\u0027m sure this has been tested. one possible approach to figure out if it is an issue is to use tftf to stress this code on fvp and then some real hardware..\nspinlock.S has been around a while and is widely used so would think something is wrong only after exhausting other possibilities.\n\nsecond core is SUPPOSED to wait for first core to finish by design. Standalone MM partition is not re-entrant or multi-threaded which is why the spinlock and state machine exists.. are you expecting to enter MM on multiple cores?",
      "parentUuid": "8b00e57d_b4e6d2d8",
      "range": {
        "startLine": 51,
        "startChar": 2,
        "endLine": 53,
        "endChar": 19
      },
      "revId": "ebb97f97e22476bff3e40ef4ab56518ffc48e0f4",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9055fc87_287c0508",
        "filename": "services/std_svc/spm_mm/spm_mm_main.c",
        "patchSetId": 1
      },
      "lineNbr": 53,
      "author": {
        "id": 1000464
      },
      "writtenOn": "2021-08-22T03:59:50Z",
      "side": 1,
      "message": "I just expect one core enter MM, another core should wait the first core finish and then enter MM, not enter MM simultaneously.\n\nI use on haps not real hardware. My test:\nRegister one spi interrupt in TF-A for error inject(einj). While the spi interrupt tigger, enter MM and inject one RAS error in MM. Another core enter TF-A because RAS interrupt and wait to enter MM. Found the first core can\u0027t acquire the lock to exit MM and the second core wait for ever.",
      "parentUuid": "51d94a79_70f48435",
      "range": {
        "startLine": 51,
        "startChar": 2,
        "endLine": 53,
        "endChar": 19
      },
      "revId": "ebb97f97e22476bff3e40ef4ab56518ffc48e0f4",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4d12c265_3cb06626",
        "filename": "services/std_svc/spm_mm/spm_mm_main.c",
        "patchSetId": 1
      },
      "lineNbr": 53,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2021-08-22T04:42:43Z",
      "side": 1,
      "message": "i dont see how that can happen in code. Are you seeing your second core stuck in the loop within the spin_lock function? is it possible that the MM on the first core never returned or hung since it crashed due to which the second core is unable to make progress?",
      "parentUuid": "9055fc87_287c0508",
      "range": {
        "startLine": 51,
        "startChar": 2,
        "endLine": 53,
        "endChar": 19
      },
      "revId": "ebb97f97e22476bff3e40ef4ab56518ffc48e0f4",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1a34a102_8c5e29bf",
        "filename": "services/std_svc/spm_mm/spm_mm_main.c",
        "patchSetId": 1
      },
      "lineNbr": 53,
      "author": {
        "id": 1000464
      },
      "writtenOn": "2021-08-22T14:39:58Z",
      "side": 1,
      "message": "I add debug log in sp_state_set() and sp_state_wait_switch().\nThe second core stuck in the loop but not within the spin_lock always. The first core go to sp_state_set(), but can\u0027t acquire the spin_lock.\n\nDebug code:\nvoid sp_state_set(sp_context_t *sp_ptr, sp_state_t state)\n{\n\tINFO(\"--exitmm:\\n\");\n\tspin_lock(\u0026(sp_ptr-\u003estate_lock));\n\tINFO(\"--get lock:\\n\");\n\tsp_ptr-\u003estate \u003d state;\n\tspin_unlock(\u0026(sp_ptr-\u003estate_lock));\n\tINFO(\"--unlock:\\n\");\n}\n\nvoid sp_state_wait_switch(sp_context_t *sp_ptr, sp_state_t from, sp_state_t to)\n{\n\tint success \u003d 0;\n\tint i \u003d 0;\n\n\twhile (success \u003d\u003d 0) {\n\t\tspin_lock(\u0026(sp_ptr-\u003estate_lock));\n\t\tif ((i % 10000) \u003d\u003d 0) INFO(\"--wait:%d\\n\", i);\n\t\ti++;\n\t\tinv_dcache_range ((uint64_t)\u0026sp_ptr-\u003estate, 8);\n\t\tif (sp_ptr-\u003estate \u003d\u003d from) {\n\t\t\tsp_ptr-\u003estate \u003d to;\n\t\t\tclean_dcache_range ((uint64_t)\u0026sp_ptr-\u003estate, 8);\n\n\t\t\tsuccess \u003d 1;\n\t\t}\n\t\tspin_unlock(\u0026(sp_ptr-\u003estate_lock));\n\t}\n}\n-----------------\nDebug log:\n[root@m1rootfs einj]$echo 1 \u003e error_inject\nINFO:    Core[0](0x81000000) received ras intr\u003d115, cnt\u003d3.\nINFO:    --wait:0\nEinj ErrType:100 Flags:1, ApicId:0\nInject PCIe error S:0 B:0 D:2 F:0\nRpEcam:50010000 DevEcam:50200000 VsecOffset:334\nINFO:    Core[1](0x81010000) received ras intr\u003d415, cnt\u003d1.\nINFO:    --wait:0\nINFO:    --exitmm:\nINFO:    --wait:10000\nINFO:    --wait:20000\nINFO:    --wait:30000\nINFO:    --wait:40000\nINFO:    --wait:50000\nINFO:    --wait:60000\n...",
      "parentUuid": "4d12c265_3cb06626",
      "range": {
        "startLine": 51,
        "startChar": 2,
        "endLine": 53,
        "endChar": 19
      },
      "revId": "ebb97f97e22476bff3e40ef4ab56518ffc48e0f4",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f05632bc_8a802321",
        "filename": "services/std_svc/spm_mm/spm_mm_main.c",
        "patchSetId": 1
      },
      "lineNbr": 53,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2021-08-23T02:40:17Z",
      "side": 1,
      "message": "i see statements that invalidate and clean dcache range that isnt in the original code. if that fixes the issue, it probably means memory is not marked appropriately and you are having coherency issues. is the sp_context_t structure in normal cacheable and coherent memory?\ni\u0027ve seen issues where some SRAM\u0027s where BL31 runs from, does not necessarily support exclusive monitors and cannot use load exclusive and store exclusive instructions.",
      "parentUuid": "1a34a102_8c5e29bf",
      "range": {
        "startLine": 51,
        "startChar": 2,
        "endLine": 53,
        "endChar": 19
      },
      "revId": "ebb97f97e22476bff3e40ef4ab56518ffc48e0f4",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "365554bf_bf276ffb",
        "filename": "services/std_svc/spm_mm/spm_mm_main.c",
        "patchSetId": 1
      },
      "lineNbr": 53,
      "author": {
        "id": 1000464
      },
      "writtenOn": "2021-08-23T11:58:05Z",
      "side": 1,
      "message": "The issue can\u0027t be fixed only add dcache maintenance. The sp_context is in range ARM_AP_TZC_DRAM1_BASE(DDR space), which is default configuration. I think it is normal cacheable and coherent memory.",
      "parentUuid": "f05632bc_8a802321",
      "range": {
        "startLine": 51,
        "startChar": 2,
        "endLine": 53,
        "endChar": 19
      },
      "revId": "ebb97f97e22476bff3e40ef4ab56518ffc48e0f4",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5bc80934_bac5b11e",
        "filename": "services/std_svc/spm_mm/spm_mm_main.c",
        "patchSetId": 1
      },
      "lineNbr": 53,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2021-08-23T14:19:21Z",
      "side": 1,
      "message": "alright, what other changes did you have to make to fix the issue on your build?\ni\u0027m not seeing how this code can dead lock..",
      "parentUuid": "365554bf_bf276ffb",
      "range": {
        "startLine": 51,
        "startChar": 2,
        "endLine": 53,
        "endChar": 19
      },
      "revId": "ebb97f97e22476bff3e40ef4ab56518ffc48e0f4",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "254ab7f4_b5bf4ade",
        "filename": "services/std_svc/spm_mm/spm_mm_main.c",
        "patchSetId": 1
      },
      "lineNbr": 53,
      "author": {
        "id": 1000464
      },
      "writtenOn": "2021-08-24T04:20:57Z",
      "side": 1,
      "message": "All changes were in this patch, no other changes. My comments is not accurate. The issue is not dead lock, but something wrong else.\n\nThanks.",
      "parentUuid": "5bc80934_bac5b11e",
      "range": {
        "startLine": 51,
        "startChar": 2,
        "endLine": 53,
        "endChar": 19
      },
      "revId": "ebb97f97e22476bff3e40ef4ab56518ffc48e0f4",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda"
    }
  ]
}