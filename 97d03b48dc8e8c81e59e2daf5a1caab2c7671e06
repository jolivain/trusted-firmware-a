{
  "comments": [
    {
      "key": {
        "uuid": "4e6f812c_e58f1ac8",
        "filename": "bl31/aarch64/runtime_exceptions.S",
        "patchSetId": 2
      },
      "lineNbr": 85,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2020-02-18T19:24:36Z",
      "side": 1,
      "message": "question. I understand the DSB before exiting EL3, that ensures that any async EA\u0027s caused by instructions in EL3 get handled before the ERET. What is the purpose of the DSB on EL3 entry ? To handle async EA\u0027s from lower EL\u0027s immediately?(assuming scr_el3.EA is set of course, otherwise they should be handled at the appropriate EL).",
      "range": {
        "startLine": 85,
        "startChar": 6,
        "endLine": 85,
        "endChar": 7
      },
      "revId": "97d03b48dc8e8c81e59e2daf5a1caab2c7671e06",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "202324be_5f012559",
        "filename": "bl31/aarch64/runtime_exceptions.S",
        "patchSetId": 2
      },
      "lineNbr": 85,
      "author": {
        "id": 1000098
      },
      "writtenOn": "2020-02-18T20:40:52Z",
      "side": 1,
      "message": "Yes. To handle async EA\u0027s from lower EL\u0027s immediately. A similar discussion can be found here:\nhttps://lore.kernel.org/patchwork/patch/846451/",
      "parentUuid": "4e6f812c_e58f1ac8",
      "range": {
        "startLine": 85,
        "startChar": 6,
        "endLine": 85,
        "endChar": 7
      },
      "revId": "97d03b48dc8e8c81e59e2daf5a1caab2c7671e06",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3f6a77ca_4e73cb8d",
        "filename": "bl31/aarch64/runtime_exceptions.S",
        "patchSetId": 2
      },
      "lineNbr": 85,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2020-02-18T20:56:30Z",
      "side": 1,
      "message": "Thanks. Another general/philosophical question, not intended to block the patch. If there is an instruction that causes an async external abort from lower EL(perhaps from speculative accesses), and scr_el3.EA is set, on entry into EL3, perhaps due to an SMC and executing the DSB here, the SError can trigger immediately and will appear on serror_sp_elx(since we havent yet changed to sp_el0), and serror_sp_elx calls the platform handler, which per the documentation is not supposed to return. Is this behavior we want ? This seems like it would violate 4.5.4. Handling recoverable errors of the coding guidelines document. If the plat handler is not expected to return and must be written in assembly, it would be relatively easy for the kernel running at NS-EL1/EL2 to trigger crashes in secure world easily.",
      "parentUuid": "202324be_5f012559",
      "range": {
        "startLine": 85,
        "startChar": 6,
        "endLine": 85,
        "endChar": 7
      },
      "revId": "97d03b48dc8e8c81e59e2daf5a1caab2c7671e06",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1a3568a8_0a236add",
        "filename": "bl31/aarch64/runtime_exceptions.S",
        "patchSetId": 2
      },
      "lineNbr": 85,
      "author": {
        "id": 1000056
      },
      "writtenOn": "2020-02-19T12:54:32Z",
      "side": 1,
      "message": "\u003e Is this behavior we want ?\n\nThat is a good point. The only action which BL31 does if an EA arrives while in EL3, is to panic and die. It is not prepared to handle Serror triggered in current EL (serror_sp_elx/serror_sp_el0). \n\nPart of the trouble is that there is no way to distinguish why the error triggered at serror_sp_elx/serror_sp_el0 whether it is due to explicit syncronization by entry code or a error in EL3 in which case there is usually no recovery.\n\nThe story is little different if RAS handling is enabled in BL31. This is because BL31 is expected to handle error as reflected in DISR_EL1. Even in this case, it is not prepared to `handle` the SEerror if it triggers at current EL at serror_sp_elx/serror_sp_el0 vectors\n\nSo I am leaning towards *not* adding the dsb sy for all entry if the end result is the system is just going to die (either in El3 due to plat_handle_el3_ea or in lower EL) till we understand the implication better.\n\n\u003e Handling recoverable errors of the coding guidelines document. If the plat handler is not\n\u003e expected to return and must be written in assembly, it would be relatively easy for the kernel \n\u003e running at NS-EL1/EL2 to trigger crashes in secure world easily.\n\nBy default, HANDLE_EA_EL3_FIRST is 0 which means the EA are not routed to EL3. This flag needs to be set when EL3 is expected to handle errors in which case (mostly RAS usecases). So in this case the EA triggers at serror_aarch64/serror_aarch32 which is supposedly prepared to handle it.\n\nBut there is a theoritical case that NS world will be able to cause an EA which will abort while executing in EL3 and will cause it to panic. So in this case, it can be argued that having the dsb() at entry of EL3 will cause an early panic which is better than EA during some sensitive secure world operation.",
      "parentUuid": "3f6a77ca_4e73cb8d",
      "range": {
        "startLine": 85,
        "startChar": 6,
        "endLine": 85,
        "endChar": 7
      },
      "revId": "97d03b48dc8e8c81e59e2daf5a1caab2c7671e06",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3e2b0e78_bbc160f8",
        "filename": "bl31/aarch64/runtime_exceptions.S",
        "patchSetId": 2
      },
      "lineNbr": 85,
      "author": {
        "id": 1000114
      },
      "writtenOn": "2020-02-19T15:25:53Z",
      "side": 1,
      "message": "Thanks for the response! Agree!",
      "parentUuid": "1a3568a8_0a236add",
      "range": {
        "startLine": 85,
        "startChar": 6,
        "endLine": 85,
        "endChar": 7
      },
      "revId": "97d03b48dc8e8c81e59e2daf5a1caab2c7671e06",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9c6edda0_15c09022",
        "filename": "lib/el3_runtime/aarch64/context.S",
        "patchSetId": 2
      },
      "lineNbr": 537,
      "author": {
        "id": 1000162
      },
      "writtenOn": "2020-02-18T19:14:34Z",
      "side": 1,
      "message": "I think this is concerning part of this patch as it adds latency to all exception returns. IIUC, we need this only when returning from a RAS exception? If yes, then is there a way to do this conditionally?",
      "range": {
        "startLine": 537,
        "startChar": 1,
        "endLine": 537,
        "endChar": 7
      },
      "revId": "97d03b48dc8e8c81e59e2daf5a1caab2c7671e06",
      "serverId": "8f6f209b-db1a-4cbf-aa44-c8bc30e9bfda",
      "unresolved": true
    }
  ]
}